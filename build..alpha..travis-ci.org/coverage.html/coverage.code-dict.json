{"/home/travis/build/npmtest/node-npmtest-deepstream.io/test.js":"/* istanbul instrument in package npmtest_deepstream_io */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/lib.npmtest_deepstream.io.js":"/* istanbul instrument in package npmtest_deepstream_io */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_deepstream_io = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_deepstream_io = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-deepstream.io && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_deepstream_io */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_deepstream_io\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_deepstream_io.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_deepstream_io.rollup.js'] =\n            local.assetsDict['/assets.npmtest_deepstream_io.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_deepstream_io.__dirname + '/lib.npmtest_deepstream_io.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/deepstream.io.js":"'use strict'\n\nconst ConnectionEndpoint = require('./message/connection-endpoint')\nconst MessageProcessor = require('./message/message-processor')\nconst MessageDistributor = require('./message/message-distributor')\nconst EventHandler = require('./event/event-handler')\nconst messageParser = require('./message/message-parser')\nconst readMessage = require('./utils/read-message')\nconst fs = require('fs')\nconst path = require('path')\nconst util = require('util')\nconst utils = require('./utils/utils')\nconst defaultOptions = require('./default-options')\nconst configInitialiser = require('./config/config-initialiser')\nconst jsYamlLoader = require('./config/js-yaml-loader')\nconst RpcHandler = require('./rpc/rpc-handler')\nconst RecordHandler = require('./record/record-handler')\nconst PresenceHandler = require('./presence/presence-handler')\nconst DependencyInitialiser = require('./utils/dependency-initialiser')\nconst ClusterRegistry = require('./cluster/cluster-registry')\nconst UniqueRegistry = require('./cluster/cluster-unique-state-provider')\nconst C = require('./constants/constants')\nconst pkg = require('../package.json')\n\nconst EventEmitter = require('events').EventEmitter\nconst EOL = require('os').EOL\n\nconst STATES = C.STATES\n\n/**\n * Deepstream is a realtime data server that scales horizontally\n * by running in clusters of interacting nodes\n *\n * @copyright 2016 deepstreamHub GmbH\n * @author deepstreamHub GmbH\n *\n * @param {Object} config Configuration object\n *\n * @constructor\n */\nconst Deepstream = function (config) {\n  this._currentState = STATES.CLOSED\n  this.constants = C\n  this._loadConfig(config)\n  this._connectionEndpoint = null\n  this._messageProcessor = null\n  this._messageDistributor = null\n  this._eventHandler = null\n  this._rpcHandler = null\n  this._recordHandler = null\n  this._plugins = [\n    'messageConnector',\n    'storage',\n    'cache',\n    'authenticationHandler',\n    'permissionHandler'\n  ]\n}\n\nutil.inherits(Deepstream, EventEmitter)\n\n/**\n * Sets the name of the process\n *\n * @type {String}\n */\nprocess.title = 'deepstream server'\n\n/**\n * Expose constants to allow consumers to access them without\n * requiring a reference to a deepstream instance.\n *\n *\n*/\nDeepstream.constants = C\n\n\n/**\n * Utility method to return a helper object to simplify permissions assertions\n *\n * @param  {object} message description\n * @return {object}         description\n */\nDeepstream.readMessage = readMessage\n\n/**\n * Set a deepstream option. For a list of all available options\n * please see default-options.\n *\n * @param {String} key   the name of the option\n * @param {Mixed} value  the value, e.g. a portnumber for ports or an instance of a logger class\n *\n * @public\n * @returns {void}\n */\nDeepstream.prototype.set = function (key, value) {\n  if (key === 'message') {\n    key = 'messageConnector' // eslint-disable-line\n  }\n\n  if (this._options[key] === undefined) {\n    throw new Error(`Unknown option \"${key}\"`)\n  }\n\n  this._options[key] = value\n  return this\n}\n\n/**\n * Returns true if the deepstream server is running, otherwise false\n *\n * @public\n * @returns {boolean}\n */\nDeepstream.prototype.isRunning = function () {\n  return this._currentState === STATES.IS_RUNNING\n}\n\n/**\n * Starts up deepstream. The startup process has three steps:\n *\n * - First of all initialise the logger and wait for it (ready event)\n * - Then initialise all other dependencies (cache connector, message connector, storage connector)\n * - Instantiate the messaging pipeline and record-, rpc- and event-handler\n * - Start WS server\n *\n * @public\n * @returns {void}\n */\nDeepstream.prototype.start = function () {\n  if (this._currentState !== STATES.CLOSED) {\n    throw new Error(`Server can only start after it stops succesfully, currently ${this._currentState}`)\n  }\n  this._currentState = STATES.STARTING\n  this._showStartLogo()\n  const loggerInitializer = new DependencyInitialiser(this._options, 'logger')\n  loggerInitializer.once('ready', this._start.bind(this))\n}\n\n/**\n * This is the actual function which starts deepstream. It is invoked after+\n * the logger was intialized or emitted the read event if it was initialized\n * asynchronously\n *\n * @private\n * @returns {void}\n */\nDeepstream.prototype._start = function () {\n  this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.INFO, `deepstream version: ${pkg.version}`)\n\n  // otherwise (no configFile) deepstream was invoked by API\n  if (this._configFile != null) {\n    this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.INFO, `configuration file loaded from ${this._configFile}`)\n  }\n\n  if (global.deepstreamLibDir) {\n    this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.INFO, `library directory set to: ${global.deepstreamLibDir}`)\n  }\n\n  let i\n  let initialiser\n\n  for (i = 0; i < this._plugins.length; i++) {\n    initialiser = new DependencyInitialiser(this._options, this._plugins[i])\n    initialiser.once('ready', this._checkReady.bind(this, this._plugins[i], initialiser.getDependency()))\n  }\n  this._checkReady('logger', this._options.logger)\n}\n\n/**\n * Stops the server and closes all connections. The server can be started again,\n * but all clients have to reconnect. Will emit a 'stopped' event once done\n *\n * @public\n * @returns {void}\n */\nDeepstream.prototype.stop = function () {\n  if (this._currentState !== STATES.IS_RUNNING) {\n    throw new Error(`Server can only be stopped after it starts succesfully, currently ${this._currentState}`)\n  }\n  this._currentState = STATES.CLOSING\n\n  let i\n  let plugin\n  const closables = [this._connectionEndpoint]\n\n  if (typeof this._options.logger.close === 'function') {\n    closables.push(this._options.logger)\n    setTimeout(this._options.logger.close.bind(this._options.logger))\n  }\n\n  for (i = 0; i < this._plugins.length; i++) {\n    plugin = this._options[this._plugins[i]]\n    if (typeof plugin.close === 'function') {\n      closables.push(plugin)\n      setTimeout(plugin.close.bind(plugin))\n    }\n  }\n\n  utils.combineEvents(closables, 'close', this._onStopped.bind(this))\n  this._options.clusterRegistry.leaveCluster()\n  this._connectionEndpoint.close()\n}\n\n/**\n * Expose the message-parser's convertTyped method\n * so that it can be used within permissionHandlers\n *\n * @param   {String} value A String starting with a type identifier (see C.TYPES)\n *\n * @public\n * @returns {mixed} the converted value\n */\nDeepstream.prototype.convertTyped = function (value) {\n  return messageParser.convertTyped(value)\n}\n\n/**\n * Synchronously loads a configuration file\n * Initialization of plugins and logger will be triggered by the\n * configInitialiser, but it should not block. Instead the ready events of\n * those plugins are handled through the DependencyInitialiser in this instnace.\n *\n * @param {Object} config Configuration object\n * @private\n * @returns {void}\n */\nDeepstream.prototype._loadConfig = function (config) {\n  if (config === null || typeof config === 'string') {\n    const result = jsYamlLoader.loadConfig(config)\n    this._configFile = result.file\n    config = result.config // eslint-disable-line\n  } else {\n    const rawConfig = utils.merge(defaultOptions.get(), config)\n    config = configInitialiser.initialise(rawConfig) // eslint-disable-line\n  }\n  this._options = config\n}\n\n/**\n * Callback for the final stop event\n *\n * @private\n * @returns {void}\n */\nDeepstream.prototype._onStopped = function () {\n  this._currentState = STATES.CLOSED\n  this.emit('stopped')\n}\n\n/**\n * Shows a giant ASCII art logo which is absolutely crucial\n * for the proper functioning of the server\n *\n * @private\n * @returns {void}\n */\nDeepstream.prototype._showStartLogo = function () {\n  if (this._options.showLogo !== true) {\n    return\n  }\n  /* istanbul ignore next */\n  let logo\n\n  try {\n    const nexeres = require('nexeres') // eslint-disable-line\n    logo = nexeres.get('ascii-logo.txt').toString('ascii')\n  } catch (e) {\n    logo = fs.readFileSync(path.join(__dirname, '..', '/ascii-logo.txt'), 'utf8')\n  }\n\n  /* istanbul ignore next */\n  process.stdout.write(logo + EOL)\n  process.stdout.write(` =========================   starting   ==========================${EOL}`)\n}\n\n/**\n * Invoked once all dependencies are initialised. Instantiates the messaging pipeline and\n * the various handlers.\n * The startup sequence will be complete once the connection endpoint is started and listening\n *\n * @private\n * @returns {void}\n */\nDeepstream.prototype._init = function () {\n  this._connectionEndpoint = new ConnectionEndpoint(this._options, this._onStarted.bind(this))\n  this._messageProcessor = new MessageProcessor(this._options)\n  this._messageDistributor = new MessageDistributor(this._options)\n  this._connectionEndpoint.onMessage = this._messageProcessor.process.bind(this._messageProcessor)\n\n  this._options.clusterRegistry = new ClusterRegistry(this._options, this._connectionEndpoint)\n  this._options.uniqueRegistry = new UniqueRegistry(this._options, this._options.clusterRegistry)\n\n  this._eventHandler = new EventHandler(this._options)\n  this._messageDistributor.registerForTopic(\n    C.TOPIC.EVENT,\n    this._eventHandler.handle.bind(this._eventHandler)\n  )\n\n  this._rpcHandler = new RpcHandler(this._options)\n  this._messageDistributor.registerForTopic(\n    C.TOPIC.RPC,\n    this._rpcHandler.handle.bind(this._rpcHandler)\n  )\n\n  this._recordHandler = new RecordHandler(this._options)\n  this._messageDistributor.registerForTopic(\n    C.TOPIC.RECORD,\n    this._recordHandler.handle.bind(this._recordHandler)\n  )\n\n  this._options.connectionEndpoint = this._connectionEndpoint\n  this._presenceHandler = new PresenceHandler(this._options)\n  this._messageDistributor.registerForTopic(\n    C.TOPIC.PRESENCE,\n    this._presenceHandler.handle.bind(this._presenceHandler)\n  )\n\n  this._messageProcessor.onAuthenticatedMessage =\n      this._messageDistributor.distribute.bind(this._messageDistributor)\n\n  if (this._options.permissionHandler.setRecordHandler) {\n    this._options.permissionHandler.setRecordHandler(this._recordHandler)\n  }\n\n  this._currentState = STATES.INITIALIZED\n}\n\n/**\n * Called whenever a dependency emits a ready event. Once all dependencies are ready\n * deepstream moves to the init step.\n *\n * @private\n * @returns {void}\n */\nDeepstream.prototype._checkReady = function (pluginName, plugin) {\n  if (plugin instanceof EventEmitter) {\n    plugin.on('error', this._onPluginError.bind(this, pluginName))\n  }\n\n  for (let i = 0; i < this._plugins.length; i++) {\n    if (this._options[this._plugins[i]].isReady !== true) {\n      return\n    }\n  }\n\n  if (this._currentState === STATES.STARTING) {\n    this._init()\n  }\n}\n\n/**\n * Final callback - Deepstream is up and running now\n *\n * @private\n * @returns {void}\n */\nDeepstream.prototype._onStarted = function () {\n  this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.INFO, 'Deepstream started')\n  this._currentState = STATES.IS_RUNNING\n  this.emit('started')\n}\n\n/**\n * Callback for plugin errors that occur at runtime. Errors during initialisation\n * are handled by the DependencyInitialiser\n *\n * @param   {String} pluginName\n * @param   {Error} error\n *\n * @private\n * @returns {void}\n */\nDeepstream.prototype._onPluginError = function (pluginName, error) {\n  const msg = `Error from ${pluginName} plugin: ${error.toString()}`\n  this._options.logger.log(C.LOG_LEVEL.ERROR, C.EVENT.PLUGIN_ERROR, msg)\n}\n\nmodule.exports = Deepstream\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/message/connection-endpoint.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst messageParser = require('./message-parser')\nconst messageBuilder = require('./message-builder')\nconst SocketWrapper = require('./socket-wrapper')\nconst events = require('events')\nconst http = require('http')\nconst https = require('https')\nconst uws = require('uws')\n\nconst OPEN = 'OPEN'\n\n/**\n * This is the frontmost class of deepstream's message pipeline. It receives\n * connections and authentication requests, authenticates sockets and\n * forwards messages it receives from authenticated sockets.\n *\n * @constructor\n *\n * @extends events.EventEmitter\n *\n * @param {Object} options the extended default options\n * @param {Function} readyCallback will be invoked once both the ws is ready\n */\nmodule.exports = class ConnectionEndpoint extends events.EventEmitter {\n  constructor (options, readyCallback) {\n    super()\n    this._options = options\n    this._readyCallback = readyCallback\n\n    this._wsReady = false\n    this._wsServerClosed = false\n\n    this._server = this._createHttpServer()\n    this._server.listen(this._options.port, this._options.host)\n    this._server.on('request', this._handleHealthCheck.bind(this))\n    this._options.logger.log(\n      C.LOG_LEVEL.INFO,\n      C.EVENT.INFO,\n      `Listening for health checks on path ${options.healthCheckPath}`\n    )\n\n    this._ws = new uws.Server({\n      server: this._server,\n      perMessageDeflate: false,\n      path: this._options.urlPath\n    })\n    this._ws.startAutoPing(\n      this._options.heartbeatInterval,\n      messageBuilder.getMsg(C.TOPIC.CONNECTION, C.ACTIONS.PING)\n    )\n    this._server.once('listening', this._checkReady.bind(this))\n    this._ws.on('error', this._onError.bind(this))\n    this._ws.on('connection', this._onConnection.bind(this))\n\n    this._authenticatedSockets = []\n  }\n\n  /**\n   * Called for every message that's received\n   * from an authenticated socket\n   *\n   * This method will be overridden by an external class and is used instead\n   * of an event emitter to improve the performance of the messaging pipeline\n   *\n   * @param   {SocketWrapper} socketWrapper\n   * @param   {String} message the raw message as sent by the client\n   *\n   * @public\n   *\n   * @returns {void}\n   */\n  onMessage (socketWrapper, message) { // eslint-disable-line\n  }\n\n  /**\n   * Closes the ws server connection. The ConnectionEndpoint\n   * will emit a close event once succesfully shut down\n   * @public\n   * @returns {void}\n   */\n  close () {\n    this._server.removeAllListeners('request')\n    this._ws.removeAllListeners('connection')\n    this._ws.close()\n\n    this._server.close(() => {\n      this._wsServerClosed = true\n      this._checkClosed()\n    })\n  }\n\n  /**\n   * Returns the number of currently connected clients. This is used by the\n   * cluster module to determine loadbalancing endpoints\n   *\n   * @public\n   * @returns {Number} connectionCount\n   */\n  getConnectionCount () {\n    return this._authenticatedSockets.length\n  }\n\n  /**\n   * Creates an HTTP or HTTPS server for ws to attach itself to,\n   * depending on the options the client configured\n   *\n   * @private\n   * @returns {http.HttpServer | http.HttpsServer}\n   */\n  _createHttpServer () {\n    if (this._isHttpsServer()) {\n      const httpsOptions = {\n        key: this._options.sslKey,\n        cert: this._options.sslCert\n      }\n\n      if (this._options.sslCa) {\n        httpsOptions.ca = this._options.sslCa\n      }\n\n      return https.createServer(httpsOptions)\n    }\n\n    return http.createServer()\n  }\n\n  /**\n   * Responds to http health checks.\n   * Responds with 200(OK) if deepstream is alive.\n   *\n   * @private\n   * @returns {void}\n   */\n  _handleHealthCheck (req, res) {\n    if (req.method === 'GET' && req.url === this._options.healthCheckPath) {\n      res.writeHead(200)\n      res.end()\n    }\n  }\n\n  /**\n   * Called whenever either the server itself or one of its sockets\n   * is closed. Once everything is closed it will emit a close event\n   *\n   * @private\n   * @returns {void}\n   */\n  _checkClosed () {\n    if (this._wsServerClosed === false) {\n      return\n    }\n\n    this.emit('close')\n  }\n\n  /**\n   * Callback for 'connection' event. Receives\n   * a connected socket, wraps it in a SocketWrapper, sends a connection ack to the user and\n  * subscribes to authentication messages.\n   * @param {Websocket} socket\n   *\n   * @private\n   * @returns {void}\n   */\n  _onConnection (socket) {\n    const socketWrapper = new SocketWrapper(socket, this._options)\n    const handshakeData = socketWrapper.getHandshakeData()\n    const logMsg = `from ${handshakeData.referer} (${handshakeData.remoteAddress})`\n    let disconnectTimer\n\n    this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.INCOMING_CONNECTION, logMsg)\n\n    if (this._options.unauthenticatedClientTimeout !== null) {\n      disconnectTimer = setTimeout(\n        this._processConnectionTimeout.bind(this, socketWrapper),\n        this._options.unauthenticatedClientTimeout\n      )\n      socketWrapper.once('close', clearTimeout.bind(null, disconnectTimer))\n    }\n\n    socketWrapper.connectionCallback = this._processConnectionMessage.bind(this, socketWrapper)\n    socketWrapper.authCallBack = this._authenticateConnection.bind(\n      this,\n      socketWrapper,\n      disconnectTimer\n    )\n    socketWrapper.sendMessage(C.TOPIC.CONNECTION, C.ACTIONS.CHALLENGE)\n    socket.on('message', socketWrapper.connectionCallback)\n  }\n\n  /**\n   * Always challenges the client that connects. This will be opened up later to allow users\n   * to put in their own challenge authentication, but requires more work on the clustering\n   * aspect first.\n   *\n   * @param  {SocketWrapper} socketWrapper Socket\n   * @param  {Message} connectionMessage Message recieved from server\n   *\n   * @private\n   * @returns {void}\n   */\n  _processConnectionMessage (socketWrapper, connectionMessage) {\n    if (typeof connectionMessage !== 'string') {\n      this._options.logger.log(\n        C.LOG_LEVEL.WARN,\n        C.EVENT.INVALID_MESSAGE,\n        connectionMessage.toString()\n      )\n      socketWrapper.sendError(\n        C.TOPIC.CONNECTION,\n        C.EVENT.INVALID_MESSAGE,\n        'invalid connection message'\n      )\n      return\n    }\n\n    const msg = messageParser.parse(connectionMessage)[0]\n\n    if (msg === null || msg === undefined) {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.MESSAGE_PARSE_ERROR, connectionMessage)\n      socketWrapper.sendError(C.TOPIC.CONNECTION, C.EVENT.MESSAGE_PARSE_ERROR, connectionMessage)\n      socketWrapper.destroy()\n    } else if (msg.topic !== C.TOPIC.CONNECTION) {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.INVALID_MESSAGE, `invalid connection message ${connectionMessage}`)\n      socketWrapper.sendError(C.TOPIC.CONNECTION, C.EVENT.INVALID_MESSAGE, 'invalid connection message')\n    } else if (msg.action === C.ACTIONS.PONG) {\n      // do nothing\n    } else if (msg.action === C.ACTIONS.CHALLENGE_RESPONSE) {\n      socketWrapper.socket.removeListener('message', socketWrapper.connectionCallback)\n      socketWrapper.socket.on('message', socketWrapper.authCallBack)\n      socketWrapper.sendMessage(C.TOPIC.CONNECTION, C.ACTIONS.ACK)\n    } else {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.UNKNOWN_ACTION, msg.action)\n      socketWrapper.sendError(C.TOPIC.CONNECTION, C.EVENT.UNKNOWN_ACTION, `unknown action ${msg.action}`)\n    }\n  }\n\n  /**\n   * Callback for the first message that's received from the socket.\n   * This is expected to be an auth-message. This method makes sure that's\n   * the case and - if so - forwards it to the permission handler for authentication\n   *\n   * @param   {SocketWrapper} socketWrapper\n   * @param   {Timeout} disconnectTimeout\n   * @param   {String} authMsg\n   *\n   * @private\n   *\n   * @returns {void}\n   */\n  _authenticateConnection (socketWrapper, disconnectTimeout, authMsg) {\n    if (typeof authMsg !== 'string') {\n      this._options.logger.log(\n        C.LOG_LEVEL.WARN,\n        C.EVENT.INVALID_AUTH_MSG,\n        authMsg.toString()\n      )\n      socketWrapper.sendError(\n        C.TOPIC.AUTH,\n        C.EVENT.INVALID_AUTH_MSG,\n        'invalid authentication message'\n      )\n      return\n    }\n\n    const msg = messageParser.parse(authMsg)[0]\n    let authData\n    let errorMsg\n\n    /**\n     * Ignore pong messages\n     */\n    if (msg && msg.topic === C.TOPIC.CONNECTION && msg.action === C.ACTIONS.PONG) {\n      return\n    }\n\n    /**\n     * Log the authentication attempt\n     */\n    const logMsg = `${socketWrapper.getHandshakeData().remoteAddress}: ${authMsg}`\n    this._options.logger.log(C.LOG_LEVEL.DEBUG, C.EVENT.AUTH_ATTEMPT, logMsg)\n\n    /**\n     * Ensure the message is a valid authentication message\n     */\n    if (!msg ||\n        msg.topic !== C.TOPIC.AUTH ||\n        msg.action !== C.ACTIONS.REQUEST ||\n        msg.data.length !== 1\n      ) {\n      errorMsg = this._options.logInvalidAuthData === true ? authMsg : ''\n      this._sendInvalidAuthMsg(socketWrapper, errorMsg)\n      return\n    }\n\n    /**\n     * Ensure the authentication data is valid JSON\n     */\n    try {\n      authData = this._getValidAuthData(msg.data[0])\n    } catch (e) {\n      errorMsg = 'Error parsing auth message'\n\n      if (this._options.logInvalidAuthData === true) {\n        errorMsg += ` \"${authMsg}\": ${e.toString()}`\n      }\n\n      this._sendInvalidAuthMsg(socketWrapper, errorMsg)\n      return\n    }\n\n    /**\n     * Forward for authentication\n     */\n    this._options.authenticationHandler.isValidUser(\n      socketWrapper.getHandshakeData(),\n      authData,\n      this._processAuthResult.bind(this, authData, socketWrapper, disconnectTimeout)\n    )\n  }\n\n  /**\n   * Will be called for syntactically incorrect auth messages. Logs\n   * the message, sends an error to the client and closes the socket\n   *\n   * @param   {SocketWrapper} socketWrapper\n   * @param   {String} msg the raw message as sent by the client\n   *\n   * @private\n   *\n   * @returns {void}\n   */\n  _sendInvalidAuthMsg (socketWrapper, msg) {\n    this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.INVALID_AUTH_MSG, this._options.logInvalidAuthData ? msg : '')\n    socketWrapper.sendError(C.TOPIC.AUTH, C.EVENT.INVALID_AUTH_MSG, 'invalid authentication message')\n    socketWrapper.destroy()\n  }\n\n  /**\n   * Callback for succesfully validated sockets. Removes\n   * all authentication specific logic and registeres the\n   * socket with the authenticated sockets\n   *\n   * @param   {SocketWrapper} socketWrapper\n   * @param   {String} username\n   *\n   * @private\n   *\n   * @returns {void}\n   */\n  _registerAuthenticatedSocket (socketWrapper, userData) {\n    socketWrapper.socket.removeListener('message', socketWrapper.authCallBack)\n    socketWrapper.once('close', this._onSocketClose.bind(this, socketWrapper))\n    socketWrapper.socket.on('message', (msg) => { this.onMessage(socketWrapper, msg) })\n    this._appendDataToSocketWrapper(socketWrapper, userData)\n    if (typeof userData.clientData === 'undefined') {\n      socketWrapper.sendMessage(C.TOPIC.AUTH, C.ACTIONS.ACK)\n    } else {\n      socketWrapper.sendMessage(\n        C.TOPIC.AUTH,\n        C.ACTIONS.ACK,\n        [messageBuilder.typed(userData.clientData)]\n      )\n    }\n\n    if (socketWrapper.user !== OPEN) {\n      this.emit('client-connected', socketWrapper)\n    }\n\n    this._authenticatedSockets.push(socketWrapper)\n    this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.AUTH_SUCCESSFUL, socketWrapper.user)\n  }\n\n  /**\n   * Append connection data to the socket wrapper\n   *\n   * @param   {SocketWrapper} socketWrapper\n   * @param   {Object} userData the data to append to the socket wrapper\n   *\n   * @private\n   *\n   * @returns {void}\n   */\n  _appendDataToSocketWrapper (socketWrapper, userData) { // eslint-disable-line\n    socketWrapper.user = userData.username || OPEN\n    socketWrapper.authData = userData.serverData || null\n  }\n\n  /**\n   * Callback for invalid credentials. Will notify the client\n   * of the invalid auth attempt. If the number of invalid attempts\n   * exceed the threshold specified in options.maxAuthAttempts\n   * the client will be notified and the socket destroyed.\n   *\n   * @param   {Object} authData the (invalid) auth data\n   * @param   {SocketWrapper} socketWrapper\n   *\n   * @private\n   *\n   * @returns {void}\n   */\n  _processInvalidAuth (clientData, authData, socketWrapper) {\n    let logMsg = 'invalid authentication data'\n\n    if (this._options.logInvalidAuthData === true) {\n      logMsg += `: ${JSON.stringify(authData)}`\n    }\n\n    this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.INVALID_AUTH_DATA, logMsg)\n    socketWrapper.sendError(\n      C.TOPIC.AUTH,\n      C.EVENT.INVALID_AUTH_DATA,\n      messageBuilder.typed(clientData)\n    )\n    socketWrapper.authAttempts++\n\n    if (socketWrapper.authAttempts >= this._options.maxAuthAttempts) {\n      this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.TOO_MANY_AUTH_ATTEMPTS, 'too many authentication attempts')\n      socketWrapper.sendError(C.TOPIC.AUTH, C.EVENT.TOO_MANY_AUTH_ATTEMPTS, messageBuilder.typed('too many authentication attempts'))\n      socketWrapper.destroy()\n    }\n  }\n\n  /**\n   * Callback for connections that have not authenticated succesfully within\n   * the expected timeframe\n   *\n   * @param   {SocketWrapper} socketWrapper\n   *\n   * @private\n   *\n   * @returns {void}\n   */\n  _processConnectionTimeout (socketWrapper) {\n    const log = 'connection has not authenticated successfully in the expected time'\n    this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.CONNECTION_AUTHENTICATION_TIMEOUT, log)\n    socketWrapper.sendError(\n      C.TOPIC.CONNECTION,\n      C.EVENT.CONNECTION_AUTHENTICATION_TIMEOUT,\n      messageBuilder.typed(log)\n    )\n    socketWrapper.destroy()\n  }\n\n  /**\n   * Callback for the results returned by the permissionHandler\n   *\n   * @param   {Object} authData\n   * @param   {SocketWrapper} socketWrapper\n   * @param   {Boolean} isAllowed\n   * @param   {Object} userData\n   *\n   * @private\n   *\n   * @returns {void}\n   */\n  _processAuthResult (authData, socketWrapper, disconnectTimeout, isAllowed, userData) {\n    userData = userData || {} // eslint-disable-line\n    clearTimeout(disconnectTimeout)\n\n    if (isAllowed === true) {\n      this._registerAuthenticatedSocket(socketWrapper, userData)\n    } else {\n      this._processInvalidAuth(userData.clientData, authData, socketWrapper)// todo\n    }\n  }\n\n  /**\n   * Called for the ready event of the ws server.\n   *\n   * @private\n   * @returns {void}\n   */\n  _checkReady () {\n    const address = this._server.address()\n    const msg = `Listening for websocket connections on ${address.address}:${address.port}${this._options.urlPath}`\n    this._wsReady = true\n\n    this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.INFO, msg)\n    this._readyCallback()\n  }\n\n  /**\n   * Generic callback for connection errors. This will most often be called\n   * if the configured port number isn't available\n   *\n   * @param   {String} error\n   *\n   * @private\n   * @returns {void}\n   */\n  _onError (error) {\n    this._options.logger.log(C.LOG_LEVEL.ERROR, C.EVENT.CONNECTION_ERROR, error.toString())\n  }\n\n  /**\n  * Notifies the (optional) onClientDisconnect method of the permissionHandler\n  * that the specified client has disconnected\n  *\n  * @param {SocketWrapper} socketWrapper\n  *\n  * @private\n  * @returns {void}\n  */\n  _onSocketClose (socketWrapper) {\n    if (this._options.authenticationHandler.onClientDisconnect) {\n      this._options.authenticationHandler.onClientDisconnect(socketWrapper.user)\n    }\n\n    if (socketWrapper.user !== OPEN) {\n      this.emit('client-disconnected', socketWrapper)\n    }\n  }\n\n  /**\n  * Returns whether or not sslKey and sslCert have been set to start a https server.\n  *\n  * @throws Will throw an error if only sslKey or sslCert have been specified\n  *\n  * @private\n  * @returns {boolean}\n  */\n  _isHttpsServer () {\n    let isHttps = false\n    if (this._options.sslKey || this._options.sslCert) {\n      if (!this._options.sslKey) {\n        throw new Error('Must also include sslKey in order to use HTTPS')\n      }\n      if (!this._options.sslCert) {\n        throw new Error('Must also include sslCert in order to use HTTPS')\n      }\n      isHttps = true\n    }\n    return isHttps\n  }\n\n  /**\n  * Checks for authentication data and throws if null or not well formed\n  *\n  * @throws Will throw an error on invalid auth data\n  *\n  * @private\n  * @returns {void}\n  */\n  _getValidAuthData (authData) { // eslint-disable-line\n    const parsedData = JSON.parse(authData)\n    if (parsedData === null || parsedData === undefined || typeof parsedData !== 'object') {\n      throw new Error(`invalid authentication data ${authData}`)\n    }\n    return parsedData\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/constants/constants.js":"'use strict'\n\nexports.MESSAGE_SEPERATOR = String.fromCharCode(30) // ASCII Record Seperator 1E\nexports.MESSAGE_PART_SEPERATOR = String.fromCharCode(31) // ASCII Unit Separator 1F\n\nexports.SOURCE_MESSAGE_CONNECTOR = 'SOURCE_MESSAGE_CONNECTOR'\nexports.ALL = 'ALL'\n\nexports.LOG_LEVEL = {}\nexports.LOG_LEVEL.DEBUG = 0\nexports.LOG_LEVEL.INFO = 1\nexports.LOG_LEVEL.WARN = 2\nexports.LOG_LEVEL.ERROR = 3\nexports.LOG_LEVEL.OFF = 100\n\nexports.STATES = {}\nexports.STATES.STARTING = 'starting'\nexports.STATES.INITIALIZED = 'initialized'\nexports.STATES.IS_RUNNING = 'is-running'\nexports.STATES.CLOSING = 'closing'\nexports.STATES.CLOSED = 'closed'\n\nexports.EVENT = {}\nexports.EVENT.DEPRECATED = 'DEPRECATED'\nexports.EVENT.TRIGGER_EVENT = 'TRIGGER_EVENT'\nexports.EVENT.INCOMING_CONNECTION = 'INCOMING_CONNECTION'\nexports.EVENT.INFO = 'INFO'\nexports.EVENT.SUBSCRIBE = 'SUBSCRIBE'\nexports.EVENT.UNSUBSCRIBE = 'UNSUBSCRIBE'\nexports.EVENT.RECORD_DELETION = 'RECORD_DELETION'\nexports.EVENT.INVALID_AUTH_MSG = 'INVALID_AUTH_MSG'\nexports.EVENT.INVALID_AUTH_DATA = 'INVALID_AUTH_DATA'\nexports.EVENT.AUTH_ATTEMPT = 'AUTH_ATTEMPT'\nexports.EVENT.AUTH_ERROR = 'AUTH_ERROR'\nexports.EVENT.TOO_MANY_AUTH_ATTEMPTS = 'TOO_MANY_AUTH_ATTEMPTS'\nexports.EVENT.AUTH_SUCCESSFUL = 'AUTH_SUCCESSFUL'\nexports.EVENT.CONNECTION_ERROR = 'CONNECTION_ERROR'\nexports.EVENT.MESSAGE_PERMISSION_ERROR = 'MESSAGE_PERMISSION_ERROR'\nexports.EVENT.MESSAGE_PARSE_ERROR = 'MESSAGE_PARSE_ERROR'\nexports.EVENT.MAXIMUM_MESSAGE_SIZE_EXCEEDED = 'MAXIMUM_MESSAGE_SIZE_EXCEEDED'\nexports.EVENT.MESSAGE_DENIED = 'MESSAGE_DENIED'\nexports.EVENT.INVALID_MESSAGE_DATA = 'INVALID_MESSAGE_DATA'\nexports.EVENT.CONNECTION_AUTHENTICATION_TIMEOUT = 'CONNECTION_AUTHENTICATION_TIMEOUT'\nexports.EVENT.UNKNOWN_TOPIC = 'UNKNOWN_TOPIC'\nexports.EVENT.UNKNOWN_ACTION = 'UNKNOWN_ACTION'\nexports.EVENT.MULTIPLE_SUBSCRIPTIONS = 'MULTIPLE_SUBSCRIPTIONS'\nexports.EVENT.NOT_SUBSCRIBED = 'NOT_SUBSCRIBED'\nexports.EVENT.ACK_TIMEOUT = 'ACK_TIMEOUT'\nexports.EVENT.RESPONSE_TIMEOUT = 'RESPONSE_TIMEOUT'\nexports.EVENT.MULTIPLE_ACK = 'MULTIPLE_ACK'\nexports.EVENT.MULTIPLE_RESPONSE = 'MULTIPLE_RESPONSE'\nexports.EVENT.NO_RPC_PROVIDER = 'NO_RPC_PROVIDER'\nexports.EVENT.RECORD_LOAD_ERROR = 'RECORD_LOAD_ERROR'\nexports.EVENT.RECORD_CREATE_ERROR = 'RECORD_CREATE_ERROR'\nexports.EVENT.RECORD_UPDATE_ERROR = 'RECORD_UPDATE_ERROR'\nexports.EVENT.RECORD_DELETE_ERROR = 'RECORD_DELETE_ERROR'\nexports.EVENT.RECORD_SNAPSHOT_ERROR = 'RECORD_SNAPSHOT_ERROR'\nexports.EVENT.RECORD_NOT_FOUND = 'RECORD_NOT_FOUND'\nexports.EVENT.CACHE_RETRIEVAL_TIMEOUT = 'CACHE_RETRIEVAL_TIMEOUT'\nexports.EVENT.STORAGE_RETRIEVAL_TIMEOUT = 'STORAGE_RETRIEVAL_TIMEOUT'\nexports.EVENT.CLOSED_SOCKET_INTERACTION = 'CLOSED_SOCKET_INTERACTION'\nexports.EVENT.CLIENT_DISCONNECTED = 'CLIENT_DISCONNECTED'\nexports.EVENT.INVALID_MESSAGE = 'INVALID_MESSAGE'\nexports.EVENT.VERSION_EXISTS = 'VERSION_EXISTS'\nexports.EVENT.INVALID_VERSION = 'INVALID_VERSION'\nexports.EVENT.PLUGIN_ERROR = 'PLUGIN_ERROR'\nexports.EVENT.PLUGIN_INITIALIZATION_ERROR = 'PLUGIN_INITIALIZATION_ERROR'\nexports.EVENT.PLUGIN_INITIALIZATION_TIMEOUT = 'PLUGIN_INITIALIZATION_TIMEOUT'\nexports.EVENT.UNKNOWN_CALLEE = 'UNKNOWN_CALLEE'\nexports.EVENT.DISTRIBUTED_STATE_ADD = 'DISTRIBUTED_STATE_ADD'\nexports.EVENT.DISTRIBUTED_STATE_REMOVE = 'DISTRIBUTED_STATE_REMOVE'\nexports.EVENT.DISTRIBUTED_STATE_REQUEST_FULL_STATE = 'DISTRIBUTED_STATE_REQUEST_FULL_STATE'\nexports.EVENT.DISTRIBUTED_STATE_FULL_STATE = 'DISTRIBUTED_STATE_FULL_STATE'\nexports.EVENT.CLUSTER_JOIN = 'CLUSTER_JOIN'\nexports.EVENT.CLUSTER_LEAVE = 'CLUSTER_LEAVE'\nexports.EVENT.INVALID_LEADER_REQUEST = 'INVALID_LEADER_REQUEST'\nexports.EVENT.TIMEOUT = 'TIMEOUT'\nexports.EVENT.LEADING_LISTEN = 'LEADING_LISTEN'\nexports.EVENT.LOCAL_LISTEN = 'LOCAL_LISTEN'\nexports.EVENT.UNSOLICITED_MSGBUS_MESSAGE = 'UNSOLICITED_MSGBUS_MESSAGE'\nexports.EVENT.INVALID_MSGBUS_MESSAGE = 'INVALID_MSGBUS_MESSAGE'\nexports.EVENT.INVALID_CONFIG_DATA = 'INVALID_CONFIG_DATA'\n\nexports.TOPIC = {}\nexports.TOPIC.CONNECTION = 'C'\nexports.TOPIC.AUTH = 'A'\nexports.TOPIC.ERROR = 'X'\nexports.TOPIC.EVENT = 'E'\nexports.TOPIC.RECORD = 'R'\nexports.TOPIC.RPC = 'P'\nexports.TOPIC.PRESENCE = 'U'\nexports.TOPIC.ONLINE_USERS = 'O'\nexports.TOPIC.CLUSTER = 'CL'\nexports.TOPIC.LEADER = 'L'\nexports.TOPIC.LEADER_PRIVATE = 'LP_'\nexports.TOPIC.PRIVATE = 'PRIVATE/'\n\nexports.TOPIC.LISTEN = 'LI'\nexports.TOPIC.PUBLISHED_SUBSCRIPTIONS = 'PS'\nexports.TOPIC.LISTEN_PATTERNS = 'LIP'\nexports.TOPIC.SUBSCRIPTIONS = 'SUB'\n\nexports.ACTIONS = {}\nexports.ACTIONS.PING = 'PI'\nexports.ACTIONS.PONG = 'PO'\nexports.ACTIONS.ACK = 'A'\nexports.ACTIONS.READ = 'R'\nexports.ACTIONS.CREATE = 'C'\nexports.ACTIONS.UPDATE = 'U'\nexports.ACTIONS.PATCH = 'P'\nexports.ACTIONS.DELETE = 'D'\nexports.ACTIONS.SUBSCRIBE = 'S'\nexports.ACTIONS.UNSUBSCRIBE = 'US'\nexports.ACTIONS.HAS = 'H'\nexports.ACTIONS.HEAD = 'HD'\nexports.ACTIONS.SNAPSHOT = 'SN'\nexports.ACTIONS.LISTEN_SNAPSHOT = 'LSN'\nexports.ACTIONS.LISTEN = 'L'\nexports.ACTIONS.UNLISTEN = 'UL'\nexports.ACTIONS.LISTEN_ACCEPT = 'LA'\nexports.ACTIONS.LISTEN_REJECT = 'LR'\nexports.ACTIONS.SUBSCRIPTION_HAS_PROVIDER = 'SH'\nexports.ACTIONS.SUBSCRIPTIONS_FOR_PATTERN_FOUND = 'SF'\nexports.ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND = 'SP'\nexports.ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED = 'SR'\nexports.ACTIONS.CREATEORREAD = 'CR'\nexports.ACTIONS.EVENT = 'EVT'\nexports.ACTIONS.ERROR = 'E'\nexports.ACTIONS.REQUEST = 'REQ'\nexports.ACTIONS.RESPONSE = 'RES'\nexports.ACTIONS.REJECTION = 'REJ'\nexports.ACTIONS.STATUS = 'ST'\nexports.ACTIONS.REMOVE = 'RM'\nexports.ACTIONS.LEADER_REQUEST = 'LR'\nexports.ACTIONS.LEADER_VOTE = 'LV'\nexports.ACTIONS.LOCK_REQUEST = 'LRQ'\nexports.ACTIONS.LOCK_RESPONSE = 'LRP'\nexports.ACTIONS.LOCK_RELEASE = 'LRL'\nexports.ACTIONS.CHALLENGE = 'CH'\nexports.ACTIONS.CHALLENGE_RESPONSE = 'CHR'\nexports.ACTIONS.WRITE_ACKNOWLEDGEMENT = 'WA'\n\nexports.ACTIONS.LEADER_REQUEST = 'LR'\nexports.ACTIONS.LEADER_VOTE = 'LV'\nexports.ACTIONS.LOCK_REQUEST = 'LRQ'\nexports.ACTIONS.LOCK_RESPONSE = 'LRP'\nexports.ACTIONS.LOCK_RELEASE = 'LRL'\n\nexports.ACTIONS.PRESENCE_JOIN = 'PNJ'\nexports.ACTIONS.PRESENCE_LEAVE = 'PNL'\nexports.ACTIONS.QUERY = 'Q'\n\nexports.TYPES = {}\nexports.TYPES.STRING = 'S'\nexports.TYPES.OBJECT = 'O'\nexports.TYPES.NUMBER = 'N'\nexports.TYPES.NULL = 'L'\nexports.TYPES.TRUE = 'T'\nexports.TYPES.FALSE = 'F'\nexports.TYPES.UNDEFINED = 'U'\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/message/message-parser.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst utils = require('../utils/utils')\n\n/**\n * Turns the ACTION:SHORTCODE constants map\n * around to facilitate shortcode lookup\n *\n * @private\n *\n * @returns {Object} actions\n*/\nconst actions = new Set(Object.keys(C.ACTIONS).map(key => C.ACTIONS[key]))\n\n/**\n * Parses ASCII control character seperated\n * message strings into digestable maps\n *\n * @constructor\n */\nmodule.exports = class MessageParser {\n  /**\n   * Main interface method. Receives a raw message\n   * string, containing one or more messages\n   * and returns an array of parsed message objects\n   * or null for invalid messages\n   *\n   * @param   {String} message raw message\n   *\n   * @public\n   *\n   * @returns {Array} array of parsed message objects\n   *                  following the format\n   *                  {\n   *                    raw: <original message string>\n   *                    topic: <string>\n   *                    action: <string - shortcode>\n   *                    data: <array of strings>\n   *                  }\n   */\n  static parse (message) {\n    const parsedMessages = []\n    const rawMessages = message.split(C.MESSAGE_SEPERATOR)\n\n    for (let i = 0; i < rawMessages.length; i++) {\n      if (rawMessages[i].length < 3) {\n        continue\n      }\n\n      const parts = rawMessages[i].split(C.MESSAGE_PART_SEPERATOR)\n      parsedMessages.push(parts.length < 2 || !actions.has(parts[1]) ? null : {\n        raw: rawMessages[i],\n        topic: parts[0],\n        action: parts[1],\n        data: parts.splice(2)\n      })\n    }\n\n    return parsedMessages\n  }\n\n  /**\n   * Deserializes values created by MessageBuilder.typed to\n   * their original format\n   *\n   * @param {String} value\n   *\n   * @public\n   * @returns {Mixed} original value\n   */\n  static convertTyped (value) {\n    const type = value.charAt(0)\n\n    if (type === C.TYPES.STRING) {\n      return value.substr(1)\n    }\n\n    if (type === C.TYPES.OBJECT) {\n      const result = utils.parseJSON(value.substr(1))\n      if (result.value) {\n        return result.value\n      }\n      return result.error\n    }\n\n    if (type === C.TYPES.NUMBER) {\n      return parseFloat(value.substr(1))\n    }\n\n    if (type === C.TYPES.NULL) {\n      return null\n    }\n\n    if (type === C.TYPES.TRUE) {\n      return true\n    }\n\n    if (type === C.TYPES.FALSE) {\n      return false\n    }\n\n    if (type === C.TYPES.UNDEFINED) {\n      return undefined\n    }\n\n    return new Error('Unknown type')\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/utils/utils.js":"'use strict'\n/* eslint-disable valid-typeof */\nconst url = require('url')\n\nconst OBJECT = 'object'\n\n/**\n * Returns a unique identifier\n *\n * @returns {String} uid\n */\nexports.getUid = function () {\n  return `${Date.now().toString(36)}-${(Math.random() * 10000000000000000000).toString(36)}`\n}\n\n/**\n * Calls <callback> once all <emitters> have emitted <event>\n *\n * @param {Array} emitters Array of objects extending events.EventEmitter\n * @param {String} event\n * @param {Function} callback Will be called once every emitter has emitted the event\n *\n * @public\n * @returns {void}\n */\nexports.combineEvents = function (emitters, event, callback) {\n  let i\n  let count = 0\n  const increment = function () {\n    count++\n\n    if (count === emitters.length) {\n      callback()\n    }\n  }\n\n  for (i = 0; i < emitters.length; i++) {\n    emitters[i].once(event, increment)\n  }\n}\n\n/**\n * Takes a key-value map and returns\n * a map with { value: key } of the old map\n *\n * @param  {Object} map\n *\n * @public\n * @return {Object} reversed map\n */\nexports.reverseMap = function (map) {\n  const reversedMap = {}\n\n  for (const key in map) {\n    reversedMap[map[key]] = key\n  }\n\n  return reversedMap\n}\n\n/**\n * Extended version of the typeof operator. Also supports 'array'\n * and 'url' to check for valid URL schemas\n *\n * @param   {Mixed}   input\n * @param   {String}  expectedType\n *\n * @public\n * @returns {Boolean}\n */\nexports.isOfType = function (input, expectedType) {\n  if (input === null) {\n    return expectedType === 'null'\n  } else if (expectedType === 'array') {\n    return Array.isArray(input)\n  } else if (expectedType === 'url') {\n    return !!url.parse(input).host\n  }\n  return typeof input === expectedType\n}\n\n/**\n * Takes a map and validates it against a basic\n * json schema in the form { key: type }\n *\n * @param   {Object}  map        the map to validate\n * @param   {Boolean} throwError if true, errors will be thrown rather than returned\n * @param   {Object}  schema     json schema in the form { key: type }\n *\n * @public\n * @returns {Boolean|Error}\n */\nexports.validateMap = function (map, throwError, schema) {\n  let error\n  let key\n\n  for (key in schema) {\n    if (typeof map[key] === 'undefined') {\n      error = new Error(`Missing key ${key}`)\n      break\n    }\n\n    if (!exports.isOfType(map[key], schema[key])) {\n      error = new Error(`Invalid type ${typeof map[key]} for ${key}`)\n      break\n    }\n  }\n\n  if (error) {\n    if (throwError) {\n      throw error\n    } else {\n      return error\n    }\n  } else {\n    return true\n  }\n}\n\n/**\n * Tests have shown that JSON stringify outperforms any attempt of\n * a code based implementation by 50% - 100% whilst also handling edge-cases and keeping\n * implementation complexity low.\n *\n * If ES6/7 ever decides to implement deep copying natively (what happened to Object.clone?\n * that was briefly a thing...), let's switch it for the native implementation. For now though,\n * even Object.assign({}, obj) only provides a shallow copy.\n *\n * Please find performance test results backing these statements here:\n *\n * http://jsperf.com/object-deep-copy-assign\n *\n * @param   {Mixed} obj the object that should be cloned\n *\n * @public\n * @returns {Mixed} clone\n */\nexports.deepCopy = function (obj) {\n  if (typeof obj === OBJECT) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n  return obj\n}\n\n/**\n * Multi Object recoursive merge\n *\n * @param {Object} multiple objects to be merged into each other recoursively\n *\n * @public\n * @returns {Object} merged result\n */\nexports.merge = function () {\n  const result = {}\n  const objs = Array.prototype.slice.apply(arguments) // eslint-disable-line\n  let i\n\n  const _merge = (objA, objB) => {\n    let key\n\n    for (key in objB) {\n      if (objB[key] && objB[key].constructor === Object) {\n        objA[key] = objA[key] || {}\n        _merge(objA[key], objB[key])\n      } else if (objB[key] !== undefined) {\n        objA[key] = objB[key]\n      }\n    }\n  }\n\n  for (i = 0; i < objs.length; i++) {\n    _merge(result, objs[i])\n  }\n\n  return result\n}\n\n/**\n * Set timeout utility that adds support for disabling a timeout\n * by passing null\n *\n * @param {Function} callback        the function that will be called after the given time\n * @param {Number}   timeoutDuration the duration of the timeout in milliseconds\n *\n * @public\n * @returns {Number} timeoutId\n */\nexports.setTimeout = function (callback, timeoutDuration) {\n  if (timeoutDuration !== null) {\n    return setTimeout(callback, timeoutDuration)\n  }\n  return -1\n}\n\n/**\n * Set Interval utility that adds support for disabling an interval\n * by passing null\n *\n * @param {Function} callback        the function that will be called after the given time\n * @param {Number}   intervalDuration the duration of the interval in milliseconds\n *\n * @public\n * @returns {Number} intervalId\n */\nexports.setInterval = function (callback, intervalDuration) {\n  if (intervalDuration !== null) {\n    return setInterval(callback, intervalDuration)\n  }\n  return -1\n}\n\nexports.getRandomIntInRange = function (min, max) {\n  return min + Math.floor(Math.random() * (max - min))\n}\n\nexports.spliceRandomElement = function (array) {\n  const randomIndex = exports.getRandomIntInRange(0, array.length)\n  return array.splice(randomIndex, 1)[0]\n}\n\n/**\n * Randomize array element order in-place.\n * Using Durstenfeld shuffle algorithm.\n *\n * @param  {Array} array The array to shuffle\n */\nexports.shuffleArray = function (array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1))\n    const temp = array[i]\n    array[i] = array[j]\n    array[j] = temp\n  }\n  return array\n}\n\n/**\n * This method tries to parse a value, and returns\n * an object containing the value or error.\n *\n * This is an optimization to avoid doing try/catch\n * inline since it incurs a massive performance hit\n * in most versions of node.\n */\nexports.parseJSON = function (text, reviver) {\n  try {\n    return {\n      value: JSON.parse(text, reviver)\n    }\n  } catch (err) {\n    return {\n      error: err\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/message/message-builder.js":"'use strict'\n\nconst C = require('../constants/constants')\n\nconst SEP = C.MESSAGE_PART_SEPERATOR\n\n/**\n * Creates a deepstream message string, based on the\n * provided parameters\n *\n * @param   {String} topic  One of CONSTANTS.TOPIC\n * @param   {String} action One of CONSTANTS.ACTIONS\n * @param   {Array} data An array of strings or JSON-serializable objects\n *\n * @returns {String} deepstream message string\n */\nexports.getMsg = function (topic, action, data) {\n  const sendData = [topic, action]\n\n  if (data) {\n    for (let i = 0; i < data.length; i++) {\n      if (typeof data[i] === 'object') {\n        sendData.push(JSON.stringify(data[i]))\n      } else {\n        sendData.push(data[i])\n      }\n    }\n  }\n\n  return sendData.join(SEP) + C.MESSAGE_SEPERATOR\n}\n\n/**\n * Creates a deepstream error message string based on the provided\n * arguments\n *\n * @param   {String} topic   One of CONSTANTS.TOPIC - error messages might either be send on\n *                           the generic ERROR topic or on the topic that caused the error\n *\n * @param   {String} type    One of CONSTANTS.EVENT\n * @param   {String | Array } message a message text or an array of data\n *\n * @returns {String } deepstream error message string\n */\nexports.getErrorMsg = function (topic, type, message) {\n  if (message instanceof Array) {\n    return `${topic + SEP}E${SEP}${type}${SEP}${message.join(SEP)}${C.MESSAGE_SEPERATOR}`\n  }\n\n  return `${topic + SEP}E${SEP}${type}${SEP}${message}${C.MESSAGE_SEPERATOR}`\n}\n\n/**\n * Converts a serializable value into its string-representation and adds\n * a flag that provides instructions on how to deserialize it.\n *\n * Please see messageParser.convertTyped for the counterpart of this method\n *\n * @param {Mixed} value\n *\n * @public\n * @returns {String} string representation of the value\n */\nexports.typed = function (value) {\n  const type = typeof value\n\n  if (type === 'string') {\n    return C.TYPES.STRING + value\n  }\n\n  if (value === null) {\n    return C.TYPES.NULL\n  }\n\n  if (type === 'object') {\n    return C.TYPES.OBJECT + JSON.stringify(value)\n  }\n\n  if (type === 'number') {\n    return C.TYPES.NUMBER + value.toString()\n  }\n\n  if (value === true) {\n    return C.TYPES.TRUE\n  }\n\n  if (value === false) {\n    return C.TYPES.FALSE\n  }\n\n  if (value === undefined) {\n    return C.TYPES.UNDEFINED\n  }\n\n  throw new Error(`Can't serialize type ${value}`)\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/message/socket-wrapper.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst messageBuilder = require('./message-builder')\nconst utils = require('util')\nconst uws = require('uws')\n\nconst EventEmitter = require('events').EventEmitter\n\n/**\n * This class wraps around a websocket\n * and provides higher level methods that are integrated\n * with deepstream's message structure\n *\n * @param {WebSocket} socket\n * @param {Object} options\n *\n * @extends EventEmitter\n *\n * @constructor\n */\nconst SocketWrapper = function (socket, options) {\n  this.socket = socket\n  this.isClosed = false\n  this.socket.once('close', this._onSocketClose.bind(this))\n  this._options = options\n  this.user = null\n  this.authCallBack = null\n  this.authAttempts = 0\n  this.setMaxListeners(0)\n  this.uuid = Math.random()\n  this._handshakeData = null\n  this._setUpHandshakeData()\n\n  this._queuedMessages = []\n  this._currentPacketMessageCount = 0\n  this._sendNextPacketTimeout = null\n  this._currentMessageResetTimeout = null\n}\n\nutils.inherits(SocketWrapper, EventEmitter)\nSocketWrapper.lastPreparedMessage = null\n\n/**\n * Updates lastPreparedMessage and returns the [uws] prepared message.\n *\n * @param {String} message the message to be prepared\n *\n * @public\n * @returns {External} prepared message\n */\nSocketWrapper.prepareMessage = function (message) {\n  SocketWrapper.lastPreparedMessage = message\n  return uws.native.server.prepareMessage(message, uws.OPCODE_TEXT)\n}\n\n/**\n * Sends the [uws] prepared message, or in case of testing sends the\n * last prepared message.\n *\n * @param {External} preparedMessage the prepared message\n *\n * @public\n * @returns {void}\n */\nSocketWrapper.prototype.sendPrepared = function (preparedMessage) {\n  if (this.socket.external) {\n    uws.native.server.sendPrepared(this.socket.external, preparedMessage)\n  } else if (this.socket.external !== null) {\n    this.socket.send(SocketWrapper.lastPreparedMessage)\n  }\n}\n\n/**\n * Variant of send with no particular checks or appends of message.\n *\n * @param {String} message the message to send\n *\n * @public\n * @returns {void}\n */\nSocketWrapper.prototype.sendNative = function (message) {\n  this.socket.send(message)\n}\n\n/**\n * Finalizes the [uws] perpared message.\n *\n * @param {External} preparedMessage the prepared message to finalize\n *\n * @public\n * @returns {void}\n */\nSocketWrapper.finalizeMessage = function (preparedMessage) {\n  uws.native.server.finalizeMessage(preparedMessage)\n}\n\n/**\n * Returns a map of parameters that were collected\n * during the initial http request that established the\n * connection\n *\n * @public\n * @returns {Object} handshakeData\n */\nSocketWrapper.prototype.getHandshakeData = function () {\n  return this._handshakeData\n}\n\n/**\n * Sends an error on the specified topic. The\n * action will automatically be set to C.ACTION.ERROR\n *\n * @param {String} topic one of C.TOPIC\n * @param {String} type one of C.EVENT\n * @param {String} msg generic error message\n *\n * @public\n * @returns {void}\n */\nSocketWrapper.prototype.sendError = function (topic, type, msg) {\n  if (this.isClosed === false) {\n    this.send(messageBuilder.getErrorMsg(topic, type, msg))\n  }\n}\n\n/**\n * Sends a message based on the provided action and topic\n *\n * @param {String} topic one of C.TOPIC\n * @param {String} action one of C.ACTIONS\n * @param {Array} data Array of strings or JSON-serializable objects\n *\n * @public\n * @returns {void}\n */\nSocketWrapper.prototype.sendMessage = function (topic, action, data) {\n  if (this.isClosed === false) {\n    this.send(messageBuilder.getMsg(topic, action, data))\n  }\n}\n\n/**\n * Checks the passed message and appends missing end separator if\n * needed, and then sends this message immediately.\n *\n * @param   {String} message deepstream message\n *\n * @public\n * @returns {void}\n */\nSocketWrapper.prototype.send = function (message) {\n  if (message.charAt(message.length - 1) !== C.MESSAGE_SEPERATOR) {\n    message += C.MESSAGE_SEPERATOR // eslint-disable-line\n  }\n\n  if (this.isClosed === true) {\n    return\n  }\n\n  this.socket.send(message)\n}\n\n/**\n * Destroyes the socket. Removes all deepstream specific\n * logic and closes the connection\n *\n * @public\n * @returns {void}\n */\nSocketWrapper.prototype.destroy = function () {\n  this.socket.close()\n  this.authCallBack = null\n}\n\n/**\n * Callback for closed sockets\n *\n * @private\n * @returns {void}\n */\nSocketWrapper.prototype._onSocketClose = function () {\n  this.isClosed = true\n  this.emit('close', this)\n  this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.CLIENT_DISCONNECTED, this.user)\n  this.socket.removeAllListeners()\n}\n\n/**\n * Initialise the handshake data from the initial connection\n *\n * @private\n * @returns void\n */\nSocketWrapper.prototype._setUpHandshakeData = function () {\n  this._handshakeData = {\n    remoteAddress: this.socket._socket.remoteAddress\n  }\n\n  if (this.socket.upgradeReq) {\n    this._handshakeData.headers = this.socket.upgradeReq.headers\n    this._handshakeData.referer = this.socket.upgradeReq.headers.referer\n  }\n  return this._handshakeData\n}\n\nmodule.exports = SocketWrapper\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/message/message-processor.js":"'use strict'\n\nconst messageParser = require('./message-parser')\nconst C = require('../constants/constants')\n\n/**\n * The MessageProcessor consumes blocks of parsed messages emitted by the\n * ConnectionEndpoint, checks if they are permissioned and - if they\n * are - forwards them.\n *\n * @constructor\n *\n * @param {Object} options deepstream options\n */\nmodule.exports = class MessageProcessor {\n  constructor (options) {\n    this._options = options\n  }\n\n  /**\n   * There will only ever be one consumer of forwarded messages. So rather than using\n   * events - and their performance overhead - the messageProcessor exposes\n   * this method that's expected to be overwritten.\n   *\n   * @param   {SocketWrapper} socketWrapper\n   * @param   {Object} message the parsed message\n   *\n   * @overwrite\n   *\n   * @returns {void}\n   */\n  onAuthenticatedMessage (socketWrapper, message) { // eslint-disable-line\n  }\n\n  /**\n   * This method is the way the message processor accepts input. It receives arrays\n   * of parsed messages, iterates through them and issues permission requests for\n   * each individual message\n   *\n   * @todo The responses from the permissionHandler might arive in any arbitrary order - order them\n   * @todo Handle permission handler timeouts\n   *\n   * @param   {SocketWrapper} socketWrapper\n   * @param   {Object} message parsed message\n   *\n   * @returns {void}\n   */\n  process (socketWrapper, message) {\n    if (typeof message !== 'string') {\n      this._options.logger.log(\n        C.LOG_LEVEL.WARN,\n        C.EVENT.INVALID_MESSAGE,\n        'non text based message recieved'\n      )\n      socketWrapper.sendError(\n        C.TOPIC.ERROR,\n        C.EVENT.MESSAGE_PARSE_ERROR,\n        'non text based message recieved'\n      )\n      return\n    }\n\n    const parsedMessages = messageParser.parse(message)\n    let parsedMessage\n\n    const length = parsedMessages.length\n    for (let i = 0; i < length; i++) {\n      parsedMessage = parsedMessages[i]\n\n      if (parsedMessage === null) {\n        this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.MESSAGE_PARSE_ERROR, message)\n        socketWrapper.sendError(C.TOPIC.ERROR, C.EVENT.MESSAGE_PARSE_ERROR, message)\n        continue\n      }\n\n      if (parsedMessage.topic === C.TOPIC.CONNECTION && parsedMessage.action === C.ACTIONS.PONG) {\n        continue\n      }\n\n      this._options.permissionHandler.canPerformAction(\n        socketWrapper.user,\n        parsedMessage,\n        this._onPermissionResponse.bind(this, socketWrapper, parsedMessage),\n        socketWrapper.authData\n      )\n    }\n  }\n\n  /**\n   * Processes the response that's returned by the permissionHandler.\n   *\n   * @param   {SocketWrapper}   socketWrapper\n   * @param   {Object} message  parsed message - might have been manipulated\n   *                              by the permissionHandler\n   * @param   {Error} error     error or null if no error. Denied permissions will be expressed\n   *                            by setting result to false\n   * @param   {Boolean} result    true if permissioned\n   *\n   * @returns {void}\n   */\n  _onPermissionResponse (socketWrapper, message, error, result) {\n    if (error !== null) {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.MESSAGE_PERMISSION_ERROR, error.toString())\n      socketWrapper.sendError(\n        message.topic,\n        C.EVENT.MESSAGE_PERMISSION_ERROR,\n        this._getPermissionErrorData(message)\n      )\n      return\n    }\n\n    if (result !== true) {\n      socketWrapper.sendError(\n        message.topic,\n        C.EVENT.MESSAGE_DENIED,\n        this._getPermissionErrorData(message)\n      )\n      return\n    }\n\n    this.onAuthenticatedMessage(socketWrapper, message)\n  }\n\n  /**\n   * Create data in the correct format expected in a MESSAGE_DENIED or MESSAGE_PERMISSION_ERROR\n   *\n   * @param   {Object} message  parsed message - might have been manipulated\n   *                              by the permissionHandler\n   * @returns {Object}\n   */\n  _getPermissionErrorData (message) { // eslint-disable-line\n    let data = [message.data[0], message.action]\n    if (message.data.length > 1) {\n      data = data.concat(message.data.slice(1))\n    }\n    return data\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/message/message-distributor.js":"'use strict'\n\nconst C = require('../constants/constants')\n\n/**\n * The MessageDistributor routes valid and permissioned messages to\n * various, previously registered handlers, e.g. event-, rpc- or recordHandler\n *\n * @param {Object} options deepstream options\n */\nmodule.exports = class MessageDistributor {\n  constructor (options) {\n    this._callbacks = {}\n    this._options = options\n  }\n\n  /**\n   * Accepts a socketWrapper and a parsed message as input and distributes\n   * it to its subscriber, based on the message's topic\n   *\n   * @param   {SocketWrapper} socketWrapper\n   * @param   {Object} message parsed and permissioned message\n   *\n   * @public\n   * @returns {void}\n   */\n  distribute (socketWrapper, message) {\n    if (this._callbacks[message.topic] === undefined) {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.UNKNOWN_TOPIC, message.topic)\n      socketWrapper.sendError(C.TOPIC.ERROR, C.EVENT.UNKNOWN_TOPIC, message.topic)\n      return\n    }\n\n    socketWrapper.emit(message.topic, message)\n\n    if (message.isCompleted !== true) {\n      this._callbacks[message.topic](socketWrapper, message)\n    }\n  }\n\n  /**\n   * Allows handlers (event, rpc, record) to register for topics. Subscribes them\n   * to both messages passed to the distribute method as well as messages received\n   * from the messageConnector\n   *\n   * @param   {String}   topic    One of C.TOPIC\n   * @param   {Function} callback The method that should be called for every message\n   *                              on the specified topic. Will be called with socketWrapper\n   *                              and message\n   *\n   * @public\n   * @returns {void}\n   */\n  registerForTopic (topic, callback) {\n    if (this._callbacks[topic] !== undefined) {\n      throw new Error(`Callback already registered for topic ${topic}`)\n    }\n\n    this._callbacks[topic] = callback\n    this._options.messageConnector.subscribe(\n      topic,\n      this._onMessageConnectorMessage.bind(this, callback)\n    )\n  }\n\n  /**\n   * Whenever a message from the messageConnector is received it is passed\n   * to the relevant handler, but with SOURCE_MESSAGE_CONNECTOR instead of\n   * a socketWrapper as sender\n   *\n   * @param   {Function} callback the handler callback\n   * @param   {Object}   message  the already parsed and validated message\n   *\n   * @private\n   * @returns {void}\n   */\n  _onMessageConnectorMessage (callback, message) { // eslint-disable-line\n    callback(C.SOURCE_MESSAGE_CONNECTOR, message)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/event/event-handler.js":"'use strict'\n/* eslint-disable valid-typeof */\nconst C = require('../constants/constants')\nconst SubscriptionRegistry = require('../utils/subscription-registry')\nconst ListenerRegistry = require('../listen/listener-registry')\nconst messageBuilder = require('../message/message-builder')\n\n/**\n * Handles incoming and outgoing messages for the EVENT topic.\n *\n * @param {Object} options deepstream options\n *\n * @constructor\n */\nconst EventHandler = function (options) {\n  this._options = options\n  this._subscriptionRegistry = new SubscriptionRegistry(options, C.TOPIC.EVENT)\n  this._listenerRegistry = new ListenerRegistry(C.TOPIC.EVENT, options, this._subscriptionRegistry)\n  this._subscriptionRegistry.setSubscriptionListener(this._listenerRegistry)\n  this._logger = options.logger\n  this._message = options.messageConnector\n}\n\n/**\n * The main distribution method. Routes messages to functions\n * based on the provided action parameter of the message\n *\n * @param {SocketWrapper} socket\n * @param {Object} message parsed and permissioned deepstream message\n *\n * @public\n * @returns {void}\n */\nEventHandler.prototype.handle = function (socket, message) {\n  if (message.action === C.ACTIONS.SUBSCRIBE) {\n    this._addSubscriber(socket, message)\n  } else if (message.action === C.ACTIONS.UNSUBSCRIBE) {\n    this._removeSubscriber(socket, message)\n  } else if (message.action === C.ACTIONS.EVENT) {\n    this._triggerEvent(socket, message)\n  } else if (message.action === C.ACTIONS.LISTEN ||\n    message.action === C.ACTIONS.UNLISTEN ||\n    message.action === C.ACTIONS.LISTEN_ACCEPT ||\n    message.action === C.ACTIONS.LISTEN_REJECT) {\n    this._listenerRegistry.handle(socket, message)\n  } else {\n    this._sendError(socket, C.EVENT.UNKNOWN_ACTION, `unknown action ${message.action}`)\n  }\n}\n\n/**\n * Handler for the SUBSCRIBE action. Adds the socket as\n * a subscriber to the specified event name\n *\n * @param {SocketWrapper} socket\n * @param {Object} message parsed and permissioned deepstream message\n *\n * @private\n * @returns {void}\n */\nEventHandler.prototype._addSubscriber = function (socket, message) {\n  if (validateSubscriptionMessage(socket, message)) {\n    this._subscriptionRegistry.subscribe(message.data[0], socket)\n  }\n}\n\n/**\n * Handler for the UNSUBSCRIBE action. Removes the socket as\n * a subscriber from the specified event name\n *\n * @param {SocketWrapper} socket\n * @param {Object} message parsed and permissioned deepstream message\n *\n * @private\n * @returns {void}\n */\nEventHandler.prototype._removeSubscriber = function (socket, message) {\n  if (validateSubscriptionMessage(socket, message)) {\n    this._subscriptionRegistry.unsubscribe(message.data[0], socket)\n  }\n}\n\n/**\n * Notifies subscribers of events. This method is invoked for the EVENT action. It can\n * be triggered by messages coming in from both clients and the message connector.\n *\n * @param {String|SocketWrapper} socket If socket is the constant SOURCE_MESSAGE_CONNECTOR\n *                        the message was received from the message connector\n *\n * @param {Object} message parsed and permissioned deepstream message\n *\n * @private\n * @returns {void}\n */\nEventHandler.prototype._triggerEvent = function (socket, message) {\n  if (typeof message.data[0] !== 'string') {\n    this._sendError(socket, C.EVENT.INVALID_MESSAGE_DATA, message.raw)\n    return\n  }\n\n  this._logger.log(C.LOG_LEVEL.DEBUG, C.EVENT.TRIGGER_EVENT, message.raw)\n\n  if (socket !== C.SOURCE_MESSAGE_CONNECTOR) {\n    this._message.publish(C.TOPIC.EVENT, message)\n  }\n\n  this._subscriptionRegistry.sendToSubscribers(\n    message.data[0],\n    messageBuilder.getMsg(C.TOPIC.EVENT, C.ACTIONS.EVENT, message.data),\n    false,\n    socket\n  )\n}\n\nEventHandler.prototype._sendError = function (socket, event, message) {\n  if (socket && socket.sendError) {\n    socket.sendError(C.TOPIC.EVENT, event, message)\n  }\n  this._logger.log(C.LOG_LEVEL.ERROR, event, message)\n}\n\n/**\n * Makes sure that subscription message contains the name of the event. Sends an error to the client\n * if not\n *\n * @param {SocketWrapper} socket\n * @param {Object} message parsed and permissioned deepstream message\n *\n * @private\n * @returns {Boolean} is valid subscription message\n */\nfunction validateSubscriptionMessage (socket, message) {\n  if (message.data && message.data.length === 1 && typeof message.data[0] === 'string') {\n    return true\n  }\n\n  socket.sendError(C.TOPIC.EVENT, C.EVENT.INVALID_MESSAGE_DATA, message.raw)\n\n  return false\n}\n\nmodule.exports = EventHandler\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/utils/subscription-registry.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst DistributedStateRegistry = require('../cluster/distributed-state-registry')\nconst SocketWrapper = require('../message/socket-wrapper')\n\nclass SubscriptionRegistry {\n  /**\n   * A generic mechanism to handle subscriptions from sockets to topics.\n   * A bit like an event-hub, only that it registers SocketWrappers rather\n   * than functions\n   *\n   * @constructor\n   *\n   * @param {Object} options deepstream options\n   * @param {String} topic one of C.TOPIC\n   * @param {[String]} clusterTopic A unique cluster topic, if not created uses format:\n   *                                topic_SUBSCRIPTIONS\n   */\n  constructor (options, topic, clusterTopic) {\n    this._delayedBroadcasts = new Map()\n    this._delay = -1\n    if (options.broadcastTimeout !== undefined) {\n      this._delay = options.broadcastTimeout\n    }\n    this._names = new Map()\n    this._subscriptions = new Map()\n    this._options = options\n    this._topic = topic\n    this._subscriptionListener = null\n    this._constants = {\n      MULTIPLE_SUBSCRIPTIONS: C.EVENT.MULTIPLE_SUBSCRIPTIONS,\n      SUBSCRIBE: C.ACTIONS.SUBSCRIBE,\n      UNSUBSCRIBE: C.ACTIONS.UNSUBSCRIBE,\n      NOT_SUBSCRIBED: C.EVENT.NOT_SUBSCRIBED\n    }\n    this._onBroadcastTimeout = this._onBroadcastTimeout.bind(this)\n    this._onSocketClose = this._onSocketClose.bind(this)\n\n    this._setupRemoteComponents(clusterTopic)\n  }\n\n  /**\n   * Setup all the remote components and actions required to deal with the subscription\n   * via the cluster.\n   */\n  _setupRemoteComponents (clusterTopic) {\n    this._clusterSubscriptions = new DistributedStateRegistry(\n      clusterTopic ||\n      `${this._topic}_${C.TOPIC.SUBSCRIPTIONS}`,\n      this._options\n    )\n    this._clusterSubscriptions.on('add', this._onClusterSubscriptionAdded.bind(this))\n    this._clusterSubscriptions.on('remove', this._onClusterSubscriptionRemoved.bind(this))\n  }\n\n  /**\n   * Return all the servers that have this subscription.\n   *\n   * @param  {String} subscriptionName the subscriptionName to look for\n   *\n   * @public\n   * @return {Array}  An array of all the servernames with this subscription\n   */\n  getAllServers (subscriptionName) {\n    return this._clusterSubscriptions.getAllServers(subscriptionName)\n  }\n\n  /**\n   * Return all the servers that have this subscription excluding the current\n   * server name\n   *\n   * @param  {String} subscriptionName the subscriptionName to look for\n   *\n   * @public\n   * @return {Array}  An array of all the servernames with this subscription\n   */\n  getAllRemoteServers (subscriptionName) {\n    const serverNames = this._clusterSubscriptions.getAllServers(subscriptionName)\n    const localServerIndex = serverNames.indexOf(this._options.serverName)\n    if (localServerIndex > -1) {\n      serverNames.splice(serverNames.indexOf(this._options.serverName), 1)\n    }\n    return serverNames\n  }\n\n  /**\n   * Returns a list of all the topic this registry\n   * currently has subscribers for\n   *\n   * @public\n   * @returns {Array} names\n   */\n  getNames () {\n    return this._clusterSubscriptions.getAll()\n  }\n\n  /**\n   * Returns true if the subscription exists somewhere\n   * in the cluster\n   *\n   * @public\n   * @returns {Array} names\n   */\n  hasName (subscriptionName) {\n    return this._clusterSubscriptions.has(subscriptionName)\n  }\n\n  /**\n  * This method allows you to customise the SubscriptionRegistry so that it can send\n  * custom events and ack messages back.\n  * For example, when using the C.ACTIONS.LISTEN, you would override SUBSCRIBE with\n  * C.ACTIONS.SUBSCRIBE and UNSUBSCRIBE with UNSUBSCRIBE\n  *\n  * @param {string} name The name of the the variable to override. This can be either\n  * MULTIPLE_SUBSCRIPTIONS, SUBSCRIBE, UNSUBSCRIBE, NOT_SUBSCRIBED\n  *\n  * @param {string} value The value to override with.\n  *\n  * @public\n  * @returns {void}\n  */\n  setAction (name, value) {\n    this._constants[name.toUpperCase()] = value\n  }\n\n  _onSocketClose (socket) {\n    const names = this._names.get(socket) || new Set()\n    for (const name of names) {\n      this.unsubscribe(name, socket, true)\n    }\n  }\n\n  /**\n   * Broadcasts the enqueued messages for the timed out subscription room.\n   *\n   * @param   {Object} delayedBroadcasts holds information of what messages to send and where\n   *\n   * @public\n   * @returns {void}\n   */\n  _onBroadcastTimeout () {\n    this._delayedBroadcastsTimer = null\n    for (const entry of this._delayedBroadcasts) {\n      const name = entry[0]\n      const delayedBroadcasts = entry[1]\n      const uniqueSenders = delayedBroadcasts.uniqueSenders\n      const sharedMessages = delayedBroadcasts.sharedMessages\n\n      if (sharedMessages.length === 0) {\n        this._delayedBroadcasts.delete(name)\n        continue\n      }\n\n      // for all unique senders and their gaps, build their special messages\n      for (const uniqueSender of uniqueSenders) {\n        const socket = uniqueSender[0]\n        const gaps = uniqueSender[1]\n        let i = 0\n        let message = sharedMessages.substring(0, gaps[i++])\n        let lastStop = gaps[i++]\n        while (i < gaps.length) {\n          message += sharedMessages.substring(lastStop, gaps[i++])\n          lastStop = gaps[i++]\n        }\n        message += sharedMessages.substring(lastStop, sharedMessages.length)\n\n        if (message) {\n          socket.sendNative(message)\n        }\n      }\n\n      // for all sockets in this subscription name, send either sharedMessage or this socket's\n      // specialized message. only sockets that sent something will have a special message, all\n      // other sockets are only listeners and receive the exact same (sharedMessage) message.\n      const sockets = this._subscriptions.get(name)\n      if (sockets) {\n        const preparedMessage = SocketWrapper.prepareMessage(sharedMessages)\n        for (const socket of sockets) {\n          if (!uniqueSenders.has(socket)) {\n            socket.sendPrepared(preparedMessage)\n          }\n        }\n        SocketWrapper.finalizeMessage(preparedMessage)\n      }\n\n      delayedBroadcasts.uniqueSenders.clear()\n      delayedBroadcasts.sharedMessages = ''\n    }\n  }\n\n  /**\n   * Enqueues a message string to be broadcast to all subscribers. Broadcasts will potentially\n   * be reordered in relation to *other* subscription names, but never in relation to the same\n   * subscription name. Each broadcast is given 'broadcastTimeout' ms to coalesce into one big\n   * broadcast.\n   *\n   * @param   {String} name      the name/topic the subscriber was previously registered for\n   * @param   {String} msgString the message as string\n   * @param   {Boolean} noDelay flay to disable broadcast delay for message\n   * @param   {[SocketWrapper]} socket an optional socket that shouldn't receive the message\n   *\n   * @public\n   * @returns {void}\n   */\n  sendToSubscribers (name, msgString, noDelay, socket) {\n    if (!this._subscriptions.has(name)) {\n      return\n    }\n\n    // not all messages are valid, this should be fixed elsewhere!\n    if (msgString.charAt(msgString.length - 1) !== C.MESSAGE_SEPERATOR) {\n      msgString += C.MESSAGE_SEPERATOR // eslint-disable-line\n    }\n\n    // if not already a delayed broadcast, create it\n    let delayedBroadcasts = this._delayedBroadcasts.get(name)\n    if (delayedBroadcasts === undefined) {\n      delayedBroadcasts = {\n        uniqueSenders: new Map(),\n        sharedMessages: ''\n      }\n      this._delayedBroadcasts.set(name, delayedBroadcasts)\n    }\n\n    // append this message to the sharedMessage, the message that\n    // is shared in the broadcast to every listener-only\n    const start = delayedBroadcasts.sharedMessages.length\n    delayedBroadcasts.sharedMessages += msgString\n    const stop = delayedBroadcasts.sharedMessages.length\n\n    // uniqueSendersMap maps from uuid to offset in uniqueSendersVector\n    // each uniqueSender has a vector of \"gaps\" in relation to sharedMessage\n    // sockets should not receive what they sent themselves, so a gap is inserted\n    // for every send from this socket\n    if (socket && socket.uuid !== undefined) {\n      const uniqueSenders = delayedBroadcasts.uniqueSenders\n      let gaps = uniqueSenders.get(socket)\n\n      if (!gaps) {\n        gaps = []\n        uniqueSenders.set(socket, gaps)\n      }\n\n      gaps.push(start, stop)\n    }\n\n    // reuse the same timer if already started\n    if (!this._delayedBroadcastsTimer) {\n      if (this._delay !== -1 && !noDelay) {\n        this._delayedBroadcastsTimer = setTimeout(this._onBroadcastTimeout, this._delay)\n      } else {\n        this._onBroadcastTimeout()\n      }\n    }\n  }\n\n  /**\n   * Adds a SocketWrapper as a subscriber to a topic\n   *\n   * @param   {String} name\n   * @param   {SocketWrapper} socket\n   *\n   * @public\n   * @returns {void}\n   */\n  subscribe (name, socket) {\n    const sockets = this._subscriptions.get(name) || new Set()\n\n    if (sockets.size === 0) {\n      this._subscriptions.set(name, sockets)\n    } else if (sockets.has(socket)) {\n      const msg = `repeat supscription to \"${name}\" by ${socket.user}`\n      this._options.logger.log(C.LOG_LEVEL.WARN, this._constants.MULTIPLE_SUBSCRIPTIONS, msg)\n      socket.sendError(this._topic, this._constants.MULTIPLE_SUBSCRIPTIONS, name)\n      return\n    }\n\n    sockets.add(socket)\n\n    if (socket.listeners('close').indexOf(this._onSocketClose) === -1) {\n      socket.once('close', this._onSocketClose)\n    }\n\n    const names = this._names.get(socket) || new Set()\n    if (names.size === 0) {\n      this._names.set(socket, names)\n    }\n    names.add(name)\n\n    if (this._subscriptionListener) {\n      this._subscriptionListener.onSubscriptionMade(\n        name,\n        socket,\n        sockets.size\n      )\n    }\n\n    this._clusterSubscriptions.add(name)\n\n    const logMsg = `for ${this._topic}:${name} by ${socket.user}`\n    this._options.logger.log(C.LOG_LEVEL.DEBUG, this._constants.SUBSCRIBE, logMsg)\n    socket.sendMessage(this._topic, C.ACTIONS.ACK, [this._constants.SUBSCRIBE, name])\n  }\n\n  /**\n   * Removes a SocketWrapper from the list of subscriptions for a topic\n   *\n   * @param   {String} name\n   * @param   {SocketWrapper} socket\n   * @param   {Boolean} silent supresses logs and unsubscribe ACK messages\n   *\n   * @public\n   * @returns {void}\n   */\n  unsubscribe (name, socket, silent) {\n    const sockets = this._subscriptions.get(name)\n\n    if (!sockets || !sockets.has(socket)) {\n      const msg = `${socket.user} is not subscribed to ${name}`\n      this._options.logger.log(C.LOG_LEVEL.WARN, this._constants.NOT_SUBSCRIBED, msg)\n      socket.sendError(this._topic, this._constants.NOT_SUBSCRIBED, name)\n      return\n    }\n\n    sockets.delete(socket)\n\n    this._clusterSubscriptions.remove(name)\n\n    if (sockets.size === 0) {\n      this._subscriptions.delete(name)\n    }\n\n    const names = this._names.get(socket)\n    names.delete(name)\n\n    if (names.size === 0) {\n      this._names.delete(socket)\n    }\n\n    if (this._subscriptionListener) {\n      this._subscriptionListener.onSubscriptionRemoved(\n        name,\n        socket,\n        sockets.size,\n        this.getAllRemoteServers(name).length\n      )\n    }\n\n    if (!silent) {\n      const logMsg = `for ${this._topic}:${name} by ${socket.user}`\n      this._options.logger.log(C.LOG_LEVEL.DEBUG, this._constants.UNSUBSCRIBE, logMsg)\n      socket.sendMessage(this._topic, C.ACTIONS.ACK, [this._constants.UNSUBSCRIBE, name])\n    }\n  }\n\n  /**\n   * Returns an array of SocketWrappers that are subscribed\n   * to <name> or null if there are no subscribers\n   *\n   * @param   {String} name\n   *\n   * @public\n   * @returns {Array} SocketWrapper[]\n   */\n  getLocalSubscribers (name) {\n    return this._subscriptions.get(name) || new Set()\n  }\n\n  /**\n   * Returns true if there are SocketWrappers that\n   * are subscribed to <name> or false if there\n   * aren't any subscribers\n   *\n   * @param   {String}  name\n   *\n   * @public\n   * @returns {Boolean} hasLocalSubscribers\n   */\n  hasLocalSubscribers (name) {\n    return this._subscriptions.has(name)\n  }\n\n  /**\n   * Allows to set a subscriptionListener after the class had been instantiated\n   *\n   * @param {SubscriptionListener} subscriptionListener a class exposing a onSubscriptionMade\n   *                                                    and onSubscriptionRemoved method\n   *\n   * @public\n   * @returns {void}\n   */\n  setSubscriptionListener (subscriptionListener) {\n    this._subscriptionListener = subscriptionListener\n  }\n\n  /**\n   * Called when a subscription has been added to the cluster\n   * This can be invoked locally or remotely, so we check if it\n   * is a local invocation and ignore it if so in favour of the\n   * call done from subscribe\n   * @param  {String} name the name that was added\n   */\n  _onClusterSubscriptionAdded (name) {\n    if (this._subscriptionListener && !this.hasLocalSubscribers(name)) {\n      this._subscriptionListener.onSubscriptionMade(name, null, 1)\n    }\n  }\n\n  /**\n   * Called when a subscription has been removed from the cluster\n   * This can be invoked locally or remotely, so we check if it\n   * is a local invocation and ignore it if so in favour of the\n   * call done from unsubscribe\n   * @param  {String} name the name that was removed\n   */\n  _onClusterSubscriptionRemoved (name) {\n    if (this._subscriptionListener && !this.hasLocalSubscribers(name)) {\n      this._subscriptionListener.onSubscriptionRemoved(name, null, 0, 0)\n    }\n  }\n}\n\nmodule.exports = SubscriptionRegistry\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/cluster/distributed-state-registry.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst EventEmitter = require('events').EventEmitter\n\nconst DATA_LENGTH = {}\nDATA_LENGTH[C.EVENT.DISTRIBUTED_STATE_REQUEST_FULL_STATE] = 1\nDATA_LENGTH[C.EVENT.DISTRIBUTED_STATE_FULL_STATE] = 2\nDATA_LENGTH[C.EVENT.DISTRIBUTED_STATE_ADD] = 3\nDATA_LENGTH[C.EVENT.DISTRIBUTED_STATE_REMOVE] = 3\n\n/**\n * This class provides a generic mechanism that allows to maintain\n * a distributed state amongst the nodes of a cluster. The state is an\n * array of unique strings in arbitrary order.\n *\n * Whenever a string is added by any node within the cluster for the first time,\n * an 'add' event is emitted. Whenever its removed by the last node within the cluster,\n * a 'remove' event is emitted.\n *\n * @extends {EventEmitter}\n *\n * @event 'add' emitted whenever an entry is added for the first time\n * @event 'remove' emitted whenever an entry is removed by the last node\n *\n * @author DeepstreamHub GmbH 2016\n */\nmodule.exports = class DistributedStateRegistry extends EventEmitter {\n\n  /**\n  * Initialises the DistributedStateRegistry and subscribes to the provided cluster topic\n  *\n  * @param   {String} topic   A TOPIC constant\n  * @param   {Object} options Global deepstream server options\n  *\n  * @constructor\n  */\n  constructor (topic, options) {\n    super()\n    this._topic = topic\n    this._options = options\n    this._options.messageConnector.subscribe(topic, this._processIncomingMessage.bind(this))\n    this._options.clusterRegistry.on('remove', this.removeAll.bind(this))\n    this._data = {}\n    this._reconciliationTimeouts = {}\n    this._fullStateSent = false\n    this._requestFullState(C.ALL)\n  }\n\n  /**\n  * Checks if a given entry exists within the registry\n  *\n  * @param   {String}  name       the name of the entry\n  *\n  * @public\n  * @returns {Boolean} exists\n  */\n  has (name) {\n    return !!this._data[name]\n  }\n\n  /**\n  * Add a name/entry to the registry. If the entry doesn't exist yet,\n  * this will notify the other nodes within the cluster\n  *\n  * @param {String} name any string key\n  *\n  * @public\n  * @returns {void}\n  */\n  add (name) {\n    if (!this._has(name, this._options.serverName)) {\n      this._add(name, this._options.serverName)\n      this._sendMessage(name, C.EVENT.DISTRIBUTED_STATE_ADD)\n    }\n  }\n\n  /**\n  * Removes a name/entry from the registry. If the entry doesn't exist,\n  * this will exit silently\n  *\n  * @param {String} name any previously added name\n  *\n  * @public\n  * @returns {void}\n  */\n  remove (name) {\n    if (this._has(name, this._options.serverName)) {\n      this._remove(name, this._options.serverName)\n      this._sendMessage(name, C.EVENT.DISTRIBUTED_STATE_REMOVE)\n    }\n  }\n\n  /**\n  * Removes all entries for a given serverName. This is intended to be called\n  * whenever a node leaves the cluster\n  *\n  * @param   {String} serverName The serverName of a node within the cluster\n  *\n  * @returns {[type]}\n  */\n  removeAll (serverName) {\n    let name\n    for (name in this._data) {\n      if (this._data[name].nodes[serverName]) {\n        this._remove(name, serverName)\n      }\n    }\n  }\n\n  /**\n  * Returns all the servers that hold a given state\n  *\n  * @public\n  * @returns {Object} entries\n  */\n  getAllServers (name) {\n    if (this._data[name]) {\n      return Object.keys(this._data[name].nodes)\n    }\n\n    return []\n  }\n\n  /**\n  * Returns all currently registered entries\n  *\n  * @public\n  * @returns {Array} entries\n  */\n  getAll () {\n    return Object.keys(this._data)\n  }\n\n  /**\n  * Removes an entry for a given serverName. If the serverName\n  * was the last node that held the entry, the entire entry will\n  * be removed and a `remove` event will be emitted\n  *\n  * @param   {String} name       the name of the entry\n  * @param   {String} serverName the name of the server that no longer holds the entry\n  *\n  * @private\n  * @returns {void}\n  */\n  _remove (name, serverName) {\n    let exists = false\n\n    if (!this._data[name]) {\n      return\n    }\n\n    delete this._data[name].nodes[serverName]\n\n    for (const nodeName in this._data[name].nodes) {\n      if (this._data[name].nodes[nodeName] === true) {\n        exists = true\n      }\n    }\n\n    if (exists === false) {\n      delete this._data[name]\n      this.emit('remove', name)\n    }\n  }\n\n  /**\n  * Adds a new entry to this registry, either as a result of a remote or\n  * a local addition. Will emit an `add` event if the entry wasn't present before\n  *\n  * @param {String} name       the name of the new entry\n  * @param {String} serverName the name of the server that added the entry\n  *\n  * @private\n  * @returns {void}\n  */\n  _add (name, serverName) {\n    if (!this._data[name]) {\n      this._data[name] = {\n        nodes: {},\n        checkSum: this._createCheckSum(name)\n      }\n      this.emit('add', name)\n    }\n\n    this._data[name].nodes[serverName] = true\n  }\n\n  /**\n  * Checks if a given entry exists for a given serverName\n  *\n  * @param   {String}  name       the name of the entry\n  * @param   {String}  serverName the name of the server that might hold the entry\n  *\n  * @private\n  * @returns {Boolean} exists\n  */\n  _has (name, serverName) {\n    return this._data[name] && this._data[name].nodes[serverName]\n  }\n\n  /**\n  * Generic messaging function for add and remove messages\n  *\n  * @param   {String} name   the name of the entry that's added or removed\n  * @param   {String} action action-constant, one of C.EVENT.<>\n  *\n  * @private\n  * @returns {void}\n  */\n  _sendMessage (name, action) {\n    const message = {\n      topic: this._topic,\n      action,\n      data: [name, this._options.serverName, this._getCheckSumTotal(this._options.serverName)]\n    }\n\n    this._options.messageConnector.publish(this._topic, message)\n  }\n\n  /**\n  * This method calculates the total checkSum for all local entries of\n  * a given serverName\n  *\n  * @param {String} serverName the name of the server for which the checkSum should be calculated\n  *\n  * @private\n  * @returns {Number} totalCheckSum\n  */\n  _getCheckSumTotal (serverName) {\n    let totalCheckSum = 0\n    let name\n\n    for (name in this._data) {\n      if (this._data[name].nodes[serverName]) {\n        totalCheckSum += this._data[name].checkSum\n      }\n    }\n\n    return totalCheckSum\n  }\n\n  /**\n  * Calculates a simple checkSum for a given name. This is done up-front and cached\n  * to increase performance for local add and remove operations. Arguably this is a generic\n  * method and might be moved to the utils class if we find another usecase for it.\n  *\n  * @param   {String} name the name of the entry\n  *\n  * @private\n  * @returns {Number} checkSum\n  */\n  _createCheckSum (name) { // eslint-disable-line\n    let checkSum = 0\n    let i\n\n    for (i = 0; i < name.length; i++) {\n      checkSum = ((checkSum << 5) - checkSum) + name.charCodeAt(i) // eslint-disable-line\n    }\n\n    return checkSum\n  }\n\n  /**\n  * Checks a remote checkSum for a given serverName against the\n  * actual checksum for all local entries for the given name.\n  *\n  * - If the checksums match, it removes all possibly pending\n  *   reconciliationTimeouts\n  *\n  * - If the checksums don't match, it schedules a reconciliation request. If\n  *   another message from the remote server arrives before the reconciliation request\n  *   is send, it will be cancelled.\n  *\n  * @param   {String} serverName     the name of the remote server for which the checkSum\n  *                                  should be calculated\n  * @param   {Number} remoteCheckSum The checksum the remote server has calculated for all\n  *                                  its local entries\n  *\n  * @private\n  * @returns {void}\n  */\n  _verifyCheckSum (serverName, remoteCheckSum) {\n    if (this._getCheckSumTotal(serverName) !== remoteCheckSum) {\n      this._reconciliationTimeouts[serverName] = setTimeout(\n                this._requestFullState.bind(this, serverName),\n                this._options.stateReconciliationTimeout\n            )\n    } else if (this._reconciliationTimeouts[serverName]) {\n      clearTimeout(this._reconciliationTimeouts[serverName])\n      delete this._reconciliationTimeouts[serverName]\n    }\n  }\n\n  /**\n  * Sends a reconciliation request for a server with a given name (technically, its send to\n  * every node within the cluster, but will be ignored by all but the one with a matching name)\n  *\n  * The matching node will respond with a DISTRIBUTED_STATE_FULL_STATE message\n  *\n  * @param   {String} serverName The name of the node with the compromised state\n  *\n  * @private\n  * @returns {void}\n  */\n  _requestFullState (serverName) {\n    this._options.messageConnector.publish(this._topic, {\n      topic: this._topic,\n      action: C.EVENT.DISTRIBUTED_STATE_REQUEST_FULL_STATE,\n      data: [serverName]\n    })\n  }\n\n  /**\n  * Creates a full state message containing an array of all local entries that\n  * will be used to reconcile compromised states as well as provide the full state\n  * for new nodes that joined the cluster\n  *\n  * When a state gets compromised, more than one remote registry might request a full state update.\n  * This method will  schedule a timeout in which no additional full state messages are sent to\n  * make sure only a single full state message is sent in reply.\n  *\n  * @private\n  * @returns {void}\n  */\n  _sendFullState () {\n    const localState = []\n    let name\n\n    for (name in this._data) {\n      if (this._data[name].nodes[this._options.serverName]) {\n        localState.push(name)\n      }\n    }\n\n    this._options.messageConnector.publish(this._topic, {\n      topic: this._topic,\n      action: C.EVENT.DISTRIBUTED_STATE_FULL_STATE,\n      data: [this._options.serverName, localState]\n    })\n\n    this._fullStateSent = true\n    setTimeout(this._resetFullStateSent.bind(this), this._options.stateReconciliationTimeout)\n  }\n\n  /**\n  * This will apply the data from an incoming full state message. Entries that are not within\n  * the incoming array will be removed for that node from the local registry and new entries will\n  * be added.\n  *\n  * @param   {String} serverName the name of the server that send the full state message\n  * @param   {Array}  names      a full list of all local entries of that server in arbitrary order\n  *\n  * @private\n  * @returns {void}\n  */\n  _applyFullState (serverName, names) {\n    let name\n    let i\n\n    for (name in this._data) {\n            // please note: only checking if the name exists is sufficient as the registry will just\n            // set node[serverName] to false if the entry exists, but not for the remote server.\n      if (names.indexOf(name) === -1) {\n        this._remove(name, serverName)\n      }\n    }\n\n    for (i = 0; i < names.length; i++) {\n      this._add(names[i], serverName)\n    }\n  }\n\n  /**\n  * Will be called after a full state message has been sent and\n  * stateReconciliationTimeout has passed. This will allow further reconciliation\n  * messages to be sent again.\n  *\n  * @private\n  * @returns {void}\n  */\n  _resetFullStateSent () {\n    this._fullStateSent = false\n  }\n\n  /**\n  * This is the main routing point for messages coming in from\n  * the message connector.\n  *\n  * @param   {Object} message a message connector message with topic, action and data fields\n  *\n  * @private\n  * @returns {void}\n  */\n  _processIncomingMessage (message) {\n    if (!this._isValidMessage(message)) {\n      return\n    }\n\n    if (message.action === C.EVENT.DISTRIBUTED_STATE_ADD) {\n      this._add(message.data[0], message.data[1])\n      this._verifyCheckSum(message.data[1], message.data[2])\n    } else if (message.action === C.EVENT.DISTRIBUTED_STATE_REMOVE) {\n      this._remove(message.data[0], message.data[1])\n      this._verifyCheckSum(message.data[1], message.data[2])\n    } else if (message.action === C.EVENT.DISTRIBUTED_STATE_REQUEST_FULL_STATE) {\n      if (\n        message.data[0] === C.ALL ||\n        (message.data[0] === this._options.serverName && this._fullStateSent === false)\n      ) {\n        this._sendFullState()\n      }\n    } else if (message.action === C.EVENT.DISTRIBUTED_STATE_FULL_STATE) {\n      this._applyFullState(message.data[0], message.data[1])\n    }\n  }\n\n  /**\n  * Performs basic validations for incoming messages, based on action and data-length\n  *\n  * @param   {Object} message a message connector message with topic, action and data fields\n  *\n  * @private\n  * @returns {Boolean} isValid\n  */\n  _isValidMessage (message) {\n    if (DATA_LENGTH[message.action] === undefined) {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.UNKNOWN_ACTION, message.action)\n      return false\n    }\n\n    if (message.data.length !== DATA_LENGTH[message.action]) {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.INVALID_MESSAGE_DATA, message.data)\n      return false\n    }\n\n    return true\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/listen/listener-registry.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst SubscriptionRegistry = require('../utils/subscription-registry')\nconst DistributedStateRegistry = require('../cluster/distributed-state-registry')\nconst TimeoutRegistry = require('./listener-timeout-registry')\nconst messageBuilder = require('../message/message-builder')\nconst utils = require('../utils/utils')\n\nmodule.exports = class ListenerRegistry {\n  /**\n  * Deepstream.io allows clients to register as listeners for subscriptions.\n  * This allows for the creation of 'active' data-providers,\n  * e.g. data providers that provide data on the fly, based on what clients\n  * are actually interested in.\n  *\n  * When a client registers as a listener, it provides a regular expression.\n  * It will then immediatly get a number of callbacks for existing record subscriptions\n  * whose names match that regular expression.\n  *\n  * After that, whenever a record with a name matching that regular expression is subscribed\n  * to for the first time, the listener is notified.\n  *\n  * Whenever the last subscription for a matching record is removed, the listener is also\n  * notified with a SUBSCRIPTION_FOR_PATTERN_REMOVED action\n  *\n  * This class manages the matching of patterns and record names. The subscription /\n  * notification logic is handled by this._providerRegistry\n  *\n  * @constructor\n  *\n  * @param {Object} options       DeepStream options\n  * @param {SubscriptionRegistry} clientRegistry The SubscriptionRegistry containing the record\n  *                                              subscriptions to allow new listeners to be\n  *                                              notified of existing subscriptions\n  */\n  constructor (topic, options, clientRegistry) {\n    this._topic = topic\n    this._options = options\n    this._clientRegistry = clientRegistry\n    this._uniqueLockName = `${topic}_LISTEN_LOCK`\n\n    this._uniqueStateProvider = this._options.uniqueRegistry\n    this._messageConnector = this._options.messageConnector\n\n    this._patterns = {}\n    this._localListenInProgress = {}\n    this._listenerTimeoutRegistry = new TimeoutRegistry(topic, options)\n\n    this._locallyProvidedRecords = {}\n\n    this._leadListen = {}\n    this._leadingListen = {}\n\n    this._setupProviderRegistry()\n    this._setupRemoteComponents()\n  }\n\n  /**\n   * Setup all the remote components and actions required to deal with the subscription\n   * via the cluster.\n   */\n  _setupProviderRegistry () {\n    this._providerRegistry = new SubscriptionRegistry(\n      this._options,\n      this._topic,\n      `${this._topic}_${C.TOPIC.LISTEN_PATTERNS}`\n    )\n    this._providerRegistry.setAction('subscribe', C.ACTIONS.LISTEN)\n    this._providerRegistry.setAction('unsubscribe', C.ACTIONS.UNLISTEN)\n    this._providerRegistry.setSubscriptionListener({\n      onSubscriptionRemoved: this._removePattern.bind(this),\n      onSubscriptionMade: this._addPattern.bind(this)\n    })\n  }\n\n  /**\n   * Setup all the remote components and actions required to deal with the subscription\n   * via the cluster.\n   */\n  _setupRemoteComponents () {\n    this._clusterProvidedRecords = new DistributedStateRegistry(\n      `${this._topic}_${C.TOPIC.PUBLISHED_SUBSCRIPTIONS}`,\n      this._options\n    )\n    this._clusterProvidedRecords.on('add', this._onRecordStartProvided.bind(this))\n    this._clusterProvidedRecords.on('remove', this._onRecordStopProvided.bind(this))\n\n    this._messageConnector.subscribe(\n      this._getMessageBusTopic(this._options.serverName, this._topic),\n      this._onIncomingMessage.bind(this)\n    )\n  }\n\n  /**\n  * Used primarily for tests. Returns whether or not a provider exists for\n  * the specific subscriptionName\n  * @public\n  * @returns {boolean}\n  */\n  hasActiveProvider (susbcriptionName) {\n    return this._clusterProvidedRecords.has(susbcriptionName)\n  }\n\n  /**\n  * The main entry point to the handle class.\n  * Called on any of the following actions:\n  *\n  * 1) C.ACTIONS.LISTEN\n  * 2) C.ACTIONS.UNLISTEN\n  * 3) C.ACTIONS.LISTEN_ACCEPT\n  * 4) C.ACTIONS.LISTEN_REJECT\n  * 5) C.ACTIONS.LISTEN_SNAPSHOT\n  *\n  * @param   {SocketWrapper} socketWrapper the socket that send the request\n  * @param   {Object} message parsed and validated message\n  *\n  * @public\n  * @returns {void}\n  */\n  handle (socketWrapper, message) {\n    const pattern = message.data[0]\n    const subscriptionName = message.data[1]\n    if (message.action === C.ACTIONS.LISTEN) {\n      this._addListener(socketWrapper, message)\n    } else if (message.action === C.ACTIONS.UNLISTEN) {\n      this._providerRegistry.unsubscribe(pattern, socketWrapper)\n      this._removeListener(socketWrapper, message)\n    } else if (this._listenerTimeoutRegistry.isALateResponder(socketWrapper, message)) {\n      this._listenerTimeoutRegistry.handle(socketWrapper, message)\n    } else if (this._localListenInProgress[subscriptionName]) {\n      this._processResponseForListenInProgress(socketWrapper, subscriptionName, message)\n    } else {\n      this._onMsgDataError(socketWrapper, message.raw, C.EVENT.INVALID_MESSAGE)\n    }\n  }\n\n  /**\n  * Handle messages that arrive via the message bus\n  *\n  * This can either be messages by the leader indicating that this\n  * node is responsible for starting a local discovery phase\n  * or from a resulting node with an ACK to allow the leader\n  * to move on and release its lock\n  *\n  * @param  {Object} message The received message\n  *\n  * @private\n  * @returns {void}\n  */\n  _onIncomingMessage (message) {\n    if (this._options.serverName !== message.data[0]) {\n      return\n    }\n    if (message.action === C.ACTIONS.LISTEN) {\n      this._leadListen[message.data[1]] = message.data[2]\n      this._startLocalDiscoveryStage(message.data[1])\n    } else if (message.action === C.ACTIONS.ACK) {\n      this._nextDiscoveryStage(message.data[1])\n    } else if (message.action === C.ACTIONS.UNSUBSCRIBE) {\n      this.onSubscriptionRemoved(\n        message.data[1],\n        null,\n        this._clientRegistry.getLocalSubscribers(message.data[1]).size,\n        this._clientRegistry.getAllServers(message.data[1]).length - 1\n      )\n    }\n  }\n\n  /**\n  * Process an accept or reject for a listen that is currently in progress\n  * and hasn't timed out yet.\n  *\n  * @param   {SocketWrapper} socketWrapper   The socket endpoint of the listener\n  * @param   {String} subscriptionName       The name of the subscription that a listen\n  *                                          is in process for\n  * @param   {Object} message                Deepstream message object\n  *\n  * @private\n  * @returns {void}\n  */\n  _processResponseForListenInProgress (socketWrapper, subscriptionName, message) {\n    if (message.action === C.ACTIONS.LISTEN_ACCEPT) {\n      this._accept(socketWrapper, message)\n      this._listenerTimeoutRegistry.rejectLateResponderThatAccepted(subscriptionName)\n      this._listenerTimeoutRegistry.clear(subscriptionName)\n    } else if (message.action === C.ACTIONS.LISTEN_REJECT) {\n      const provider = this._listenerTimeoutRegistry.getLateResponderThatAccepted(subscriptionName)\n      if (provider) {\n        this._accept(provider.socketWrapper, message)\n        this._listenerTimeoutRegistry.clear(subscriptionName)\n      } else {\n        this._triggerNextProvider(subscriptionName)\n      }\n    }\n  }\n\n  /**\n  * Called by the record subscription registry whenever the subscription count decrements.\n  * Part of the subscriptionListener interface.\n  *\n  * @param   {String} name\n  *\n  * @public\n  * @returns {void}\n  */\n  onSubscriptionMade (subscriptionName, socketWrapper, localCount) {\n    if (this.hasActiveProvider(subscriptionName)) {\n      this._sendHasProviderUpdateToSingleSubscriber(true, socketWrapper, subscriptionName)\n      return\n    }\n\n    if (localCount > 1) {\n      return\n    }\n\n    this._startDiscoveryStage(subscriptionName)\n  }\n\n  /**\n  * Called by the record subscription registry whenever the subscription count increments.\n  * Part of the subscriptionListener interface.\n  *\n  * @param   {String} subscriptionName\n  *\n  * @public\n  * @returns {void}\n  */\n  onSubscriptionRemoved (subscriptionName, socketWrapper, localCount, remoteCount) {\n    const provider = this._locallyProvidedRecords[subscriptionName]\n\n    if (this.hasActiveProvider(subscriptionName) && !provider) {\n      const serverName = this._clusterProvidedRecords.getAllServers(subscriptionName)[0]\n      this._sendLastSubscriberRemoved(serverName, subscriptionName)\n      return\n    }\n\n    if (!provider) {\n      return\n    }\n\n    if (localCount > 1 || remoteCount > 0) {\n      return\n    }\n\n    // provider discarded, but there is still another active subscriber\n    if (localCount === 1 && provider.socketWrapper === socketWrapper) {\n      return\n    }\n\n    // provider isn't a subscriber, meaning we should wait for 0\n    const subscribers = this._clientRegistry.getLocalSubscribers(subscriptionName)\n    if (localCount === 1 && !subscribers.has(provider.socketWrapper)) {\n      return\n    }\n\n    this._sendSubscriptionForPatternRemoved(provider, subscriptionName)\n    this._removeActiveListener(subscriptionName)\n  }\n\n  /**\n  * Register callback for when the server recieves an accept message from the client\n  *\n  * @private\n  * @returns {void}\n  */\n  _accept (socketWrapper, message) {\n    const subscriptionName = message.data[1]\n\n    this._listenerTimeoutRegistry.clearTimeout(subscriptionName)\n\n    this._locallyProvidedRecords[subscriptionName] = {\n      socketWrapper,\n      pattern: message.data[0],\n      closeListener: this._removeListener.bind(this, socketWrapper, message)\n    }\n    socketWrapper.once('close', this._locallyProvidedRecords[subscriptionName].closeListener)\n    this._clusterProvidedRecords.add(subscriptionName)\n\n    this._stopLocalDiscoveryStage(subscriptionName)\n  }\n\n  /**\n  * Register a client as a listener for record subscriptions\n  *\n  * @param   {SocketWrapper} socketWrapper the socket that send the request\n  * @param   {Object} message parsed and validated message\n  *\n  * @private\n  * @returns {void}\n  */\n  _addListener (socketWrapper, message) {\n    const pattern = this._getPattern(socketWrapper, message)\n    const regExp = this._validatePattern(socketWrapper, pattern)\n\n    if (!regExp) {\n      return\n    }\n\n    if (!this._providerRegistry.getLocalSubscribers(pattern).has(socketWrapper)) {\n      this._providerRegistry.subscribe(pattern, socketWrapper)\n    }\n\n    this._reconcileSubscriptionsToPatterns(regExp, pattern, socketWrapper)\n  }\n\n  /**\n  * Find subscriptions that match pattern, and notify them that\n  * they can be provided.\n  *\n  * We will attempt to notify all possible providers rather than\n  * just the single provider for load balancing purposes and\n  * so that the one listener doesnt potentially get overwhelmed.\n  *\n  * @private\n  * @returns {Message}\n  */\n  _reconcileSubscriptionsToPatterns (regExp, pattern, socketWrapper) {\n    for (const subscriptionName of this._clientRegistry.getNames()) {\n      if (!subscriptionName.match(regExp)) {\n        continue\n      }\n\n      if (this._locallyProvidedRecords[subscriptionName]) {\n        continue\n      }\n\n      const listenInProgress = this._localListenInProgress[subscriptionName]\n\n      if (listenInProgress) {\n        listenInProgress.push({ socketWrapper, pattern })\n      } else {\n        this._startDiscoveryStage(subscriptionName)\n      }\n    }\n  }\n\n  /**\n  * De-register a client as a listener for record subscriptions\n  *\n  * @param   {SocketWrapper} socketWrapper the socket that send the request\n  * @param   {Object} message parsed and validated message\n  *\n  * @private\n  * @returns {void}\n  */\n  _removeListener (socketWrapper, message) {\n    const pattern = message.data[0]\n\n    this._removeListenerFromInProgress(this._localListenInProgress, pattern, socketWrapper)\n    this._removeListenerIfActive(pattern, socketWrapper)\n  }\n\n  /**\n  * Removes the listener if it is the currently active publisher, and retriggers\n  * another listener discovery phase\n  *\n  * @private\n  * @returns {Message}\n  */\n  _removeListenerIfActive (pattern, socketWrapper) {\n    for (const subscriptionName in this._locallyProvidedRecords) {\n      const provider = this._locallyProvidedRecords[subscriptionName]\n      if (\n        provider.socketWrapper === socketWrapper &&\n        provider.pattern === pattern\n      ) {\n        provider.socketWrapper.removeListener('close', provider.closeListener)\n        this._removeActiveListener(subscriptionName)\n        if (this._clientRegistry.hasLocalSubscribers(subscriptionName)) {\n          this._startDiscoveryStage(subscriptionName)\n        }\n      }\n    }\n  }\n\n  /**\n  * @private\n  * @returns {Void}\n    */\n  _removeActiveListener (subscriptionName) {\n    delete this._locallyProvidedRecords[subscriptionName]\n    this._clusterProvidedRecords.remove(subscriptionName)\n  }\n\n  /**\n  * Start discovery phase once a lock is obtained from the leader within\n  * the cluster\n  *\n  * @param   {String} subscriptionName the subscription name\n  *\n  * @private\n  * @returns {void}\n  */\n  _startDiscoveryStage (subscriptionName) {\n    const localListenArray = this._createLocalListenArray(\n      this._patterns,\n      this._providerRegistry,\n      subscriptionName\n    )\n\n    if (localListenArray.length === 0) {\n      return\n    }\n\n    this._uniqueStateProvider.get(this._getUniqueLockName(subscriptionName), (success) => {\n      if (!success) {\n        return\n      }\n\n      if (this.hasActiveProvider(subscriptionName)) {\n        this._uniqueStateProvider.release(this._getUniqueLockName(subscriptionName))\n        return\n      }\n\n      this._options.logger.log(\n        C.LOG_LEVEL.DEBUG,\n        C.EVENT.LEADING_LISTEN,\n        `started for ${this._topic}:${subscriptionName}`\n      )\n\n      const remoteListenArray = this._createRemoteListenArray(\n        this._patterns,\n        this._providerRegistry,\n        subscriptionName\n      )\n      this._leadingListen[subscriptionName] = remoteListenArray\n\n      this._startLocalDiscoveryStage(subscriptionName, localListenArray)\n    })\n  }\n\n  /**\n  * called when a subscription has been provided to clear down the discovery stage,\n  * or when an ack has been recieved via the message bus\n  *\n  * @param  {String} subscriptionName check if the subscription has a provider yet,\n  *                                   if not trigger the next request via the message\n  *                                   bus\n  *\n  * @private\n  * @returns {void}\n  */\n  _nextDiscoveryStage (subscriptionName) {\n    if (\n      this.hasActiveProvider(subscriptionName) ||\n      this._leadingListen[subscriptionName].length === 0\n    ) {\n      this._options.logger.log(\n        C.LOG_LEVEL.DEBUG,\n        C.EVENT.LEADING_LISTEN,\n        `finished for ${this._topic}:${subscriptionName}`\n      )\n      delete this._leadingListen[subscriptionName]\n      this._uniqueStateProvider.release(this._getUniqueLockName(subscriptionName))\n    } else {\n      const nextServerName = this._leadingListen[subscriptionName].shift()\n      this._options.logger.log(\n        C.LOG_LEVEL.DEBUG,\n        C.EVENT.LEADING_LISTEN,\n        `started for ${this._topic}:${subscriptionName}`\n      )\n      this._sendRemoteDiscoveryStart(nextServerName, subscriptionName)\n    }\n  }\n\n  /**\n  * Start discovery phase once a lock is obtained from the leader within\n  * the cluster\n  *\n  * @param   {String} subscriptionName the subscription name\n  * @param   {Object} [localListenMap] map of all listeners\n  *\n  * @private\n  * @returns {void}\n  */\n  _startLocalDiscoveryStage (subscriptionName, localListenArray) {\n    if (!localListenArray) {\n      // eslint-disable-next-line\n      localListenArray = this._createLocalListenArray(\n        this._patterns,\n        this._providerRegistry,\n        subscriptionName\n      )\n    }\n\n    if (localListenArray.length > 0) {\n      this._options.logger.log(\n        C.LOG_LEVEL.DEBUG,\n        C.EVENT.LOCAL_LISTEN,\n        `started for ${this._topic}:${subscriptionName}`\n      )\n      this._localListenInProgress[subscriptionName] = localListenArray\n      this._triggerNextProvider(subscriptionName)\n    }\n  }\n\n  /**\n  * Finalises a local listener discovery stage\n  *\n  * @param   {String} subscriptionName the subscription a listener is searched for\n  *\n  * @private\n  * @returns {void}\n  */\n  _stopLocalDiscoveryStage (subscriptionName) {\n    delete this._localListenInProgress[subscriptionName]\n\n    this._options.logger.log(\n      C.LOG_LEVEL.DEBUG,\n      C.EVENT.LOCAL_LISTEN,\n      `stopped for ${this._topic}:${subscriptionName}`\n    )\n\n    if (this._leadingListen[subscriptionName]) {\n      this._nextDiscoveryStage(subscriptionName)\n    } else {\n      this._sendRemoteDiscoveryStop(this._leadListen[subscriptionName], subscriptionName)\n      delete this._leadListen[subscriptionName]\n    }\n  }\n\n  /**\n  * Trigger the next provider in the map of providers capable of publishing\n  * data to the specific subscriptionName\n  *\n  * @param   {String} subscriptionName the subscription a listener is searched for\n  *\n  * @private\n  * @returns {void}\n  */\n  _triggerNextProvider (subscriptionName) {\n    const listenInProgress = this._localListenInProgress[subscriptionName]\n\n    if (typeof listenInProgress === 'undefined') {\n      return\n    }\n\n    if (listenInProgress.length === 0) {\n      this._stopLocalDiscoveryStage(subscriptionName)\n      return\n    }\n\n    const provider = listenInProgress.shift()\n    const subscribers = this._clientRegistry.getLocalSubscribers(subscriptionName)\n\n    if (subscribers && subscribers.has(provider.socketWrapper)) {\n      this._stopLocalDiscoveryStage(subscriptionName)\n      return\n    }\n\n    this._listenerTimeoutRegistry.addTimeout(\n      subscriptionName,\n      provider,\n      this._triggerNextProvider.bind(this)\n    )\n\n    this._sendSubscriptionForPatternFound(provider, subscriptionName)\n  }\n\n  /**\n  * Triggered when a subscription is being provided by a node in the cluster\n  *\n  * @param   {String} subscriptionName the subscription a listener is searched for\n  *\n  * @private\n  * @returns {void}\n  */\n  _onRecordStartProvided (subscriptionName) {\n    this._sendHasProviderUpdate(true, subscriptionName)\n    if (this._leadingListen[subscriptionName]) {\n      this._nextDiscoveryStage(subscriptionName)\n    }\n  }\n\n  /**\n  * Triggered when a subscription is stopped being provided by a node in the cluster\n  *\n  * @param   {String} subscriptionName the subscription a listener is searched for\n  *\n  * @private\n  * @returns {void}\n  */\n  _onRecordStopProvided (subscriptionName) {\n    this._sendHasProviderUpdate(false, subscriptionName)\n    if (\n      !this.hasActiveProvider(subscriptionName) &&\n      this._clientRegistry.hasName(subscriptionName)\n    ) {\n      this._startDiscoveryStage(subscriptionName)\n    }\n  }\n\n  /**\n  * Compiles a regular expression from an incoming pattern\n  *\n  * @param {String} pattern       the raw pattern\n  * @param {SocketWrapper} socketWrapper connection to the client that provided the pattern\n  * @param {Number} count         the amount of times this pattern is present\n  *\n  * @private\n  * @returns {void}\n  */\n  _addPattern (pattern /* , socketWrapper, count */) {\n    if (!this._patterns[pattern]) {\n      this._patterns[pattern] = new RegExp(pattern)\n    }\n  }\n\n  /**\n  * Deletes the pattern regex when removed\n  *\n  * @param {String} pattern       the raw pattern\n  * @param {SocketWrapper} socketWrapper connection to the client that provided the pattern\n  * @param {Number} count         the amount of times this pattern is present\n  *\n  * @private\n  * @returns {void}\n  */\n  _removePattern (pattern, socketWrapper, count) {\n    if (socketWrapper) {\n      this._listenerTimeoutRegistry.removeProvider(socketWrapper)\n      this._removeListenerFromInProgress(this._localListenInProgress, pattern, socketWrapper)\n      this._removeListenerIfActive(pattern, socketWrapper)\n    }\n\n    if (count === 0) {\n      delete this._patterns[pattern]\n    }\n  }\n\n  /**\n  * Remove provider from listen in progress map if it unlistens during\n  * discovery stage\n  *\n  * @param  {Object} listensCurrentlyInProgress the listeners currently in progress\n  * @param  {String} pattern the pattern that has been unlistened to\n  * @param  {SocketWrapper} socketWrapper the socket wrapper of the provider that unlistened\n  */\n  _removeListenerFromInProgress (listensCurrentlyInProgress, pattern, socketWrapper) { // eslint-disable-line\n    for (const subscriptionName in listensCurrentlyInProgress) {\n      const listenInProgress = listensCurrentlyInProgress[subscriptionName]\n      for (let i = 0; i < listenInProgress.length; i++) {\n        if (\n          listenInProgress[i].socketWrapper === socketWrapper &&\n          listenInProgress[i].pattern === pattern\n        ) {\n          listenInProgress.splice(i, 1)\n        }\n      }\n    }\n  }\n\n  /**\n  * Sends a has provider update to a single subcriber\n  * @param  {Boolean} hasProvider      send T or F so provided status\n  * @param  {SocketWrapper}  socketWrapper    the socket wrapper to send to,\n  *                                           if it doesn't exist then don't do anything\n  * @param  {String}  subscriptionName The subscription name which provided status changed\n  */\n  _sendHasProviderUpdateToSingleSubscriber (hasProvider, socketWrapper, subscriptionName) {\n    if (socketWrapper && this._topic === C.TOPIC.RECORD) {\n      socketWrapper.send(this._createHasProviderMessage(hasProvider, this._topic, subscriptionName))\n    }\n  }\n\n  /**\n  * Sends a has provider update to all subcribers\n  * @param  {Boolean} hasProvider      send T or F so provided status\n  * @param  {String}  subscriptionName The subscription name which provided status changed\n  */\n  _sendHasProviderUpdate (hasProvider, subscriptionName) {\n    if (this._topic !== C.TOPIC.RECORD) {\n      return\n    }\n    this._clientRegistry.sendToSubscribers(\n      subscriptionName,\n      this._createHasProviderMessage(hasProvider, this._topic, subscriptionName)\n    )\n  }\n\n  /**\n  * Sent by the listen leader, and is used to inform the next server in the cluster to\n  * start a local discovery\n  *\n  * @param  {String} serverName       the name of the server to notify\n  * @param  {String} subscriptionName the subscription to find a provider for\n  */\n  _sendRemoteDiscoveryStart (serverName, subscriptionName) {\n    const messageTopic = this._getMessageBusTopic(serverName, this._topic)\n    this._messageConnector.publish(messageTopic, {\n      topic: messageTopic,\n      action: C.ACTIONS.LISTEN,\n      data: [serverName, subscriptionName, this._options.serverName]\n    })\n  }\n\n  /**\n  * Sent by the listen follower, and is used to inform the leader that it has\n  * complete its local discovery start\n  *\n  * @param  {String} listenLeaderServerName  the name of the listen leader\n  * @param  {String} subscriptionName the subscription to that has just finished\n  */\n  _sendRemoteDiscoveryStop (listenLeaderServerName, subscriptionName) {\n    const messageTopic = this._getMessageBusTopic(listenLeaderServerName, this._topic)\n    this._messageConnector.publish(messageTopic, {\n      topic: messageTopic,\n      action: C.ACTIONS.ACK,\n      data: [listenLeaderServerName, subscriptionName]\n    })\n  }\n\n  /**\n    * Send by a node when all local subscriptions are discarded, allowing other nodes\n    * to do a provider cleanup if necessary\n    */\n  _sendLastSubscriberRemoved (serverName, subscriptionName) {\n    const messageTopic = this._getMessageBusTopic(serverName, this._topic)\n    this._messageConnector.publish(messageTopic, {\n      topic: messageTopic,\n      action: C.ACTIONS.UNSUBSCRIBE,\n      data: [serverName, subscriptionName]\n    })\n  }\n\n  /**\n  * Send a subscription found to a provider\n  *\n  * @param  {{patten:String, socketWrapper:SocketWrapper}} provider A client that can\n  *                                                        provide the subscription\n  * @param  {String} subscriptionName the subscription to find a provider for\n  */\n  _sendSubscriptionForPatternFound (provider, subscriptionName) {\n    provider.socketWrapper.send(\n      messageBuilder.getMsg(\n        this._topic,\n        C.ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND,\n        [provider.pattern, subscriptionName]\n      )\n    )\n  }\n\n  /**\n  * Send a subscription removed to a provider\n  *\n  * @param  {{patten:String, socketWrapper:SocketWrapper}} provider An object containing the\n  *                                                        client that is currently the active\n  *                                                        provider\n  * @param  {String} subscriptionName the subscription to stop providing\n  */\n  _sendSubscriptionForPatternRemoved (provider, subscriptionName) {\n    provider.socketWrapper.send(\n      messageBuilder.getMsg(\n        this._topic,\n        C.ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED,\n        [provider.pattern, subscriptionName]\n      )\n    )\n  }\n\n  /**\n  * Create a map of all the listeners that patterns match the subscriptionName locally\n  * @param  {Object} patterns         All patterns currently on this deepstream node\n  * @param  {SusbcriptionRegistry} providerRegistry All the providers currently registered\n  * @param  {String} subscriptionName the subscription to find a provider for\n  * @return {Array}                  An array of all the providers that can provide the subscription\n  */\n  _createRemoteListenArray (patterns, providerRegistry, subscriptionName) {\n    let servers = []\n    const providerPatterns = providerRegistry.getNames()\n\n    for (let i = 0; i < providerPatterns.length; i++) {\n      const pattern = providerPatterns[i]\n      let p = patterns[pattern]\n      if (p == null) {\n        this._options.logger.log(C.LOG_LEVEL.WARN, '', `can't handle pattern ${pattern}`)\n        this._addPattern(pattern)\n        p = patterns[pattern]\n      }\n      if (p.test(subscriptionName)) {\n        servers = servers.concat(providerRegistry.getAllServers(pattern))\n      }\n    }\n\n    const set = new Set(servers)\n    set.delete(this._options.serverName)\n\n    if (!this._options.shuffleListenProviders) {\n      return Array.from(set)\n    }\n    return utils.shuffleArray(Array.from(set))\n  }\n\n  /**\n  * Create a map of all the listeners that patterns match the subscriptionName locally\n  * @param  {Object} patterns         All patterns currently on this deepstream node\n  * @param  {SusbcriptionRegistry} providerRegistry All the providers currently registered\n  * @param  {String} subscriptionName the subscription to find a provider for\n  * @return {Array}                  An array of all the providers that can provide the subscription\n  */\n  _createLocalListenArray (patterns, providerRegistry, subscriptionName) { // eslint-disable-line\n    const providers = []\n    for (const pattern in patterns) {\n      if (patterns[pattern].test(subscriptionName)) {\n        for (const socketWrapper of providerRegistry.getLocalSubscribers(pattern)) {\n          providers.push({ pattern, socketWrapper })\n        }\n      }\n    }\n\n    if (!this._options.shuffleListenProviders) {\n      return providers\n    }\n    return utils.shuffleArray(providers)\n  }\n\n  /**\n  * Extracts the subscription pattern from the message and notifies the sender\n  * if something went wrong\n  *\n  * @param   {SocketWrapper} socketWrapper\n  * @param   {Object} message\n  *\n  * @returns {String}\n  */\n  _getPattern (socketWrapper, message) {\n    if (message.data.length > 2) {\n      this._onMsgDataError(socketWrapper, message.raw)\n      return null\n    }\n\n    const pattern = message.data[0]\n\n    if (typeof pattern !== 'string') {\n      this._onMsgDataError(socketWrapper, pattern)\n      return null\n    }\n\n    return pattern\n  }\n\n  /**\n  * Validates that the pattern is not empty and is a valid regular expression\n  *\n  * @param   {SocketWrapper} socketWrapper\n  * @param   {String} pattern\n  *\n  * @returns {RegExp}\n  */\n  _validatePattern (socketWrapper, pattern) {\n    if (!pattern) {\n      return false\n    }\n\n    try {\n      return new RegExp(pattern)\n    } catch (e) {\n      this._onMsgDataError(socketWrapper, e.toString())\n      return false\n    }\n  }\n\n  /**\n  * Processes errors for invalid messages\n  *\n  * @param   {SocketWrapper} socketWrapper\n  * @param   {String} errorMsg\n  * @param   {Event} [errorEvent] Default to C.EVENT.INVALID_MESSAGE_DATA\n  */\n  _onMsgDataError (socketWrapper, errorMsg, errorEvent) {\n    errorEvent = errorEvent || C.EVENT.INVALID_MESSAGE_DATA // eslint-disable-line\n    socketWrapper.sendError(this._topic, errorEvent, errorMsg)\n    // TODO: This isn't a CRITICAL error, would we say its an info\n    this._options.logger.log(C.LOG_LEVEL.ERROR, errorEvent, errorMsg)\n  }\n\n  /**\n  * Get the unique topic to use for the message bus\n  * @param  {String} serverName the name of the server\n  * @param  {Topic} topic\n  * @return {String}\n  */\n  _getMessageBusTopic (serverName, topic) { // eslint-disable-line\n    return C.TOPIC.LEADER_PRIVATE + serverName + topic + C.ACTIONS.LISTEN\n  }\n\n  /**\n  * Returns the unique lock when leading a listen discovery phase\n  *\n  * @param  {String} subscriptionName the subscription to find a provider for\n  *\n  * @return {String}\n  */\n  _getUniqueLockName (subscriptionName) {\n    return `${this._uniqueLockName}_${subscriptionName}`\n  }\n\n  /**\n  * Create a has provider update message\n  *\n  * @returns {Message}\n  */\n  _createHasProviderMessage (hasProvider, topic, subscriptionName) { // eslint-disable-line\n    return messageBuilder.getMsg(\n      topic,\n      C.ACTIONS.SUBSCRIPTION_HAS_PROVIDER,\n      [subscriptionName, (hasProvider ? C.TYPES.TRUE : C.TYPES.FALSE)]\n    )\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/listen/listener-timeout-registry.js":"'use strict'\n\nconst messageBuilder = require('../message/message-builder')\nconst C = require('../constants/constants')\n\nmodule.exports = class ListenerTimeoutRegistry {\n\n  /**\n  * The ListenerTimeoutRegistry is responsible for keeping track of listeners that have\n  * been asked whether they want to provide a certain subscription, but have not yet\n  * responded.\n  *\n  * @param {Topic} type\n  * @param {Map} options\n  *\n  * @constructor\n  */\n  constructor (type, options) {\n    this._type = type\n    this._options = options\n    this._timeoutMap = {}\n    this._timedoutProviders = {}\n    this._acceptedProvider = {}\n  }\n\n  /**\n    * The main entry point, which takes a message from a provider\n    * that has already timed out and does the following:\n    *\n    * 1) If reject, remove from map\n    * 2) If accept, store as an accepted and reject all following accepts\n    *\n    * @param {SocketWrapper} socketWrapper\n    * @param {Object} message deepstream message\n    *\n    * @private\n    * @returns {void}\n    */\n  handle (socketWrapper, message) {\n    const subscriptionName = message.data[1]\n    const index = this._getIndex(socketWrapper, message)\n    const provider = this._timedoutProviders[subscriptionName][index]\n    if (message.action === C.ACTIONS.LISTEN_ACCEPT) {\n      if (!this._acceptedProvider[subscriptionName]) {\n        this._acceptedProvider[subscriptionName] = this._timedoutProviders[subscriptionName][index]\n      } else {\n        provider.socketWrapper.send(\n          messageBuilder.getMsg(\n            this._type,\n            C.ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED,\n            [provider.pattern, subscriptionName]\n          )\n        )\n      }\n    } else if (message.action === C.ACTIONS.LISTEN_REJECT) {\n      this._timedoutProviders[subscriptionName].splice(index, 1)\n    }\n  }\n\n  /**\n    * Clear cache once discovery phase is complete\n    *\n    * @param {String} subscriptionName the subscription that needs to be removed\n    *\n    * @public\n    * @returns {void}\n    */\n  clear (subscriptionName) {\n    delete this._timeoutMap[subscriptionName]\n    delete this._timedoutProviders[subscriptionName]\n    delete this._acceptedProvider[subscriptionName]\n  }\n\n  /**\n    * Called whenever a provider closes to ensure cleanup\n    *\n    * @param {SocketWrapper} socketWrapper the now closed connection endpoint\n    *\n    * @private\n    * @returns {void}\n    */\n  removeProvider (socketWrapper) {\n    for (const acceptedProvider in this._acceptedProvider) {\n      if (this._acceptedProvider[acceptedProvider].socketWrapper === socketWrapper) {\n        delete this._acceptedProvider[acceptedProvider]\n      }\n    }\n    for (const subscriptionName in this._timeoutMap) {\n      if (this._timeoutMap[subscriptionName]) {\n        this.clearTimeout(subscriptionName)\n      }\n    }\n  }\n  /**\n  * Starts a timeout for a provider. The following cases can apply\n  *\n  * Provider accepts within the timeout: We stop here\n  * Provider rejects within the timeout: We ask the next provider\n  * Provider doesn't respond within the timeout: We ask the next provider\n  *\n  * Provider accepts after the timeout:\n  *  If no other provider accepted yet, we'll wait for the current request to end and stop here\n  *  If another provider has accepted already, we'll immediatly send a SUBSCRIPTION_REMOVED message\n  *\n  * @param {String}   subscriptionName The subscription name\n  * @param {Object}   provider         The provider that may timeout\n  * @param {Function} callback         The callback if the timeout occurs\n  *\n  * @public\n  * @returns {void}\n  */\n  addTimeout (subscriptionName, provider, callback) {\n    const timeoutId = setTimeout(() => {\n      if (this._timedoutProviders[subscriptionName] == null) {\n        this._timedoutProviders[subscriptionName] = []\n      }\n      this._timedoutProviders[subscriptionName].push(provider)\n      callback(subscriptionName)\n    }, this._options.listenResponseTimeout)\n    this._timeoutMap[subscriptionName] = timeoutId\n  }\n\n  /**\n    * Clear the timeout for a LISTEN_ACCEPT or LISTEN_REJECt recieved\n    * by the listen registry\n    *\n    * @public\n    */\n  clearTimeout (subscriptionName) {\n    clearTimeout(this._timeoutMap[subscriptionName])\n    delete this._timeoutMap[subscriptionName]\n  }\n\n  /**\n    * Return if the socket is a provider that previously timeout\n    *\n    * @public\n    */\n  isALateResponder (socketWrapper, message) {\n    const index = this._getIndex(socketWrapper, message)\n    return this._timedoutProviders[message.data[1]] && index !== -1\n  }\n\n  /**\n    * Return if the socket is a provider that previously timeout\n    *\n    * @public\n    */\n  rejectLateResponderThatAccepted (subscriptionName) {\n    const provider = this._acceptedProvider[subscriptionName]\n    if (provider) {\n      provider.socketWrapper.send(\n                messageBuilder.getMsg(\n                    this._type,\n                    C.ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED,\n                    [provider.pattern, subscriptionName]\n                )\n            )\n    }\n  }\n\n  /**\n    * Return if the socket is a provider that previously timeout\n    *\n    * @public\n    */\n  getLateResponderThatAccepted (subscriptionName) {\n    return this._acceptedProvider[subscriptionName]\n  }\n\n  /**\n    * Return if the socket is a provider that previously timeout\n    *\n    * @private\n    */\n  _getIndex (socketWrapper, message) {\n    const pattern = message.data[0]\n    const subscriptionName = message.data[1]\n    const timedoutProviders = this._timedoutProviders[subscriptionName]\n\n    if (timedoutProviders) {\n      for (let i = 0; i < timedoutProviders.length; i++) {\n        if (\n          timedoutProviders[i].socketWrapper === socketWrapper &&\n          timedoutProviders[i].pattern === pattern\n        ) {\n          return i\n        }\n      }\n    }\n\n    return -1\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/utils/read-message.js":"'use strict'\n\nconst C = require('../constants/constants')\n\nfunction readMessage (message) {\n  const TOPIC = C.TOPIC\n  const ACTIONS = C.ACTIONS\n  return {\n    isRecord: message.topic === TOPIC.RECORD,\n    isEvent: message.topic === TOPIC.EVENT,\n    isRPC: message.topic === TOPIC.RPC,\n\n    isCreate: message.action === ACTIONS.CREATEORREAD,\n    isRead: message.action === ACTIONS.CREATEORREAD,\n    isChange: (\n      message.action === ACTIONS.PATCH || message.action === ACTIONS.UPDATE\n    ),\n    isDelete: message.action === ACTIONS.DELETE,\n\n    isAck: message.action === ACTIONS.ACK,\n    isSubscribe: message.action === ACTIONS.SUBSCRIBE,\n    isUnsubscribe: message.action === ACTIONS.UNSUBSCRIBE,\n    isRequest: message.action === ACTIONS.REQUEST,\n    isRejection: message.action === ACTIONS.REJECTION,\n\n    name: message.data[0],\n    path: message.action === ACTIONS.PATCH ? message.data[2] : undefined,\n    data: message.action === ACTIONS.PATCH ? message.data[3] : message.data[2]\n  }\n}\n\nmodule.exports = readMessage\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/default-options.js":"'use strict'\n/* eslint-disable global-require */\nconst utils = require('./utils/utils')\nconst C = require('./constants/constants')\n\nexports.get = function () {\n  const options = {\n    /*\n    * General\n    */\n    serverName: utils.getUid(),\n    showLogo: true,\n    logLevel: C.LOG_LEVEL.INFO,\n\n    /*\n    * Connectivity\n    */\n    port: 6020,\n    host: '0.0.0.0',\n    urlPath: '/deepstream',\n    healthCheckPath: '/health-check',\n    externalUrl: null,\n    heartbeatInterval: 30000,\n\n    /*\n    * SSL Configuration\n    */\n    sslKey: null,\n    sslCert: null,\n    sslCa: null,\n\n    /*\n    * Authentication\n    */\n    auth: {\n      type: 'none'\n    },\n\n    /*\n    * Permissioning\n    */\n    permission: {\n      type: 'none'\n    },\n\n    /*\n    * Default Plugins\n    */\n    messageConnector: require('./default-plugins/noop-message-connector'),\n    cache: require('./default-plugins/local-cache'),\n    storage: require('./default-plugins/noop-storage'),\n\n    /*\n    * Storage options\n    */\n    storageExclusion: null,\n\n    /*\n    * Security\n    */\n    unauthenticatedClientTimeout: 180000,\n    maxAuthAttempts: 3,\n    logInvalidAuthData: true,\n    maxMessageSize: 1048576,\n\n    /**\n     * Listening\n     */\n    shuffleListenProviders: true,\n\n    /*\n    * Timeouts\n    */\n    rpcAckTimeout: 1000,\n    rpcTimeout: 10000,\n    cacheRetrievalTimeout: 1000,\n    storageRetrievalTimeout: 2000,\n    dependencyInitialisationTimeout: 2000,\n    stateReconciliationTimeout: 500,\n    clusterKeepAliveInterval: 5000,\n    clusterActiveCheckInterval: 1000,\n    clusterNodeInactiveTimeout: 6000,\n    listenResponseTimeout: 500,\n    lockTimeout: 1000,\n    lockRequestTimeout: 1000,\n    broadcastTimeout: 0\n  }\n\n  return options\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/config/config-initialiser.js":"'use strict'\n\nconst DefaultLogger = require('../default-plugins/std-out-logger')\nconst fs = require('fs')\nconst utils = require('../utils/utils')\nconst C = require('../constants/constants')\nconst fileUtils = require('./file-utils')\n\nconst LOG_LEVEL_KEYS = Object.keys(C.LOG_LEVEL)\n\nlet commandLineArguments\n\n/**\n * Takes a configuration object and instantiates functional properties.\n * CLI arguments will be considered.\n *\n * @param   {Object} config configuration\n *\n * @returns {Object} configuration\n */\nexports.initialise = function (config) {\n  commandLineArguments = global.deepstreamCLI || {}\n\n  handleUUIDProperty(config)\n  handleSSLProperties(config)\n  handleLogger(config)\n  handlePlugins(config)\n  handleAuthStrategy(config)\n  handlePermissionStrategy(config)\n\n  return config\n}\n\n/**\n * Transform the UUID string config to a UUID in the config object.\n *\n * @param {Object} config deepstream configuration object\n *\n * @private\n * @returns {void}\n */\nfunction handleUUIDProperty (config) {\n  if (config.serverName === 'UUID') {\n    config.serverName = utils.getUid()\n  }\n}\n\n/**\n * Load the SSL files\n * CLI arguments will be considered.\n *\n * @param {Object} config deepstream configuration object\n *\n * @private\n * @returns {void}\n */\nfunction handleSSLProperties (config) {\n  const sslFiles = ['sslKey', 'sslCert', 'sslCa']\n  let key\n  let resolvedFilePath\n  let filePath\n  for (let i = 0; i < sslFiles.length; i++) {\n    key = sslFiles[i]\n    filePath = config[key]\n    if (!filePath) {\n      continue\n    }\n    resolvedFilePath = fileUtils.lookupConfRequirePath(filePath)\n    try {\n      config[key] = fs.readFileSync(resolvedFilePath, 'utf8')\n    } catch (e) {\n      throw new Error(`The file path \"${resolvedFilePath}\" provided by \"${key}\" does not exist.`)\n    }\n  }\n}\n\n/**\n * Initialize the logger and overwrite the root logLevel if it's set\n * CLI arguments will be considered.\n *\n * @param {Object} config deepstream configuration object\n *\n * @private\n * @returns {void}\n */\nfunction handleLogger (config) {\n  const configOptions = (config.logger || {}).options\n  let Logger\n  if (config.logger == null || config.logger.name === 'default') {\n    Logger = DefaultLogger\n  } else {\n    Logger = resolvePluginClass(config.logger, 'logger')\n  }\n\n  if (configOptions instanceof Array) {\n    // Note: This will not work on options without filename, and\n    // is biased against for the winston logger\n    let options\n    for (let i = 0; i < configOptions.length; i++) {\n      options = configOptions[i].options\n      if (options && options.filename) {\n        options.filename = fileUtils.lookupConfRequirePath(options.filename)\n      }\n    }\n  }\n\n  config.logger = new Logger(configOptions)\n  if (LOG_LEVEL_KEYS.indexOf(config.logLevel) !== -1) {\n    // NOTE: config.logLevel has highest priority, compare to the level defined\n    // in the nested logger object\n    config.logLevel = C.LOG_LEVEL[config.logLevel]\n    config.logger.setLogLevel(config.logLevel)\n  }\n}\n\n/**\n * Handle the plugins property in the config object the connectors.\n * Allowed types: {message|cache|storage}\n * Plugins can be passed either as a __path__ property or as a __name__ property with\n * a naming convetion: *{cache: {name: 'redis'}}* will be resolved to the\n * npm module *deepstream.io-cache-redis*\n * Exception: *message* will be resolved to *msg*\n * Options to the constructor of the plugin can be passed as *options* object.\n *\n * CLI arguments will be considered.\n *\n * @param {Object} config deepstream configuration object\n *\n * @private\n * @returns {void}\n */\nfunction handlePlugins (config) {\n  if (config.plugins == null) {\n    return\n  }\n  // mappnig between the root properties which contains the plugin instance\n  // and the plugin configuration objects\n  const connectorMap = {\n    messageConnector: 'message',\n    cache: 'cache',\n    storage: 'storage'\n  }\n  // mapping between the plugin configuration properties and the npm module\n  // name resolution\n  const typeMap = {\n    message: 'msg',\n    cache: 'cache',\n    storage: 'storage'\n  }\n  const plugins = {\n    messageConnector: config.plugins.message,\n    cache: config.plugins.cache,\n    storage: config.plugins.storage\n  }\n\n  for (const key in plugins) {\n    const plugin = plugins[key]\n    if (plugin != null) {\n      const PluginConstructor = resolvePluginClass(plugin, typeMap[connectorMap[key]])\n      config[key] = new PluginConstructor(plugin.options)\n    }\n  }\n}\n\n/**\n * Instantiate the given plugin, which either needs a path property or a name\n * property which fits to the npm module name convention. Options will be passed\n * to the constructor.\n *\n * CLI arguments will be considered.\n *\n * @param {Object} config deepstream configuration object\n *\n * @private\n * @returns {Function} Instance return be the plugin constructor\n */\nfunction resolvePluginClass (plugin, type) {\n  // nexe needs *global.require* for __dynamic__ modules\n  // but browserify and proxyquire can't handle *global.require*\n  const req = global && global.require ? global.require : require\n  let requirePath\n  let pluginConstructor\n  if (plugin.path != null) {\n    requirePath = fileUtils.lookupLibRequirePath(plugin.path)\n    pluginConstructor = req(requirePath)\n  } else if (plugin.name != null) {\n    if (type != null) {\n      requirePath = `deepstream.io-${type}-${plugin.name}`\n      requirePath = fileUtils.lookupLibRequirePath(requirePath)\n      pluginConstructor = req(requirePath)\n    }\n  } else {\n    throw new Error(`Neither name nor path property found for ${type}`)\n  }\n  return pluginConstructor\n}\n\n/**\n * Instantiates the authentication handler registered for *config.auth.type*\n *\n * CLI arguments will be considered.\n *\n * @param   {Object} config deepstream configuration object\n *\n * @private\n * @returns {void}\n */\nfunction handleAuthStrategy (config) {\n  const authStrategies = {\n    none: require('../authentication/open-authentication-handler'), // eslint-disable-line\n    file: require('../authentication/file-based-authentication-handler'), // eslint-disable-line\n    http: require('../authentication/http-authentication-handler') // eslint-disable-line\n  }\n\n  if (!config.auth) {\n    throw new Error('No authentication type specified')\n  }\n\n  if (!authStrategies[config.auth.type]) {\n    throw new Error(`Unknown authentication type ${config.auth.type}`)\n  }\n\n  if (commandLineArguments.disableAuth) {\n    config.auth.type = 'none'\n    config.auth.options = {}\n  }\n\n  if (config.auth.options && config.auth.options.path) {\n    config.auth.options.path = fileUtils.lookupConfRequirePath(config.auth.options.path)\n  }\n\n  config.authenticationHandler =\n    new (authStrategies[config.auth.type])(config.auth.options, config.logger)\n}\n\n/**\n * Instantiates the permission handler registered for *config.permission.type*\n *\n * CLI arguments will be considered.\n *\n * @param   {Object} config deepstream configuration object\n *\n * @private\n * @returns {void}\n */\nfunction handlePermissionStrategy (config) {\n  const permissionStrategies = {\n    config: require('../permission/config-permission-handler'), // eslint-disable-line\n    none: require('../permission/open-permission-handler') // eslint-disable-line\n  }\n\n  if (!config.permission) {\n    throw new Error('No permission type specified')\n  }\n\n  if (!permissionStrategies[config.permission.type]) {\n    throw new Error(`Unknown permission type ${config.permission.type}`)\n  }\n\n  if (commandLineArguments.disablePermissions) {\n    config.permission.type = 'none'\n    config.permission.options = {}\n  }\n\n  if (config.permission.options && config.permission.options.path) {\n    config.permission.options.path = fileUtils.lookupConfRequirePath(config.permission.options.path)\n  }\n\n  config.permissionHandler = new (permissionStrategies[config.permission.type])(config)\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/default-plugins/std-out-logger.js":"'use strict'\n\nrequire('colors')\nconst C = require('../constants/constants')\n\nconst EOL = require('os').EOL\n\n/**\n * Logs to the operatingsystem's standard-out and standard-error streams.\n *\n * Consoles / Terminals as well as most log-managers and logging systems\n * consume messages from these streams\n *\n * @constructor\n */\nconst StdOutLogger = function (options) {\n  this._options = options || {}\n  this.isReady = true\n  this._$useColors = this._options.colors === undefined ? true : this._options.colors\n  this._logLevelColors = [\n    'white',\n    'green',\n    'yellow',\n    'red'\n  ]\n\n  this._currentLogLevel = C.LOG_LEVEL[this._options.logLevel] || C.LOG_LEVEL.DEBUG\n}\n\n/**\n * Logs a line\n *\n * @param   {Number} logLevel   One of the C.LOG_LEVEL constants\n * @param   {String} event      One of the C.EVENT constants\n * @param   {String} logMessage Any string\n *\n * @public\n * @returns {void}\n */\nStdOutLogger.prototype.log = function (logLevel, event, logMessage) {\n  if (logLevel < this._currentLogLevel) {\n    return\n  }\n\n  const msg = `${event} | ${logMessage}`\n  let outputStream\n\n  if (logLevel === C.LOG_LEVEL.ERROR || logLevel === C.LOG_LEVEL.WARN) {\n    outputStream = 'stderr'\n  } else {\n    outputStream = 'stdout'\n  }\n\n  if (this._$useColors) {\n    process[outputStream].write(msg[this._logLevelColors[logLevel]] + EOL)\n  } else {\n    process[outputStream].write(msg + EOL)\n  }\n}\n\n/**\n * Sets the log-level. This can be called at runtime.\n *\n * @param   {Number} logLevel   One of the C.LOG_LEVEL constants\n *\n * @public\n * @returns {void}\n */\nStdOutLogger.prototype.setLogLevel = function (logLevel) {\n  this._currentLogLevel = logLevel\n}\n\nmodule.exports = StdOutLogger\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/config/file-utils.js":"'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\n\n/**\n* Append the global library directory as the prefix to any path\n* used here\n*\n* @param {String} filePath\n*\n* @private\n* @returns {String} file path with the library prefix used\n*/\nexports.lookupLibRequirePath = function (filePath) {\n  return exports.lookupRequirePath(filePath, global.deepstreamLibDir)\n}\n\n/**\n* Append the global configuration directory as the prefix to any path\n* used here\n*\n* @param {String} filePath\n*\n* @private\n* @returns {String} file path with the configuration prefix used\n*/\nexports.lookupConfRequirePath = function (filePath) {\n  return exports.lookupRequirePath(filePath, global.deepstreamConfDir)\n}\n\n/**\n * Resolve a path which will be passed to *require*.\n *\n * If a prefix is not set the filePath will be returned\n * Otherwise it will either replace return a new path prepended with the prefix.\n * If the prefix is not an absolute path it will also prepend the CWD.\n *\n * file        || relative (starts with .) | absolute | else (npm module path)\n * -----------------------------------------------------------------------------\n * *prefix     || *CWD + prefix + file     | file     | *CWD + prefix + file\n * *no prefix  ||  CWD + file              | file     | file (resolved by nodes require)\n *\n * *CWD = ignore CWD if prefix is absolute\n *\n * @param {String} filePath\n * @param {String} prefix\n *\n * @private\n * @returns {String} file path with the prefix\n */\nexports.lookupRequirePath = function (filePath, prefix) {\n  // filePath is absolute\n  if (path.parse(filePath).root !== '') {\n    return filePath\n  }\n\n  // filePath is not relative (and not absolute)\n  if (filePath[0] !== '.') {\n    if (prefix == null) {\n      return filePath\n    }\n    return resolvePrefixAndFile(filePath, prefix)\n  }\n\n  // filePath is relative, starts with .\n  if (prefix == null) {\n    return path.resolve(process.cwd(), filePath)\n  }\n  return resolvePrefixAndFile(filePath, prefix)\n}\n\n/**\n * Returns true if a file exists for a given path\n *\n * @param   {String} path\n *\n * @private\n * @returns {Boolean} exists\n */\nexports.fileExistsSync = function (filePath) {\n  try {\n    fs.lstatSync(filePath)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\n/**\n* Append the prefix to the current working directory,\n* or use it as an absolute path\n*\n* @param   {String} nonAbsoluteFilePath\n* @param   {String} prefix\n*\n* @private\n* @returns {String} resolvedPath\n*/\nfunction resolvePrefixAndFile (nonAbsoluteFilePath, prefix) {\n  // prefix is not absolute\n  if (path.parse(prefix).root === '') {\n    return path.resolve(process.cwd(), prefix, nonAbsoluteFilePath)\n  }\n\n  // prefix is absolute\n  return path.resolve(prefix, nonAbsoluteFilePath)\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/config/js-yaml-loader.js":"'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst yaml = require('js-yaml')\n\nconst defaultOptions = require('../default-options')\nconst utils = require('../utils/utils')\n\nconst configInitialiser = require('./config-initialiser')\nconst fileUtils = require('./file-utils')\n\nconst SUPPORTED_EXTENSIONS = ['.yml', '.yaml', '.json', '.js']; path.join('.', 'conf', 'config')\nconst DEFAULT_CONFIG_DIRS = [path.join('.', 'conf', 'config'), '/etc/deepstream/config', '/usr/local/etc/deepstream/config']\n\n/**\n * Reads and parse a general configuration file content.\n *\n * @param {String} filePath\n * @param {Function} callback\n *\n * @public\n * @returns {void}\n */\nexports.readAndParseFile = function (filePath, callback) {\n  try {\n    fs.readFile(filePath, 'utf8', (error, fileContent) => {\n      if (error) {\n        return callback(error)\n      }\n\n      try {\n        const config = parseFile(filePath, fileContent)\n        return callback(null, config)\n      } catch (parseError) {\n        return callback(parseError)\n      }\n    })\n  } catch (error) {\n    callback(error)\n  }\n}\n\n/**\n * Parse a general configuration file\n * These file extension ans formats are allowed:\n * .yml, .js, .json\n *\n * If no fileContent is passed the file is read synchronously\n *\n * @param {String} filePath\n * @param {String} fileContent\n *\n * @private\n * @returns {Object} config\n */\nfunction parseFile (filePath, fileContent) {\n  let config = null\n  const extension = path.extname(filePath)\n\n  if (extension === '.yml' || extension === '.yaml') {\n    config = yaml.safeLoad(replaceEnvironmentVariables(fileContent))\n  } else if (extension === '.js') {\n    config = require(path.resolve(filePath)) // eslint-disable-line\n  } else if (extension === '.json') {\n    config = JSON.parse(replaceEnvironmentVariables(fileContent))\n  } else {\n    throw new Error(`${extension} is not supported as configuration file`)\n  }\n\n  return config\n}\n\n/**\n * Loads a config file without having to initialise it. Useful for one\n * off operations such as generating a hash via cli\n *\n * @param {Object|String} args commander arguments or path to config\n *\n * @public\n * @returns {Object} config deepstream configuration object\n */\nmodule.exports.loadConfigWithoutInitialisation = function (filePath, /* test only */ args) {\n  const argv = args || global.deepstreamCLI || {}\n  const configPath = setGlobalConfigDirectory(argv, filePath)\n  const configString = fs.readFileSync(configPath, { encoding: 'utf8' })\n  const rawConfig = parseFile(configPath, configString)\n  const config = extendConfig(rawConfig, argv)\n  setGlobalLibDirectory(argv, config)\n  return {\n    config,\n    configPath\n  }\n}\n\n/**\n * Loads a file as deepstream config. CLI args have highest priority after the\n * configuration file. If some properties are not set they will be defaulted\n * to default values defined in the defaultOptions.js file.\n * Configuraiton file will be transformed to a deepstream object by evaluating\n * some properties like the plugins (logger and connectors).\n *\n * @param {Object|String} args commander arguments or path to config\n *\n * @public\n * @returns {Object} config deepstream configuration object\n */\nmodule.exports.loadConfig = function (filePath, /* test only */ args) {\n  const config = exports.loadConfigWithoutInitialisation(filePath, args)\n  return {\n    config: configInitialiser.initialise(config.config),\n    file: config.configPath\n  }\n}\n\n/**\n* Set the globalConfig prefix that will be used as the directory for ssl, permissions and auth\n* relative files within the config file\n*/\nfunction setGlobalConfigDirectory (argv, filePath) {\n  const customConfigPath =\n      argv.c ||\n      argv.config ||\n      filePath ||\n      process.env.DEEPSTREAM_CONFIG_DIRECTORY\n  const configPath = customConfigPath\n    ? verifyCustomConfigPath(customConfigPath)\n    : getDefaultConfigPath()\n  global.deepstreamConfDir = path.dirname(configPath)\n  return configPath\n}\n\n/**\n* Set the globalLib prefix that will be used as the directory for the logger\n* and plugins within the config file\n*/\nfunction setGlobalLibDirectory (argv, config) {\n  const libDir =\n      argv.l ||\n      argv.libDir ||\n      (config.libDir && fileUtils.lookupConfRequirePath(config.libDir)) ||\n      process.env.DEEPSTREAM_LIBRARY_DIRECTORY\n  global.deepstreamLibDir = libDir\n}\n\n/**\n * Augments the basic configuration with command line parameters\n * and normalizes paths within it\n *\n * @param   {Object} config    configuration\n * @param   {Object} argv      command line arguments\n * @param   {String} configDir config directory\n *\n * @private\n * @returns {Object} extended config\n */\nfunction extendConfig (config, argv) {\n  const cliArgs = {}\n  let key\n\n  for (key in defaultOptions.get()) {\n    cliArgs[key] = typeof argv[key] === 'undefined' ? undefined : argv[key]\n  }\n\n  return utils.merge({ plugins: {} }, defaultOptions.get(), config, cliArgs)\n}\n\n/**\n * Checks if a config file is present at a given path\n *\n * @param   {String} configPath the path to the config file\n *\n * @private\n * @returns {String} verified path\n */\nfunction verifyCustomConfigPath (configPath) {\n  if (fileUtils.fileExistsSync(configPath)) {\n    return configPath\n  }\n\n  throw new Error(`Configuration file not found at: ${configPath}`)\n}\n\n/**\n * Fallback if no config path is specified. Will attempt to load the file from the default directory\n *\n * @private\n * @returns {String} filePath\n */\nfunction getDefaultConfigPath () {\n  let filePath\n  let i\n  let k\n\n  for (k = 0; k < DEFAULT_CONFIG_DIRS.length; k++) {\n    for (i = 0; i < SUPPORTED_EXTENSIONS.length; i++) {\n      filePath = DEFAULT_CONFIG_DIRS[k] + SUPPORTED_EXTENSIONS[i]\n      if (fileUtils.fileExistsSync(filePath)) {\n        return filePath\n      }\n    }\n  }\n\n  throw new Error('No config file found')\n}\n\n/**\n * Handle the introduction of global enviroment variables within\n * the yml file, allowing value substitution.\n *\n * For example:\n * ```\n * host: $HOST_NAME\n * port: $HOST_PORT\n * ```\n *\n * @param {String} fileContent The loaded yml file\n *\n * @private\n * @returns {void}\n */\nfunction replaceEnvironmentVariables (fileContent) {\n  const environmentVariable = new RegExp(/\\${([^}]+)}/g)\n  // eslint-disable-next-line\n  fileContent = fileContent.replace(environmentVariable, (a, b) => process.env[b] || b)\n  return fileContent\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/rpc/rpc-handler.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst SubscriptionRegistry = require('../utils/subscription-registry')\nconst Rpc = require('./rpc')\nconst RpcProxy = require('./rpc-proxy')\nconst utils = require('../utils/utils')\n\nmodule.exports = class RpcHandler {\n  /**\n  * Handles incoming messages for the RPC Topic.\n  *\n  * @param {Object} options deepstream options\n  */\n  constructor (options) {\n    this._options = options\n    this._subscriptionRegistry = new SubscriptionRegistry(options, C.TOPIC.RPC)\n\n    this._privateTopic = C.TOPIC.PRIVATE + this._options.serverName\n    this._options.messageConnector.subscribe(\n      this._privateTopic,\n      this._onPrivateMessage.bind(this)\n    )\n\n    this._rpcs = new Map()\n  }\n\n  /**\n  * Main interface. Handles incoming messages\n  * from the message distributor\n  *\n  * @param   {SocketWrapper} socketWrapper\n  * @param   {Object} message parsed and validated deepstream message\n  *\n  * @public\n  * @returns {void}\n  */\n  handle (socketWrapper, message) {\n    if (message.action === C.ACTIONS.SUBSCRIBE) {\n      this._registerProvider(socketWrapper, message)\n    } else if (message.action === C.ACTIONS.UNSUBSCRIBE) {\n      this._unregisterProvider(socketWrapper, message)\n    } else if (message.action === C.ACTIONS.REQUEST) {\n      this._makeRpc(socketWrapper, message)\n    } else if (\n      message.action === C.ACTIONS.RESPONSE ||\n      message.action === C.ACTIONS.ACK ||\n      message.action === C.ACTIONS.REJECTION ||\n      message.action === C.ACTIONS.ERROR\n    ) {\n      const rpcNameIndex = (message.action === C.ACTIONS.ACK || message.action === C.ACTIONS.ERROR)\n        ? 1 : 0\n      const correlationId = message.data[rpcNameIndex + 1]\n      const rpcData = this._rpcs.get(correlationId)\n      if (rpcData) {\n        rpcData.rpc.handle(message)\n        if (rpcData.rpc.isComplete) {\n          this._rpcs.delete(correlationId)\n        }\n      } else {\n        socketWrapper.sendError(\n          C.TOPIC.RPC,\n          C.EVENT.INVALID_MESSAGE_DATA,\n          `unexpected state for rpc ${message.data[rpcNameIndex]} with action ${message.action}`\n        )\n      }\n    } else {\n      /*\n      *  RESPONSE-, ERROR-, REJECT- and ACK messages from the provider are processed\n      * by the Rpc class directly\n      */\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.UNKNOWN_ACTION, message.action)\n\n      if (socketWrapper !== C.SOURCE_MESSAGE_CONNECTOR) {\n        socketWrapper.sendError(C.TOPIC.RPC, C.EVENT.UNKNOWN_ACTION, `unknown action ${message.action}`)\n      }\n    }\n  }\n\n  /**\n  * This method is called by Rpc to reroute its request\n  *\n  * If a provider is temporarily unable to service a request, it can reject it. Deepstream\n  * will then try to reroute it to an alternative provider. Finding an alternative provider\n  * happens in this method.\n  *\n  * Initially, deepstream will look for a local provider that hasn't been used by the RPC yet.\n  * If non can be found, it will go through the currently avaiblable remote providers and try\n  * find one that hasn't been used yet.\n  *\n  * If a remote provider couldn't be found or all remote-providers have been tried already\n  * this method will return null - which in turn will prompt the RPC to send a NO_RPC_PROVIDER\n  * error to the client\n  *\n  * @param {String}  rpcName\n  * @param {String}  correlationId\n  *\n  * @public\n  * @returns {SocketWrapper|RpcProxy} alternativeProvider\n  */\n  getAlternativeProvider (rpcName, correlationId) {\n    const rpcData = this._rpcs.get(correlationId)\n\n    const subscribers = Array.from(this._subscriptionRegistry.getLocalSubscribers(rpcName))\n    let index = utils.getRandomIntInRange(0, subscribers.length)\n\n    for (let n = 0; n < subscribers.length; ++n) {\n      if (!rpcData.providers.has(subscribers[index])) {\n        rpcData.providers.add(subscribers[index])\n        return subscribers[index]\n      }\n      index = (index + 1) % subscribers.length\n    }\n\n    if (!rpcData.servers) {\n      return null\n    }\n\n    const servers = this._subscriptionRegistry.getAllRemoteServers(rpcName)\n    index = utils.getRandomIntInRange(0, servers.length)\n    for (let n = 0; n < servers.length; ++n) {\n      if (!rpcData.servers.has(servers[index])) {\n        rpcData.servers.add(servers[index])\n        return new RpcProxy(this._options, C.TOPIC.PRIVATE + servers[index], rpcName, correlationId)\n      }\n      index = (index + 1) % servers.length\n    }\n\n    return null\n  }\n\n  /**\n  * Callback for subscription messages. Registers\n  * a client as a provider for specific remote\n  * procedure calls as identified by <rpcName>\n  *\n  * @param   {SocketWrapper} socketWrapper\n  * @param   {Object} message parsed and validated deepstream message\n  *\n  * @private\n  * @returns {void}\n  */\n  _registerProvider (socketWrapper, message) {\n    if (isValidMessage(1, socketWrapper, message)) {\n      this._subscriptionRegistry.subscribe(message.data[0], socketWrapper)\n    }\n  }\n\n  /**\n  * Callback for unsubscribe messages. Removes\n  * a client as a provider for specific remote\n  * procedure calls as identified by <rpcName>\n  *\n  * @param   {SocketWrapper} socketWrapper\n  * @param   {Object} message parsed and validated deepstream message\n  *\n  * @private\n  * @returns {void}\n  */\n  _unregisterProvider (socketWrapper, message) {\n    if (isValidMessage(1, socketWrapper, message)) {\n      this._subscriptionRegistry.unsubscribe(message.data[0], socketWrapper)\n    }\n  }\n\n  /**\n  * Executes a RPC. If there are clients connected to\n  * this deepstream instance that can provide the rpc, it\n  * will be routed to a random one of them, otherwise it will be routed\n  * to the message connector\n  *\n  * @param   {SocketWrapper} socketWrapper\n  * @param   {Object} message parsed and validated deepstream message\n  *\n  * @private\n  * @returns {void}\n  */\n  _makeRpc (socketWrapper, message, source) {\n    if (!isValidMessage(2, socketWrapper, message)) {\n      return\n    }\n\n    const rpcName = message.data[0]\n    const correlationId = message.data[1]\n\n    const rpcData = {\n      providers: new Set(),\n      servers: source !== C.SOURCE_MESSAGE_CONNECTOR ? new Set() : null,\n      rpc: null\n    }\n    this._rpcs.set(correlationId, rpcData)\n\n    const subscribers = Array.from(this._subscriptionRegistry.getLocalSubscribers(rpcName))\n    const provider = subscribers[utils.getRandomIntInRange(0, subscribers.length)]\n\n    if (provider) {\n      rpcData.providers.add(provider)\n      rpcData.rpc = new Rpc(this, socketWrapper, provider, this._options, message)\n    } else if (source === C.SOURCE_MESSAGE_CONNECTOR) {\n      socketWrapper.sendError(C.TOPIC.RPC, C.EVENT.NO_RPC_PROVIDER, [rpcName, correlationId])\n    } else {\n      this._makeRemoteRpc(socketWrapper, message)\n    }\n  }\n\n  /**\n  * Callback to remoteProviderRegistry.getProviderProxy()\n  *\n  * If a remote provider is available this method will route the rpc to it.\n  *\n  * If no remote provider could be found this class will return a\n  * NO_RPC_PROVIDER error to the requestor. The RPC won't continue from\n  * thereon\n  *\n  * @param   {SocketWrapper} requestor\n  * @param   {Object} message   RPC Request message\n  *\n  * @private\n  * @returns {void}\n  */\n  _makeRemoteRpc (requestor, message) {\n    const rpcName = message.data[0]\n    const correlationId = message.data[1]\n    const rpcData = this._rpcs.get(correlationId)\n\n    const servers = this._subscriptionRegistry.getAllRemoteServers(rpcName)\n    const server = servers[Math.round(Math.random() * (servers.length - 1))]\n\n    if (server) {\n      const rpcProxy = new RpcProxy(this._options, C.TOPIC.PRIVATE + server, rpcName, correlationId)\n      rpcData.rpc = new Rpc(this, requestor, rpcProxy, this._options, message)\n      return\n    }\n\n    this._rpcs.delete(correlationId)\n\n    this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.NO_RPC_PROVIDER, rpcName)\n\n    if (requestor !== C.SOURCE_MESSAGE_CONNECTOR) {\n      requestor.sendError(C.TOPIC.RPC, C.EVENT.NO_RPC_PROVIDER, [rpcName, correlationId])\n    }\n  }\n\n  /**\n  * Callback for messages that are send directly to\n  * this deepstream instance.\n  *\n  * Please note: Private messages are generic, so the RPC\n  * specific ones need to be filtered out.\n  *\n  * @param   {Object} msg\n  *\n  * @private\n  * @returns {void}\n  */\n  _onPrivateMessage (msg) {\n    if (msg.originalTopic !== C.TOPIC.RPC) {\n      return\n    }\n\n    if (!msg.data || msg.data.length < 2) {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.INVALID_MSGBUS_MESSAGE, msg.data)\n      return\n    }\n\n    msg.topic = msg.originalTopic\n\n    if (msg.action === C.ACTIONS.ERROR && msg.data[0] === C.EVENT.NO_RPC_PROVIDER) {\n      msg.action = C.ACTIONS.REJECTION\n      msg.data = msg.data[1]\n    }\n\n    if (msg.action === C.ACTIONS.REQUEST) {\n      const proxy = new RpcProxy(this._options, msg.remotePrivateTopic, msg.data[0], msg.data[1])\n      this._makeRpc(proxy, msg, C.SOURCE_MESSAGE_CONNECTOR)\n    } else if ((msg.action === C.ACTIONS.ACK || msg.action === C.ACTIONS.ERROR) && msg.data[2]) {\n      this._rpcs.get(msg.data[2]).rpc.handle(msg)\n    } else if (this._rpcs.get(msg.data[1])) {\n      this._rpcs.get(msg.data[1]).rpc.handle(msg)\n    } else {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.UNSOLICITED_MSGBUS_MESSAGE, msg)\n    }\n  }\n\n\n}\n\n/**\n* Checks if the incoming message is valid, e.g. if rpcName\n* is present for subscribe / unsubscribe messages or if\n* rpcName and correlationId is present for rpc calls.\n*\n* @param   {Number}  dataLength    The expected number of entries in the data array\n* @param   {SocketWrapper} socketWrapper\n* @param   {Object} message parsed and validated deepstream message\n*\n* @private\n* @returns {Boolean} isValid\n*/\nfunction isValidMessage (dataLength, socketWrapper, message) {\n  if (message.data && message.data.length >= dataLength && typeof message.data[0] === 'string') {\n    return true\n  }\n\n  socketWrapper.sendError(C.TOPIC.RPC, C.EVENT.INVALID_MESSAGE_DATA, message.raw)\n\n  return false\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/rpc/rpc.js":"'use strict'\n/* eslint-disable max-len */\n\nconst C = require('../constants/constants')\nconst RpcProxy = require('./rpc-proxy')\n\n/**\n * Relays a remote procedure call from a requestor to a provider and routes\n * the providers response to the requestor. Provider might either be a locally\n * connected SocketWrapper or a RpcProviderProxy that forwards messages\n * from a remote provider within the network\n */\nmodule.exports = class Rpc {\n  /**\n  * @param {RpcHandler}           rpcHandler\n  * @param {String|SocketWrapper} requestor SocketWrapper if requested locally,\n  *                                         C.SOURCE_MESSAGE_CONNECTOR if requested\n  *                                         by the message connector\n  * @param {SocketWrapper|RpcProviderProxy} provider  A SocketWrapper like class, able to provide the rpc\n  * @param {Object} options\n  * @param {Object} message\n  *\n  * @constructor\n  */\n  constructor (rpcHandler, requestor, provider, options, message) {\n    this._rpcHandler = rpcHandler\n    this._rpcName = message.data[0]\n    this._correlationId = message.data[1]\n    this._requestor = requestor\n    this._provider = provider\n    this._options = options\n    this._message = message\n    this._isAcknowledged = false\n    this.isComplete = false\n\n    this._setProvider(provider)\n  }\n\n  /**\n  * Processor for incoming messages from the RPC provider. The\n  * RPC provider is expected to send two messages,\n  *\n  * RPC|A|REQ|<rpcName>|<correlationId>\n  *\n  * and\n  *\n  * RPC|RES|<rpcName>|<correlationId|[<data>]\n  *\n  * Both of these messages will just be forwarded directly\n  * to the requestor\n  *\n  * @param   {Object} message parsed and validated provider message\n  *\n  * @private\n  * @returns {void}\n  */\n  handle (message) {\n        // This guard is for backwards compatability. Having multiple responses or recieving an ack\n        // prior to a response should not actually occur\n    if (this.isComplete === true) {\n      return\n    }\n\n    if (message.data[1] !== this._correlationId && message.data[2] !== this._correlationId) {\n      return\n    }\n\n    if (message.action === C.ACTIONS.ACK) {\n      this._handleAck(message)\n    } else if (message.action === C.ACTIONS.REJECTION) {\n      this._reroute()\n    } else if (message.action === C.ACTIONS.RESPONSE || message.action === C.ACTIONS.ERROR) {\n      this._handleResponse(message)\n    }\n  }\n\n  /**\n  * Destroyes this Rpc, either because its completed\n  * or because a timeout has occured\n  *\n  * @public\n  * @returns {void}\n  */\n  destroy () {\n    clearTimeout(this._ackTimeout)\n    clearTimeout(this._responseTimeout)\n\n    this.isComplete = true\n    this._requestor = null\n    this._provider = null\n    this._options = null\n    this._message = null\n  }\n\n  /**\n  * By default, a RPC is the communication between one requestor\n  * and one provider. If the original provider however rejects\n  * the request, deepstream will try to re-route it to another provider.\n  *\n  * This happens in the reroute method. This method will query\n  * the rpc-handler for an alternative provider and - if it has\n  * found one - call this method to replace the provider and re-do\n  * the second leg of the rpc\n  *\n  * @param {SocketWrapper} provider\n  *\n  * @private\n  * @returns {void}\n  */\n  _setProvider (provider) {\n    clearTimeout(this._ackTimeout)\n    clearTimeout(this._responseTimeout)\n\n    this._provider = provider\n    this._ackTimeout = setTimeout(this._onAckTimeout.bind(this), this._options.rpcAckTimeout)\n    this._responseTimeout = setTimeout(this._onResponseTimeout.bind(this), this._options.rpcTimeout)\n    this._send(this._provider, this._message, this._requestor)\n  }\n\n  /**\n  * Handles rpc acknowledgement messages from the provider.\n  * If more than one Ack is received an error will be returned\n  * to the provider\n  *\n  * @param   {Object} message parsed and validated deepstream message\n  *\n  * @private\n  * @returns {void}\n  */\n  _handleAck (message) {\n    if (this._isAcknowledged === true) {\n      this._provider.sendError(C.TOPIC.RPC, C.EVENT.MULTIPLE_ACK, [this._rpcName, this._correlationId])\n      return\n    }\n\n    clearTimeout(this._ackTimeout)\n    this._isAcknowledged = true\n    this._send(this._requestor, message, this._provider)\n  }\n\n  /**\n  * Forwards response messages from the provider. If the provider\n  * sends more than one response subsequent messages will just\n  * be ignored\n  *\n  * @param   {Object} message parsed and validated deepstream message\n  *\n  * @private\n  * @returns {void}\n  */\n  _handleResponse (message) {\n    clearTimeout(this._responseTimeout)\n    this._send(this._requestor, message, this._provider)\n    this.destroy()\n  }\n\n  /**\n  * This method handles rejection messages from the current provider. If\n  * a provider is temporarily unable to serve a request, it can reject it\n  * and deepstream will try to reroute to an alternative provider\n  *\n  * If no alternative provider could be found, this method will send a NO_RPC_PROVIDER\n  * error to the client and destroy itself\n  *\n  * @private\n  * @returns {void}\n  */\n  _reroute () {\n    const alternativeProvider = this._rpcHandler.getAlternativeProvider(this._rpcName, this._correlationId)\n\n    if (alternativeProvider) {\n      this._setProvider(alternativeProvider)\n    } else {\n      this._requestor.sendError(C.TOPIC.RPC, C.EVENT.NO_RPC_PROVIDER, [this._rpcName, this._correlationId])\n      this.destroy()\n    }\n  }\n\n  /**\n  * Callback if the acknowledge message hasn't been returned\n  * in time by the provider\n  *\n  * @private\n  * @returns {void}\n  */\n  _onAckTimeout () {\n    this._requestor.sendError(C.TOPIC.RPC, C.EVENT.ACK_TIMEOUT, [this._rpcName, this._correlationId])\n    this.destroy()\n  }\n\n  /**\n  * Callback if the response message hasn't been returned\n  * in time by the provider\n  *\n  * @private\n  * @returns {void}\n  */\n  _onResponseTimeout () {\n    this._requestor.sendError(C.TOPIC.RPC, C.EVENT.RESPONSE_TIMEOUT, [this._rpcName, this._correlationId])\n    this.destroy()\n  }\n\n  /**\n  * Sends a message to a receiver.\n  *\n  * @param   {SocketWrapper} receiver    the SocketWrapper that will receive the message. Can be a RpcProxy\n  * @param   {Object}        message     deepstream message object\n  *\n  * @private\n  * @returns {void}\n  */\n  _send (receiver, message) { // eslint-disable-line\n    if (receiver instanceof RpcProxy) {\n      receiver.send(message)\n      return\n    }\n\n    receiver.sendMessage(message.topic, message.action, message.data)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/rpc/rpc-proxy.js":"'use strict'\n\nconst C = require('../constants/constants')\n\n/**\n * This class exposes an interface that mimicks the behaviour\n * of a SocketWrapper, connected to a local rpc provider, but\n * infact relays calls from and to the message connector - sneaky.\n */\nmodule.exports = class RpcProxy {\n\n  /**\n  * @param {Object} options\n  * @param {String} receiverPrivateTopic\n  * @return {[type]}\n  * @constructor\n  */\n  constructor (options, receiverPrivateTopic) {\n    this._options = options\n    this._receiverPrivateTopic = receiverPrivateTopic\n    this._privateTopic = C.TOPIC.PRIVATE + this._options.serverName\n  }\n\n  /**\n  * Mimicks the SocketWrapper's send method, but expects a message object,\n  * instead of a string.\n  *\n  * Adds additional information to the message that enables the counterparty\n  * to identify the sender\n  *\n  * @param   {Object} message\n  *\n  * @public\n  * @returns {void}\n  */\n  send (message) {\n    message.remotePrivateTopic = this._privateTopic\n    message.topic = this._receiverPrivateTopic\n    message.originalTopic = C.TOPIC.RPC\n    this._options.messageConnector.publish(this._receiverPrivateTopic, message)\n    message.isCompleted = true\n  }\n\n  /**\n  * Mimicks the SocketWrapper's sendError method.\n  * Sends an error on the specified topic. The\n  * action will automatically be set to C.ACTION.ERROR\n  *\n  * @param {String} topic one of C.TOPIC - ignored in this instance\n  * @param {String} type one of C.EVENT\n  * @param {String} msg generic error message\n  *\n  * @public\n  * @returns {void}\n  */\n  sendError (topic, type, msg) {\n    this._options.messageConnector.publish(this._receiverPrivateTopic, {\n      topic: this._receiverPrivateTopic,\n      originalTopic: C.TOPIC.RPC,\n      action: C.ACTIONS.ERROR,\n      data: [type, msg]\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/record/record-handler.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst SubscriptionRegistry = require('../utils/subscription-registry')\nconst ListenerRegistry = require('../listen/listener-registry')\nconst RecordRequest = require('./record-request')\nconst RecordTransition = require('./record-transition')\nconst RecordDeletion = require('./record-deletion')\n\n/**\n * The entry point for record related operations\n *\n * @param {Object} options deepstream options\n */\nconst RecordHandler = function (options) {\n  this._options = options\n  this._subscriptionRegistry = new SubscriptionRegistry(options, C.TOPIC.RECORD)\n  this._listenerRegistry = new ListenerRegistry(C.TOPIC.RECORD, options, this._subscriptionRegistry)\n  this._subscriptionRegistry.setSubscriptionListener(this._listenerRegistry)\n  this._transitions = {}\n  this._recordRequestsInProgress = {}\n}\n\n/**\n * Handles incoming record requests.\n *\n * Please note that neither CREATE nor READ is supported as a\n * client send action. Instead the client sends CREATEORREAD\n * and deepstream works which one it will be\n *\n * @param   {SocketWrapper} socketWrapper the sender\n * @param   {Object} message parsed and validated deepstream message\n *\n * @public\n * @returns {void}\n */\nRecordHandler.prototype.handle = function (socketWrapper, message) {\n  /*\n   * All messages have to provide at least the name of the record they relate to\n   * or a pattern in case of listen\n   */\n  if (!message.data || message.data.length < 1) {\n    socketWrapper.sendError(C.TOPIC.RECORD, C.EVENT.INVALID_MESSAGE_DATA, message.raw)\n    return\n  }\n\n  if (message.action === C.ACTIONS.CREATEORREAD) {\n    /*\n     * Return the record's contents and subscribes for future updates.\n     * Creates the record if it doesn't exist\n     */\n    this._createOrRead(socketWrapper, message)\n  } else if (message.action === C.ACTIONS.SNAPSHOT) {\n    /*\n     * Return the current state of the record in cache or db\n     */\n    this._snapshot(socketWrapper, message)\n  } else if (message.action === C.ACTIONS.HEAD) {\n    /*\n     * Return the current state of the record in cache or db\n     */\n    this._head(socketWrapper, message)\n  } else if (message.action === C.ACTIONS.HAS) {\n    /*\n     * Return a Boolean to indicate if record exists in cache or database\n     */\n    this._hasRecord(socketWrapper, message)\n  } else if (message.action === C.ACTIONS.UPDATE || message.action === C.ACTIONS.PATCH) {\n    /*\n     * Handle complete (UPDATE) or partial (PATCH) updates\n     */\n    this._update(socketWrapper, message)\n  } else if (message.action === C.ACTIONS.DELETE) {\n    /*\n     * Deletes the record\n     */\n    this._delete(socketWrapper, message)\n  } else if (message.action === C.ACTIONS.UNSUBSCRIBE) {\n  /*\n   * Unsubscribes (discards) a record that was previously subscribed to\n   * using read()\n   */\n    this._subscriptionRegistry.unsubscribe(message.data[0], socketWrapper)\n  } else if (message.action === C.ACTIONS.LISTEN ||\n  /*\n   * Listen to requests for a particular record or records\n   * whose names match a pattern\n   */\n    message.action === C.ACTIONS.UNLISTEN ||\n    message.action === C.ACTIONS.LISTEN_ACCEPT ||\n    message.action === C.ACTIONS.LISTEN_REJECT ||\n    message.action === C.ACTIONS.LISTEN_SNAPSHOT) {\n    this._listenerRegistry.handle(socketWrapper, message)\n  } else {\n  /*\n   * Default for invalid messages\n   */\n    this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.UNKNOWN_ACTION, message.action)\n\n    if (socketWrapper !== C.SOURCE_MESSAGE_CONNECTOR) {\n      socketWrapper.sendError(C.TOPIC.RECORD, C.EVENT.UNKNOWN_ACTION, `unknown action ${message.action}`)\n    }\n  }\n}\n\n/**\n * Tries to retrieve the record from the cache or storage. If not found in either\n * returns false, otherwise returns true.\n *\n * @param   {SocketWrapper} socketWrapper the socket that send the request\n * @param   {Object} message parsed and validated message\n *\n * @private\n * @returns {void}\n */\nRecordHandler.prototype._hasRecord = function (socketWrapper, message) {\n  const recordName = message.data[0]\n\n  const onComplete = function (record) {\n    const hasRecord = record ? C.TYPES.TRUE : C.TYPES.FALSE\n    socketWrapper.sendMessage(C.TOPIC.RECORD, C.ACTIONS.HAS, [recordName, hasRecord])\n  }\n  const onError = function (error) {\n    socketWrapper.sendError(C.TOPIC.RECORD, C.ACTIONS.HAS, [recordName, error])\n  }\n\n  // eslint-disable-next-line\n  new RecordRequest(recordName,\n    this._options,\n    socketWrapper,\n    onComplete.bind(this),\n    onError.bind(this)\n  )\n}\n\n/**\n * Sends the records data current data once loaded from the cache, and null otherwise\n *\n * @param {SocketWrapper} socketWrapper the socket that send the request\n * @param   {Object} message parsed and validated message\n * @private\n * @returns {void}\n */\nRecordHandler.prototype._snapshot = function (socketWrapper, message) {\n  const recordName = message.data[0]\n\n  const onComplete = function (record) {\n    if (record) {\n      this._sendRecord(recordName, record, socketWrapper)\n    } else {\n      socketWrapper.sendError(\n        C.TOPIC.RECORD,\n        C.ACTIONS.SNAPSHOT,\n        [recordName, C.EVENT.RECORD_NOT_FOUND]\n      )\n    }\n  }\n  const onError = function (error) {\n    socketWrapper.sendError(C.TOPIC.RECORD, C.ACTIONS.SNAPSHOT, [recordName, error])\n  }\n\n  // eslint-disable-next-line\n  new RecordRequest(\n    recordName,\n    this._options,\n    socketWrapper,\n    onComplete.bind(this),\n    onError.bind(this)\n  )\n}\n\n/**\n * Similar to snapshot, but will only return the current version number\n *\n * @param {SocketWrapper} socketWrapper the socket that send the request\n * @param   {Object} message parsed and validated message\n * @private\n * @returns {void}\n */\nRecordHandler.prototype._head = function (socketWrapper, message) {\n  const recordName = message.data[0]\n\n  const onComplete = function (record) {\n    if (record) {\n      socketWrapper.sendMessage(C.TOPIC.RECORD, C.ACTIONS.HEAD, [recordName, record._v])\n    } else {\n      socketWrapper.sendError(\n        C.TOPIC.RECORD,\n        C.ACTIONS.HEAD,\n        [recordName, C.EVENT.RECORD_NOT_FOUND]\n      )\n    }\n  }\n  const onError = function (error) {\n    socketWrapper.sendError(C.TOPIC.RECORD, C.ACTIONS.HEAD, [recordName, error])\n  }\n\n  // eslint-disable-next-line\n  new RecordRequest(\n    recordName,\n    this._options,\n    socketWrapper,\n    onComplete.bind(this),\n    onError.bind(this)\n  )\n}\n\n\n/**\n * Tries to retrieve the record and creates it if it doesn't exist. Please\n * note that create also triggers a read once done\n *\n * @param   {SocketWrapper} socketWrapper the socket that send the request\n * @param   {Object} message parsed and validated message\n *\n * @private\n * @returns {void}\n */\nRecordHandler.prototype._createOrRead = function (socketWrapper, message) {\n  const recordName = message.data[0]\n\n  const onComplete = function (record) {\n    if (record) {\n      this._read(recordName, record, socketWrapper)\n    } else {\n      this._permissionAction(\n        C.ACTIONS.CREATE,\n        recordName,\n        socketWrapper,\n        this._create.bind(this, recordName, socketWrapper)\n      )\n    }\n  }\n\n  // eslint-disable-next-line\n  new RecordRequest(\n    recordName,\n    this._options,\n    socketWrapper,\n    onComplete.bind(this)\n  )\n}\n\n/**\n * Creates a new, empty record and triggers a read operation once done\n *\n * @param   {SocketWrapper} socketWrapper the socket that send the request\n * @param   {Object} message parsed and validated message\n *\n * @private\n * @returns {void}\n */\nRecordHandler.prototype._create = function (recordName, socketWrapper) {\n  const record = {\n    _v: 0,\n    _d: {}\n  }\n\n  // store the records data in the cache and wait for the result\n  this._options.cache.set(recordName, record, (error) => {\n    if (error) {\n      this._options.logger.log(C.LOG_LEVEL.ERROR, C.EVENT.RECORD_CREATE_ERROR, recordName)\n      socketWrapper.sendError(C.TOPIC.RECORD, C.EVENT.RECORD_CREATE_ERROR, recordName)\n    } else {\n      this._read(recordName, record, socketWrapper)\n    }\n  })\n\n  if (!this._options.storageExclusion || !this._options.storageExclusion.test(recordName)) {\n    // store the record data in the persistant storage independently and don't wait for the result\n    this._options.storage.set(recordName, record, (error) => {\n      if (error) {\n        this._options.logger.log(C.LOG_LEVEL.ERROR, C.EVENT.RECORD_CREATE_ERROR, `storage:${error}`)\n      }\n    })\n  }\n}\n\n/**\n * Subscribes to updates for a record and sends its current data once done\n *\n * @param {String} recordName\n * @param {Object} record\n * @param {SocketWrapper} socketWrapper the socket that send the request\n *\n * @private\n * @returns {void}\n */\nRecordHandler.prototype._read = function (recordName, record, socketWrapper) {\n  this._permissionAction(C.ACTIONS.READ, recordName, socketWrapper, () => {\n    this._subscriptionRegistry.subscribe(recordName, socketWrapper)\n    this._sendRecord(recordName, record, socketWrapper)\n  })\n}\n\n/**\n * Sends the records data current data once done\n *\n * @param {String} recordName\n * @param {Object} record\n * @param {SocketWrapper} socketWrapper the socket that send the request\n *\n * @private\n * @returns {void}\n */\nRecordHandler.prototype._sendRecord = function (recordName, record, socketWrapper) {\n  socketWrapper.sendMessage(C.TOPIC.RECORD, C.ACTIONS.READ, [recordName, record._v, record._d])\n}\n\n /**\n * Applies both full and partial updates. Creates a new record transition that will live as\n * long as updates are in flight and new updates come in\n *\n * @param   {SocketWrapper} socketWrapper the socket that send the request\n * @param   {Object} message parsed and validated message\n *\n * @private\n * @returns {void}\n */\nRecordHandler.prototype._update = function (socketWrapper, message) {\n  if (message.data.length < 3) {\n    socketWrapper.sendError(C.TOPIC.RECORD, C.EVENT.INVALID_MESSAGE_DATA, message.data[0])\n    return\n  }\n\n  const recordName = message.data[0]\n  const version = parseInt(message.data[1], 10)\n\n  /*\n   * If the update message is received from the message bus, rather than from a client,\n   * assume that the original deepstream node has already updated the record in cache and\n   * storage and only broadcast the message to subscribers\n   */\n  if (socketWrapper === C.SOURCE_MESSAGE_CONNECTOR) {\n    this._$broadcastUpdate(recordName, message, false, socketWrapper)\n    return\n  }\n\n  if (isNaN(version)) {\n    socketWrapper.sendError(C.TOPIC.RECORD, C.EVENT.INVALID_VERSION, [recordName, version])\n    return\n  }\n\n  if (this._transitions[recordName] && this._transitions[recordName].hasVersion(version)) {\n    this._transitions[recordName].sendVersionExists({ message, version, sender: socketWrapper })\n    return\n  }\n\n  if (!this._transitions[recordName]) {\n    this._transitions[recordName] = new RecordTransition(recordName, this._options, this)\n  }\n\n  this._transitions[recordName].add(socketWrapper, version, message)\n}\n\n/**\n * Invoked by RecordTransition. Notifies local subscribers and other deepstream\n * instances of record updates\n *\n * @param   {String} name           record name\n * @param   {Object} message        parsed and validated deepstream message\n * @param   {Boolean} noDelay       Flag as to wether event allows delay\n * @param   {SocketWrapper} originalSender the socket the update message was received from\n *\n * @package private\n * @returns {void}\n */\nRecordHandler.prototype._$broadcastUpdate = function (name, message, noDelay, originalSender) {\n  this._subscriptionRegistry.sendToSubscribers(name, message.raw, noDelay, originalSender)\n\n  if (originalSender !== C.SOURCE_MESSAGE_CONNECTOR) {\n    this._options.messageConnector.publish(C.TOPIC.RECORD, message)\n  }\n}\n\n/**\n * Called by a RecordTransition, either if it is complete or if an error occured. Removes\n * the transition from the registry\n *\n * @todo  refactor - this is a bit of a mess\n * @param   {String} recordName record name\n *\n * @package private\n * @returns {void}\n */\nRecordHandler.prototype._$transitionComplete = function (recordName) {\n  delete this._transitions[recordName]\n}\n\n/**\n * Executes or schedules a callback function once all transitions are complete\n *\n * This is called from the PermissionHandler destroy method, which\n * could occur in cases where 'runWhenRecordStable' is never called,\n * such as when no cross referencing or data loading is used.\n *\n * @param   {String}   recordName the name of the record\n *\n * @private\n * @returns {void}\n */\nRecordHandler.prototype.removeRecordRequest = function (recordName) {\n  if (!this._recordRequestsInProgress[recordName]) {\n    return\n  }\n\n  if (this._recordRequestsInProgress[recordName].length === 0) {\n    delete this._recordRequestsInProgress[recordName]\n    return\n  }\n\n  const callback = this._recordRequestsInProgress[recordName].splice(0, 1)[0]\n  callback(recordName)\n}\n\n/**\n * Executes or schedules a callback function once all record requests are removed.\n * This is critical to block reads until writes have occured for a record, which is\n * only from permissions when a rule is required to be run and the cache has not\n * verified it has the latest version\n *\n * @param   {String}   recordName the name of the record\n * @param   {Function} callback   function to be executed once all writes to this record\n *                                are complete\n *\n * @public\n * @returns {void}\n */\nRecordHandler.prototype.runWhenRecordStable = function (recordName, callback) {\n  if (\n    !this._recordRequestsInProgress[recordName] ||\n    this._recordRequestsInProgress[recordName].length === 0\n  ) {\n    this._recordRequestsInProgress[recordName] = []\n    callback(recordName)\n  } else {\n    this._recordRequestsInProgress[recordName].push(callback)\n  }\n}\n\n/**\n * Deletes a record. If a transition is in progress it will be stopped. Once the\n * deletion is complete, an Ack is returned.\n *\n * If the deletion message is received from the message bus, rather than from a client,\n * we assume that the original deepstream node has already deleted the record from cache and\n * storage and we only need to broadcast the message to subscribers\n *\n * @param   {SocketWrapper} socketWrapper the socket that send the request\n * @param   {Object} message parsed and validated message\n *\n * @private\n * @returns {void}\n */\nRecordHandler.prototype._delete = function (socketWrapper, message) {\n  const recordName = message.data[0]\n\n  if (this._transitions[recordName]) {\n    this._transitions[recordName].destroy()\n    delete this._transitions[recordName]\n  }\n\n  if (socketWrapper === C.SOURCE_MESSAGE_CONNECTOR) {\n    this._onDeleted(recordName, message, socketWrapper)\n  } else {\n    // eslint-disable-next-line\n    new RecordDeletion(this._options, socketWrapper, message, this._onDeleted.bind(this))\n  }\n}\n\n/*\n * Callback for completed deletions. Notifies subscribers of the delete and unsubscribes them\n *\n * @param   {String} name           record name\n * @param   {Object} message        parsed and validated deepstream message\n * @param   {SocketWrapper} originalSender the socket the update message was received from\n *\n * @package private\n * @returns {void}\n */\nRecordHandler.prototype._onDeleted = function (name, message, originalSender) {\n  this._$broadcastUpdate(name, message, true, originalSender)\n\n  for (const subscriber of this._subscriptionRegistry.getLocalSubscribers(name)) {\n    this._subscriptionRegistry.unsubscribe(name, subscriber, true)\n  }\n}\n\n/**\n * A secondary permissioning step that is performed once we know if the record exists (READ)\n * or if it should be created (CREATE)\n *\n * @param   {String} action          One of C.ACTIONS, either C.ACTIONS.READ or C.ACTIONS.CREATE\n * @param   {String} recordName      The name of the record\n * @param   {SocketWrapper} socketWrapper the socket that send the request\n * @param   {Function} successCallback A callback that will only be invoked if the operation was\n *                                     successful\n *\n * @private\n * @returns {void}\n */\nRecordHandler.prototype._permissionAction = function (\n  action, recordName, socketWrapper, successCallback\n  ) {\n  const message = {\n    topic: C.TOPIC.RECORD,\n    action,\n    data: [recordName]\n  }\n\n  const onResult = function (error, canPerformAction) {\n    if (error !== null) {\n      socketWrapper.sendError(message.topic, C.EVENT.MESSAGE_PERMISSION_ERROR, error.toString())\n    } else if (canPerformAction !== true) {\n      socketWrapper.sendError(message.topic, C.EVENT.MESSAGE_DENIED, [recordName, action])\n    } else {\n      successCallback()\n    }\n  }\n\n  this._options.permissionHandler.canPerformAction(\n    socketWrapper.user,\n    message,\n    onResult,\n    socketWrapper.authData\n  )\n}\n\nmodule.exports = RecordHandler\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/record/record-request.js":"'use strict'\n\nconst C = require('../constants/constants')\n\n/**\n * This class retrieves a single record from the cache or - if it isn't in the\n * cache - from storage. If it isn't there either it will notify its initiator\n * by passing null to onComplete (but not call onError).\n *\n * It also handles all the timeout and destruction steps around this operation\n *\n * @param {String} recordName       the unique name of the record\n * @param {Object} options        deepstream options\n * @param {SocketWrapper} socketWrapper the sender whos message initiated the recordRequest\n * @param {Function} onComplete       callback for successful requests\n *                                      (even if the record wasn't found)\n * @param {[Function]} onError          callback for errors\n *\n * @constructor\n */\nconst RecordRequest = function (recordName, options, socketWrapper, onComplete, onError) {\n  this._recordName = recordName\n  this._options = options\n  this._socketWrapper = socketWrapper\n  this._storageRetrievalTimeout = null\n  this._onComplete = onComplete\n  this._onError = onError\n  this._isDestroyed = false\n\n  this._cacheRetrievalTimeout = setTimeout(\n    this._sendError.bind(this, C.EVENT.CACHE_RETRIEVAL_TIMEOUT, this._recordName),\n    this._options.cacheRetrievalTimeout\n  )\n\n  this._options.cache.get(this._recordName, this._onCacheResponse.bind(this))\n}\n\n/**\n * Callback for responses returned by the cache connector\n *\n * @param   {String} error  null if no error has occured\n * @param   {Object} record the record data structure, e.g. { _v: 33, _d: { some: 'data' } }\n *\n * @private\n * @returns {void}\n */\nRecordRequest.prototype._onCacheResponse = function (error, record) {\n  clearTimeout(this._cacheRetrievalTimeout)\n\n  if (this._isDestroyed === true) {\n    return\n  }\n\n  if (error) {\n    this._sendError(C.EVENT.RECORD_LOAD_ERROR, `error while loading ${this._recordName} from cache:${error.toString()}`)\n  } else if (record) {\n    this._onComplete(record)\n  } else if (\n      !this._options.storageExclusion ||\n      !this._options.storageExclusion.test(this._recordName)\n    ) {\n    this._storageRetrievalTimeout = setTimeout(\n      this._sendError.bind(this, C.EVENT.STORAGE_RETRIEVAL_TIMEOUT, this._recordName),\n      this._options.storageRetrievalTimeout\n    )\n    this._options.storage.get(this._recordName, this._onStorageResponse.bind(this))\n  } else {\n    this._onComplete(null)\n  }\n}\n\n/**\n * Callback for responses returned by the storage connector. The request will complete or error\n * here, if the record couldn't be found in storage no further attempts to retrieve it will be made\n *\n * @param   {String} error  null if no error has occured\n * @param   {Object} record the record data structure, e.g. { _v: 33, _d: { some: 'data' } }\n *\n * @private\n * @returns {void}\n */\nRecordRequest.prototype._onStorageResponse = function (error, record) {\n  clearTimeout(this._storageRetrievalTimeout)\n\n  if (this._isDestroyed === true) {\n    return\n  }\n\n  if (error) {\n    this._sendError(\n      C.EVENT.RECORD_LOAD_ERROR,\n      `error while loading ${this._recordName} from storage:${error.toString()}`\n    )\n  } else {\n    this._onComplete(record || null)\n\n    if (record) {\n      /*\n       * Load record from storage into cache\n       */\n      this._options.cache.set(this._recordName, record, () => {})\n    }\n\n    this._destroy()\n  }\n}\n\n/**\n * Sends an error to the socketWrapper that requested the\n * record\n *\n * @param   {String} event      Error event\n * @param   {String} message    Error message\n *\n * @private\n * @returns {void}\n */\nRecordRequest.prototype._sendError = function (event, message) {\n  this._options.logger.log(C.LOG_LEVEL.ERROR, event, message)\n  if (this._socketWrapper) {\n    this._socketWrapper.sendError(C.TOPIC.RECORD, event, message)\n  }\n  if (this._onError) {\n    this._onError(event, message)\n  }\n  this._destroy()\n}\n\n/**\n * Destroys the record request. Clears down all references and stops\n * all pending timeouts\n *\n * @private\n * @returns {void}\n */\nRecordRequest.prototype._destroy = function () {\n  clearTimeout(this._cacheRetrievalTimeout)\n  clearTimeout(this._storageRetrievalTimeout)\n  this._recordName = null\n  this._options = null\n  this._socketWrapper = null\n  this._storageRetrievalTimeout = null\n  this._onComplete = null\n  this._onError = null\n  this._isDestroyed = true\n}\n\nmodule.exports = RecordRequest\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/record/record-transition.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst JsonPath = require('./json-path')\nconst RecordRequest = require('./record-request')\nconst messageParser = require('../message/message-parser')\nconst messageBuilder = require('../message/message-builder')\nconst utils = require('../utils/utils')\n\n/**\n * This class manages one or more simultanious updates to the data of a record.\n * But: Why does that need to be so complicated and why does this class even exist?\n *\n * In short: Cross-network concurrency. If your record is written to by a single datasource\n * and consumed by many clients, this class is admittably overkill, but if deepstream is used to\n * build an app that allows many users to collaboratively edit the same dataset, sooner or later\n * two of them will do so at the same time and clash.\n *\n * Every deepstream record therefor has a version number that's incremented with every change.\n * Every client sends this version number along with the changed data. If no other update has\n * been received for the same version in the meantime, the update is accepted and not much more\n * happens.\n *\n * If, however, another clients was able to send its updated version before this update was\n * processed, the second (later) update for the same version number is rejected and the issuing\n * client is notified of the change.\n *\n * The client is then expected to merge its changes on top of the new version and re-issue the\n * update message.\n *\n * Please note: For performance reasons, succesful updates are not explicitly acknowledged.\n *\n * It's this class' responsibility to manage this. It will be created when an update arrives and\n * only exist as long as it takes to apply it and make sure that no subsequent updates for the\n * same version are requested.\n *\n * Once the update is applied it will notify the record-handler to broadcast the\n * update and delete the instance of this class.\n *\n * @param {String} name the name of the record that the transition will be applied to\n * @param {Object} deepstream options\n * @param {RecordHandler} recordHandler the instance of recordHandler that created this transition\n *\n * @constructor\n */\nconst RecordTransition = function (name, options, recordHandler) {\n  this._name = name\n  this._options = options\n  this._recordHandler = recordHandler\n  this._steps = []\n  this._record = null\n  this._currentStep = null\n  this._recordRequest = null\n  this._sendVersionExists = []\n  this.isDestroyed = false\n  this._pendingUpdates = {}\n  this._ending = false\n  this._storageResponses = 0\n  this._cacheResponses = 0\n  this._lastVersion = null\n  this._lastError = null\n}\n\n/**\n * Checks if a specific version number is already processed or\n * queued for processing\n *\n * @param   {Number}  version\n *\n * @returns {Boolean} hasVersion\n */\nRecordTransition.prototype.hasVersion = function (version) {\n  return version !== -1 && version <= this._lastVersion\n}\n\n/**\n * Send version exists error if the record has been already loaded, else\n * store the version exists error to send to the sockerWrapper once the\n * record is loaded\n *\n * @param   {SocketWrapper} socketWrapper the sender\n * @param   {Number} version The version number\n *\n * @public\n */\nRecordTransition.prototype.sendVersionExists = function (step) {\n  const socketWrapper = step.sender\n  const version = step.version\n  const config = step.message.data[4]\n\n  if (this._record) {\n    const data = config === undefined\n    ? [this._name, this._record._v, JSON.stringify(this._record._d)]\n    : [this._name, this._record._v, JSON.stringify(this._record._d), config]\n    socketWrapper.sendError(C.TOPIC.RECORD, C.EVENT.VERSION_EXISTS, data)\n\n    const msg = `${socketWrapper.user} tried to update record ${this._name} to version ${version} but it already was ${this._record._v}`\n    this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.VERSION_EXISTS, msg)\n  } else {\n    this._sendVersionExists.push({\n      version,\n      sender: socketWrapper,\n      config,\n      message: step.message\n    })\n  }\n}\n\n/**\n * Adds a new step (either an update or a patch) to the record. The step\n * will be queued or executed immediatly if the queue is empty\n *\n * This method will also retrieve the current record's data when called\n * for the first time\n *\n * @param {SocketWrapper} socketWrapper that send the message\n * @param {Number} version the expected version that this update will apply\n * @param {Object} message parsed deepstream message. Data will still be stringified JSON\n *\n * @public\n * @returns {void}\n */\nRecordTransition.prototype.add = function (socketWrapper, version, message) {\n  const update = {\n    message,\n    version,\n    upsert: false,\n    sender: socketWrapper\n  }\n  let data\n\n  try {\n    const config = RecordTransition._getRecordConfig(message)\n    this._applyConfig(config, update)\n  } catch (e) {\n    update.sender.sendError(\n      C.TOPIC.RECORD,\n      C.EVENT.INVALID_CONFIG_DATA,\n      message.data[4] || message.data[3]\n    )\n    return\n  }\n\n  if (message.action === C.ACTIONS.UPDATE) {\n    if (message.data.length !== 4 && message.data.length !== 3) {\n      socketWrapper.sendError(C.TOPIC.RECORD, C.EVENT.INVALID_MESSAGE_DATA, message.raw)\n      return\n    }\n\n    try {\n      data = JSON.parse(message.data[2])\n    } catch (e) {\n      socketWrapper.sendError(C.TOPIC.RECORD, C.EVENT.INVALID_MESSAGE_DATA, message.raw)\n      return\n    }\n\n    if (!utils.isOfType(data, 'object') && !utils.isOfType(data, 'array')) {\n      socketWrapper.sendError(C.TOPIC.RECORD, C.EVENT.INVALID_MESSAGE_DATA, message.raw)\n      return\n    }\n\n    update.isPatch = false\n    update.data = data\n  }\n\n  if (message.action === C.ACTIONS.PATCH) {\n    if (message.data.length !== 5 && message.data.length !== 4) {\n      socketWrapper.sendError(C.TOPIC.RECORD, C.EVENT.INVALID_MESSAGE_DATA, message.raw)\n      return\n    }\n\n    update.isPatch = true\n    update.data = messageParser.convertTyped(message.data[3])\n\n    if (update.data instanceof Error) {\n      socketWrapper.sendError(C.TOPIC.RECORD, C.EVENT.INVALID_MESSAGE_DATA, `${update.data.toString()}:${message.data[3]}`)\n      return\n    }\n\n    update.path = message.data[2]\n  }\n\n  if (this._lastVersion !== null && this._lastVersion !== version - 1) {\n    this.sendVersionExists(update)\n    return\n  }\n\n  if (version !== -1) {\n    this._lastVersion = version\n  }\n  this._cacheResponses++\n  this._steps.push(update)\n\n  if (this._recordRequest === null) {\n    this._recordRequest = new RecordRequest(\n      this._name,\n      this._options,\n      socketWrapper,\n      this._onRecord.bind(this, update),\n      this._onFatalError.bind(this)\n    )\n  } else if (this._steps.length === 1 && this._cacheResponses === 1) {\n    this._next()\n  }\n}\n\n/**\n * Destroys the instance\n *\n * @private\n * @returns {void}\n */\nRecordTransition.prototype.destroy = function (errorMessage) {\n  if (this.isDestroyed) {\n    return\n  }\n\n  this._sendWriteAcknowledgements(errorMessage || this._writeError)\n  this._recordHandler._$transitionComplete(this._name)\n  this.isDestroyed = true\n  this._options = null\n  this._name = null\n  this._record = null\n  this._recordHandler = null\n  this._steps = null\n  this._currentStep = null\n  this._recordRequest = null\n  this._pendingUpdates = null\n  this._lastVersion = null\n  this._cacheResponses = 0\n  this._storageResponses = 0\n}\n\n/**\n * Tries to apply config given from a socketWrapper on an\n * incoming message\n *\n * @param {Object} step the current step of the transition\n * @param {String} message\n *\n * @private\n * @returns {void}\n */\nRecordTransition.prototype._applyConfig = function (config, step) {\n  if (!config) {\n    return\n  }\n\n  if (config.writeSuccess) {\n    if (this._pendingUpdates[step.sender.uuid] === undefined) {\n      this._pendingUpdates[step.sender.uuid] = {\n        socketWrapper: step.sender,\n        versions: [step.version]\n      }\n    } else {\n      const update = this._pendingUpdates[step.sender.uuid]\n      update.versions.push(step.version)\n    }\n  }\n\n  if (config.upsert) {\n    step.upsert = true\n  }\n}\n\n/**\n * Gets the config from an incoming Record message\n *\n * @param   {String} message\n *\n * @private\n * @throws {SyntaxError } If config not valid\n * @returns null or the given config\n */\nRecordTransition._getRecordConfig = function (message) {\n  let config\n  if (message.action === C.ACTIONS.PATCH && message.data.length === 5) {\n    config = message.data[4]\n  } else if (message.action === C.ACTIONS.UPDATE && message.data.length === 4) {\n    config = message.data[3]\n  }\n\n  if (!config) {\n    return null\n  }\n\n  return JSON.parse(config)\n}\n\n/**\n * Callback for successfully retrieved records\n *\n * @param   {Object} record\n *\n * @private\n * @returns {void}\n */\nRecordTransition.prototype._onRecord = function (step, record) {\n  if (record === null && !step.upsert) {\n    this._onFatalError(`Received update for non-existant record ${this._name}`)\n  } else if (record === null && step.upsert) {\n    const emptyRecord = {\n      _v: 0,\n      _d: {}\n    }\n\n    this._recordHandler._permissionAction(\n      C.ACTIONS.CREATE,\n      this._name,\n      step.sender,\n      this._processRecord.bind(this, emptyRecord)\n    )\n  } else {\n    this._processRecord(record)\n  }\n}\n\n/**\n * Callback used to process next update after record successfully returned or permissiom\n * check passed\n *\n * @param   {Object} record\n *\n * @private\n * @returns {void}\n */\nRecordTransition.prototype._processRecord = function (record) {\n  this._record = record\n  this._flushVersionExists()\n  this._next()\n}\n\n\n/**\n * Once the record is loaded this method is called recoursively\n * for every step in the queue of pending updates.\n *\n * It will apply every patch or update and - once done - either\n * call itself to process the next one or destroy the RecordTransition\n * of the queue has been drained\n *\n * @private\n * @returns {void}\n */\nRecordTransition.prototype._next = function () {\n  if (this.isDestroyed === true) {\n    return\n  }\n\n  if (this._steps.length === 0) {\n    if (this._cacheResponses === 0 && this._storageResponses === 0) {\n      this.destroy()\n    }\n    return\n  }\n\n  this._currentStep = this._steps.shift()\n  if (this._currentStep.version === -1) {\n    const message = this._currentStep.message\n    const version = this._record._v + 1\n    this._currentStep.version = message.data[1] = version\n    // Raw message is rebroadcast, needs to be rebuilt with new version number\n    message.raw = messageBuilder.getMsg(message.topic, message.action, message.data)\n  }\n\n  if (this._record._v !== this._currentStep.version - 1) {\n    this._cacheResponses--\n    this.sendVersionExists(this._currentStep)\n    this._next()\n    return\n  }\n\n  this._record._v = this._currentStep.version\n\n  if (this._currentStep.isPatch) {\n    (new JsonPath(this._currentStep.path)).setValue(this._record._d, this._currentStep.data)\n  } else {\n    this._record._d = this._currentStep.data\n  }\n\n  /*\n   * Please note: saving to storage is called first to allow for synchronous cache\n   * responses to destroy the transition, it is however not on the critical path\n   * and the transition will continue straight away, rather than wait for the storage response\n   * to be returned.\n   *\n   * If the storage response is asynchronous and write acknowledgement is enabled, the transition\n   * will not be destroyed until writing to storage is finished\n   */\n  if (!this._options.storageExclusion || !this._options.storageExclusion.test(this._name)) {\n    this._storageResponses++\n    this._options.storage.set(\n      this._name,\n      this._record,\n      this._onStorageResponse.bind(this, this._currentStep)\n    )\n  }\n  this._options.cache.set(\n    this._name,\n    this._record,\n    this._onCacheResponse.bind(this, this._currentStep)\n  )\n}\n\n/**\n * Send all the stored version exists errors once the record has been loaded.\n *\n * @private\n */\nRecordTransition.prototype._flushVersionExists = function () {\n  for (let i = 0; i < this._sendVersionExists.length; i++) {\n    const conflict = this._sendVersionExists[i]\n    this.sendVersionExists(conflict)\n  }\n  this._sendVersionExists = []\n}\n\n/**\n * Callback for responses returned by cache.set(). If an error\n * is returned the queue will be destroyed, otherwise\n * the update will be broadcast to other subscribers and the\n * next step invoked\n *\n * @param   {String} error\n *\n * @private\n * @returns {void}\n */\nRecordTransition.prototype._onCacheResponse = function (currentStep, error) {\n  this._cacheResponses--\n  this._writeError = this._writeError || error\n  if (error) {\n    this._onFatalError(error)\n  } else if (this.isDestroyed === false) {\n    this._recordHandler._$broadcastUpdate(\n      this._name,\n      this._currentStep.message,\n      false,\n      this._currentStep.sender\n    )\n    this._next()\n  } else if (\n      this._cacheResponses === 0 &&\n      this._storageResponses === 0 &&\n      this._steps.length === 0\n    ) {\n    this.destroy()\n  }\n}\n\n/**\n * Callback for responses returned by storage.set()\n *\n * @param   {String} error\n *\n * @private\n * @returns {void}\n */\nRecordTransition.prototype._onStorageResponse = function (currentStep, error) {\n  this._storageResponses--\n  this._writeError = this._writeError || error\n  if (error) {\n    this._onFatalError(error)\n  } else if (\n      this._cacheResponses === 0 &&\n      this._storageResponses === 0 &&\n      this._steps.length === 0\n    ) {\n    this.destroy()\n  }\n}\n\n/**\n * Sends all write acknowledgement messages at the end of a transition\n *\n * @param   {String} error any error message that occurred while storing the\n *                         record data\n *\n * @private\n * @returns {void}\n */\nRecordTransition.prototype._sendWriteAcknowledgements = function (errorMessage) {\n  errorMessage = errorMessage === undefined ? null : errorMessage // eslint-disable-line\n  for (const uid in this._pendingUpdates) {\n    const update = this._pendingUpdates[uid]\n\n    update.socketWrapper.sendMessage(C.TOPIC.RECORD, C.ACTIONS.WRITE_ACKNOWLEDGEMENT, [\n      this._name,\n      update.versions,\n      messageBuilder.typed(errorMessage)\n    ])\n  }\n}\n\n/**\n * Generic error callback. Will destroy the queue and notify the senders of all pending\n * transitions\n *\n * @param   {String} errorMessage\n *\n * @private\n * @returns {void}\n */\nRecordTransition.prototype._onFatalError = function (errorMessage) {\n  if (this.isDestroyed === true) {\n    /* istanbul ignore next */\n    return\n  }\n  this._options.logger.log(C.LOG_LEVEL.ERROR, C.EVENT.RECORD_UPDATE_ERROR, errorMessage)\n\n  for (let i = 0; i < this._steps.length; i++) {\n    if (this._steps[i].sender !== C.SOURCE_MESSAGE_CONNECTOR) {\n      this._steps[i].sender.sendError(\n        C.TOPIC.RECORD,\n        C.EVENT.RECORD_UPDATE_ERROR,\n        this._steps[i].version\n      )\n    }\n  }\n\n  if (this._cacheResponses === 0 && this._storageResponses === 0) {\n    this.destroy(errorMessage)\n  }\n}\n\nmodule.exports = RecordTransition\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/record/json-path.js":"'use strict'\n/* eslint-disable no-param-reassign */\nconst SPLIT_REG_EXP = /[.[\\]]/g\n\n/**\n * This class allows to set or get specific\n * values within a json data structure using\n * string-based paths\n *\n * @param {String} path A path, e.g. users[2].firstname\n *\n * @constructor\n */\nconst JsonPath = function (path) {\n  this._path = path\n  this._tokens = []\n  this._tokenize()\n}\n\n/**\n * Sets the value of the path. If the path (or parts\n * of it) doesn't exist yet, it will be created\n *\n * @param {Object} node\n * @param {Mixed} value\n *\n * @public\n * @returns {void}\n */\nJsonPath.prototype.setValue = function (node, value) {\n  let i = 0\n\n  for (i = 0; i < this._tokens.length - 1; i++) {\n    if (node[this._tokens[i]] !== undefined) {\n      node = node[this._tokens[i]]\n    } else if (this._tokens[i + 1] && !isNaN(this._tokens[i + 1])) {\n      node = node[this._tokens[i]] = []\n    } else {\n      node = node[this._tokens[i]] = {}\n    }\n  }\n\n  node[this._tokens[i]] = value\n}\n\n/**\n * Parses the path. Splits it into\n * keys for objects and indices for arrays.\n *\n * @private\n * @returns {void}\n */\nJsonPath.prototype._tokenize = function () {\n  const parts = this._path.split(SPLIT_REG_EXP)\n  let part\n  let i\n\n  for (i = 0; i < parts.length; i++) {\n    part = parts[i].trim()\n\n    if (part.length === 0) {\n      continue\n    }\n\n    if (!isNaN(part)) {\n      this._tokens.push(parseInt(part, 10))\n      continue\n    }\n\n    this._tokens.push(part)\n  }\n}\n\nmodule.exports = JsonPath\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/record/record-deletion.js":"'use strict'\n\nconst messageBuilder = require('../message/message-builder')\nconst C = require('../constants/constants')\n\n/**\n * This class represents the deletion of a single record. It handles it's removal\n * from cache and storage and handles errors and timeouts\n *\n * @param {Object}      options           deepstream options\n * @param {SocketWrapper}   socketWrapper     the sender of the delete message\n * @param {Object}      message           parsed and validated deletion message\n * @param {Function}    successCallback   callback for succesful deletions\n *\n * @constructor\n */\nconst RecordDeletion = function (options, socketWrapper, message, successCallback) {\n  this._options = options\n  this._socketWrapper = socketWrapper\n  this._message = message\n  this._successCallback = successCallback\n  this._recordName = message.data[0]\n  this._completed = 0\n  this._isDestroyed = false\n\n  this._cacheTimeout = setTimeout(\n    this._handleError.bind(this, 'cache timeout'),\n    this._options.cacheRetrievalTimeout\n  )\n  this._options.cache.delete(\n    this._recordName,\n    this._checkIfDone.bind(this, this._cacheTimeout)\n  )\n\n  if (!this._options.storageExclusion || !this._options.storageExclusion.test(this._recordName)) {\n    this._storageTimeout = setTimeout(\n      this._handleError.bind(this, 'storage timeout'),\n      this._options.storageRetrievalTimeout\n    )\n    this._options.storage.delete(\n      this._recordName,\n      this._checkIfDone.bind(this, this._storageTimeout)\n    )\n  } else {\n    this._checkIfDone(null)\n  }\n}\n\n/**\n * Callback for completed cache and storage interactions. Will invoke\n * _done() once both are completed\n *\n * @param   {String} error     Error message or null\n * @param   {Number} timeoutId The id of the timeout that was associated with the request\n *\n * @returns {void}\n */\nRecordDeletion.prototype._checkIfDone = function (timeoutId, error) {\n  clearTimeout(timeoutId)\n  this._completed++\n\n  if (this._isDestroyed) {\n    return\n  }\n\n  if (error) {\n    this._handleError(error.toString())\n    return\n  }\n\n  if (this._completed === 2) {\n    this._done()\n  }\n}\n\n/**\n * Callback for successful deletions. Notifies the original sender and calls\n * the callback to allow the recordHandler to broadcast the deletion\n *\n * @private\n * @returns {void}\n */\nRecordDeletion.prototype._done = function () {\n  this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.RECORD_DELETION, this._recordName)\n\n  const ackMessage = {\n    topic: C.TOPIC.RECORD,\n    action: C.ACTIONS.ACK,\n    data: [C.ACTIONS.DELETE, this._recordName],\n    raw: messageBuilder.getMsg(C.TOPIC.RECORD, C.ACTIONS.ACK, [C.ACTIONS.DELETE, this._recordName])\n  }\n\n  this._socketWrapper.send(ackMessage.raw)\n  this._successCallback(this._recordName, ackMessage, this._socketWrapper)\n  this._destroy()\n}\n\n/**\n * Destroyes the class and null down its dependencies\n *\n * @private\n * @returns {void}\n */\nRecordDeletion.prototype._destroy = function () {\n  clearTimeout(this._cacheTimeout)\n  clearTimeout(this._storageTimeout)\n  this._options = null\n  this._socketWrapper = null\n  this._message = null\n  this._isDestroyed = true\n}\n\n/**\n * Handle errors that occured during deleting the record\n *\n * @param   {String} errorMsg\n *\n * @private\n * @returns {void}\n */\nRecordDeletion.prototype._handleError = function (errorMsg) {\n  this._socketWrapper.sendError(C.TOPIC.RECORD, C.EVENT.RECORD_DELETE_ERROR, errorMsg)\n  this._options.logger.log(C.LOG_LEVEL.ERROR, C.EVENT.RECORD_DELETE_ERROR, errorMsg)\n  this._destroy()\n}\n\nmodule.exports = RecordDeletion\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/presence/presence-handler.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst SubscriptionRegistry = require('../utils/subscription-registry')\nconst DistributedStateRegistry = require('../cluster/distributed-state-registry')\nconst messageBuilder = require('../message/message-builder')\n\n/**\n * This class handles incoming and outgoing messages in relation\n * to deepstream presence. It provides a way to inform clients\n * who else is logged into deepstream\n *\n * @param {Object} options    deepstream options\n * @param {Connection} connection\n * @param {Client} client\n * @public\n * @constructor\n */\nmodule.exports = class PresenceHandler {\n\n  constructor (options) {\n    this._options = options\n    this._localClients = new Map()\n    this._connectionEndpoint = options.connectionEndpoint\n    this._connectionEndpoint.on('client-connected', this._handleJoin.bind(this))\n    this._connectionEndpoint.on('client-disconnected', this._handleLeave.bind(this))\n\n    this._presenceRegistry = new SubscriptionRegistry(options, C.TOPIC.PRESENCE)\n\n    this._connectedClients = new DistributedStateRegistry(C.TOPIC.ONLINE_USERS, options)\n    this._connectedClients.on('add', this._onClientAdded.bind(this))\n    this._connectedClients.on('remove', this._onClientRemoved.bind(this))\n  }\n\n  /**\n  * The main entry point to the presence handler class.\n  *\n  * Handles subscriptions, unsubscriptions and queries\n  *\n  * @param   {SocketWrapper} socketWrapper the socket that send the request\n  * @param   {Object} message parsed and validated message\n  *\n  * @public\n  * @returns {void}\n  */\n  handle (socketWrapper, message) {\n    if (message.action === C.ACTIONS.SUBSCRIBE) {\n      this._presenceRegistry.subscribe(C.TOPIC.PRESENCE, socketWrapper)\n    } else if (message.action === C.ACTIONS.UNSUBSCRIBE) {\n      this._presenceRegistry.unsubscribe(C.TOPIC.PRESENCE, socketWrapper)\n    } else if (message.action === C.ACTIONS.QUERY) {\n      this._handleQuery(socketWrapper)\n    } else {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.UNKNOWN_ACTION, message.action)\n\n      if (socketWrapper !== C.SOURCE_MESSAGE_CONNECTOR) {\n        socketWrapper.sendError(C.TOPIC.EVENT, C.EVENT.UNKNOWN_ACTION, `unknown action ${message.action}`)\n      }\n    }\n  }\n\n  /**\n  * Called whenever a client has succesfully logged in with a username\n  *\n  * @param   {Object} socketWrapper the socketWrapper of the client that logged in\n  *\n  * @private\n  * @returns {void}\n  */\n  _handleJoin (socketWrapper) {\n    let currentCount = this._localClients.get(socketWrapper.user)\n    if (currentCount === undefined) {\n      this._localClients.set(socketWrapper.user, 1)\n      this._connectedClients.add(socketWrapper.user)\n    } else {\n      currentCount++\n      this._localClients.set(socketWrapper.user, currentCount)\n    }\n  }\n\n  /**\n  * Called whenever a client has disconnected\n  *\n  * @param   {Object} socketWrapper the socketWrapper of the client that disconnected\n  *\n  * @private\n  * @returns {void}\n  */\n  _handleLeave (socketWrapper) {\n    let currentCount = this._localClients.get(socketWrapper.user)\n    if (currentCount === 1) {\n      this._localClients.delete(socketWrapper.user)\n      this._connectedClients.remove(socketWrapper.user)\n    } else {\n      currentCount--\n      this._localClients.set(socketWrapper.user, currentCount)\n    }\n  }\n\n  /**\n  * Handles finding clients who are connected and splicing out the client\n  * querying for users\n  *\n  * @param   {Object} socketWrapper the socketWrapper of the client that is querying\n  *\n  * @private\n  * @returns {void}\n  */\n  _handleQuery (socketWrapper) {\n    const clients = this._connectedClients.getAll()\n    const index = clients.indexOf(socketWrapper.user)\n    if (index !== -1) {\n      clients.splice(index, 1)\n    }\n    socketWrapper.sendMessage(C.TOPIC.PRESENCE, C.ACTIONS.QUERY, clients)\n  }\n\n  /**\n  * Alerts all clients who are subscribed to\n  * PRESENCE_JOIN that a new client has been added.\n  *\n  * @param   {String} username the username of the client that joined\n  *\n  * @private\n  * @returns {void}\n  */\n  _onClientAdded (username) {\n    const addMsg = messageBuilder.getMsg(C.TOPIC.PRESENCE, C.ACTIONS.PRESENCE_JOIN, [username])\n    this._presenceRegistry.sendToSubscribers(C.TOPIC.PRESENCE, addMsg)\n  }\n\n  /**\n  * Alerts all clients who are subscribed to\n  * PRESENCE_LEAVE that the client has left.\n  *\n  * @param   {String} username the username of the client that left\n  *\n  * @private\n  * @returns {void}\n  */\n  _onClientRemoved (username) {\n    const removeMsg = messageBuilder.getMsg(C.TOPIC.PRESENCE, C.ACTIONS.PRESENCE_LEAVE, [username])\n    this._presenceRegistry.sendToSubscribers(C.TOPIC.PRESENCE, removeMsg)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/utils/dependency-initialiser.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst utils = require('util')\n\nconst EventEmitter = require('events').EventEmitter\n\n/**\n * This class is used to track the initialisation of\n * an individual dependency (cache connector, persistance connector,\n * message connector, logger)\n *\n * @param {Object} options deepstream options\n * @param {String} name    the key of the dependency within the options\n *\n * @constructor\n */\nconst DependencyInitialiser = function (options, name) {\n  this.isReady = false\n\n  this._options = options\n  this._dependency = options[name]\n  this._name = name\n  this._timeout = null\n\n  if (typeof this._dependency.on !== 'function' && typeof this._dependency.isReady === 'undefined') {\n    const errorMessage = `${this._name} needs to implement isReady or be an emitter`\n    this._options.logger.log(C.LOG_LEVEL.ERROR, C.EVENT.PLUGIN_INITIALIZATION_ERROR, errorMessage)\n    const error = new Error(errorMessage)\n    error.code = 'PLUGIN_INITIALIZATION_ERROR'\n    throw error\n  }\n\n  if (this._dependency.isReady) {\n    this._onReady()\n  } else {\n    this._timeout = setTimeout(\n      this._onTimeout.bind(this),\n      this._options.dependencyInitialisationTimeout\n    )\n    this._dependency.once('ready', this._onReady.bind(this))\n    this._dependency.on('error', this._onError.bind(this))\n\n    if (this._dependency.init) {\n      this._dependency.init()\n    }\n  }\n}\n\nutils.inherits(DependencyInitialiser, EventEmitter)\n\n/**\n * Returns the underlying dependency (e.g. the Logger, StorageConnector etc.)\n *\n * @public\n * @returns {Dependency}\n */\nDependencyInitialiser.prototype.getDependency = function () {\n  return this._dependency\n}\n\n/**\n * Callback for succesfully initialised dependencies\n *\n * @private\n * @returns {void}\n */\nDependencyInitialiser.prototype._onReady = function () {\n  if (this._timeout) {\n    clearTimeout(this._timeout)\n  }\n\n  const dependencyType = this._dependency.type ? `: ${this._dependency.type}` : ''\n  this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.INFO, `${this._name} ready${dependencyType}`)\n  process.nextTick(this._emitReady.bind(this))\n}\n\n/**\n * Callback for dependencies that weren't initialised in time\n *\n * @private\n * @returns {void}\n */\nDependencyInitialiser.prototype._onTimeout = function () {\n  const message = `${this._name} wasn't initialised in time`\n  this._logError(message)\n  const error = new Error(message)\n  error.code = C.EVENT.PLUGIN_INITIALIZATION_TIMEOUT\n  throw error\n}\n\n/**\n* Handles errors emitted by the dependency at startup.\n*\n* Plugin errors that occur at runtime are handled by the deepstream.io main class\n*\n* @param {Error|String} error\n*\n* @private\n* @returns {void}\n*/\nDependencyInitialiser.prototype._onError = function (error) {\n  if (this.isReady !== true) {\n    this._logError(`Error while initialising ${this._name}: ${error.toString()}`)\n    error.code = C.EVENT.PLUGIN_INITIALIZATION_ERROR\n    throw error\n  }\n}\n\n/**\n * Emits the ready event after a one tick delay\n *\n * @private\n * @returns {void}\n */\nDependencyInitialiser.prototype._emitReady = function () {\n  this.isReady = true\n  this.emit('ready')\n}\n\n/**\n * Logs error messages\n *\n * Since the logger is a dependency in its own right, it can't be relied upon\n * here. If it is available, it will be used, otherwise the error will be logged\n * straight to the console\n *\n * @param   {String} message the error message\n *\n * @private\n * @returns {void}\n */\nDependencyInitialiser.prototype._logError = function (message) {\n  if (this._options.logger && this._options.logger.isReady) {\n    this._options.logger.log(C.LOG_LEVEL.ERROR, C.EVENT.PLUGIN_ERROR, message)\n  } else {\n    console.error('Error while initialising dependency')\n    console.error(message)\n  }\n}\n\nmodule.exports = DependencyInitialiser\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/cluster/cluster-registry.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst EventEmitter = require('events').EventEmitter\n\n/**\n * This class maintains a list of all nodes that are\n * currently present within the cluster.\n *\n * It provides status messages on a predefined interval\n * and keeps track of incoming status messages.\n *\n * @emits add <serverName>\n * @emits remove <serverName>\n */\nmodule.exports = class ClusterRegistry extends EventEmitter {\n  /**\n   * Creates the class, initialises all intervals and publishes the\n   * initial status message that notifies other nodes within this\n   * cluster of its presence.\n   *\n   * @param   {Object} options            deepstream options\n   * @param   {ConnectionEndpoint}    connectionEndpoint deepstream connection endpoint\n   *\n   * @constructor\n   */\n  constructor (options, connectionEndpoint) {\n    super()\n    this._options = options\n    this._connectionEndpoint = connectionEndpoint\n    this._inCluster = false\n    this._nodes = {}\n\n    this._leaderScore = Math.random()\n    this.setMaxListeners(12)\n\n    this._onMessageFn = this._onMessage.bind(this)\n    this._leaveClusterFn = this.leaveCluster.bind(this)\n    this._options.messageConnector.subscribe(C.TOPIC.CLUSTER, this._onMessageFn)\n    this._publishStatus()\n    this._publishInterval = setInterval(\n      this._publishStatus.bind(this),\n      this._options.clusterKeepAliveInterval\n    )\n    this._checkInterval = setInterval(\n      this._checkNodes.bind(this),\n      this._options.clusterActiveCheckInterval\n    )\n    process.on('beforeExit', this._leaveClusterFn)\n    process.on('exit', this._leaveClusterFn)\n  }\n\n  /**\n   * Prompts this node to leave the cluster, either as a result of a server.close()\n   * call or due to the process exiting.\n   * This sends out a leave message to all other nodes and destroys this class.\n   *\n   * @public\n   * @returns {[type]}\n   */\n  leaveCluster () {\n    if (this._inCluster === false) {\n      return\n    }\n    this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.CLUSTER_LEAVE, this._options.serverName)\n    this._options.messageConnector.publish(C.TOPIC.CLUSTER, {\n      topic: C.TOPIC.CLUSTER,\n      action: C.ACTIONS.REMOVE,\n      data: [this._options.serverName]\n    })\n\n    // TODO: If a message connector doesn't close this is required to avoid an error\n    // being thrown during shutdown\n    // this._options.messageConnector.unsubscribe( C.TOPIC.CLUSTER, this._onMessageFn );\n\n    process.removeListener('beforeExit', this._leaveClusterFn)\n    process.removeListener('exit', this._leaveClusterFn)\n    clearInterval(this._publishInterval)\n    clearInterval(this._checkInterval)\n    this._nodes = {}\n    this._inCluster = false\n  }\n\n  /**\n   * Returns the serverNames of all nodes currently present within the cluster\n   *\n   * @public\n   * @returns {Array} serverNames\n   */\n  getAll () {\n    return Object.keys(this._nodes)\n  }\n\n  /**\n   * Returns true if this node is the cluster leader\n   * @return {Boolean} [description]\n   */\n  isLeader () {\n    return this._options.serverName === this.getCurrentLeader()\n  }\n\n  /**\n  * Returns the name of the current leader\n  * @return {String}\n  */\n  getCurrentLeader () {\n    let maxScore = 0\n    let serverName\n    let leader = null\n\n    for (serverName in this._nodes) {\n      if (this._nodes[serverName].leaderScore > maxScore) {\n        maxScore = this._nodes[serverName].leaderScore\n        leader = serverName\n      }\n    }\n\n    return leader\n  }\n\n  /**\n   * Returns the public url of the least utilized node within the cluster.\n   *\n   * @todo this currently only takes memory usage into account, but ignores the\n   *       amount of connections. Improve?\n   *\n   * @public\n   * @returns {String} public URL\n   */\n  getLeastUtilizedExternalUrl () {\n    let minMemory = Infinity\n    let serverName\n    let minNode\n\n    for (serverName in this._nodes) {\n      if (this._nodes[serverName].memory < minMemory) {\n        minMemory = this._nodes[serverName].memory\n        minNode = this._nodes[serverName]\n      }\n    }\n\n    return minNode.externalUrl\n  }\n\n  /**\n   * Distributes incoming messages on the cluster topic\n   *\n   * @param   {Object} message parsed deepstream message object\n   *\n   * @private\n   * @returns {void}\n   */\n  _onMessage (message) {\n    const data = message.data[0]\n\n    if (!data) {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.INVALID_MESSAGE_DATA, message.data)\n    } else if (message.action === C.ACTIONS.STATUS) {\n      this._updateNode(data)\n    } else if (message.action === C.ACTIONS.REMOVE) {\n      this._removeNode(data)\n    } else {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.UNKNOWN_ACTION, message.action)\n    }\n  }\n\n  /**\n   * Called on an interval defined by clusterActiveCheckInterval to check if all nodes\n   * within the cluster are still alive.\n   *\n   * Being alive is defined as having received a status message from that node less than\n   * <clusterNodeInactiveTimeout> milliseconds ago.\n   *\n   * @private\n   * @returns {void}\n   */\n  _checkNodes () {\n    const now = Date.now()\n    let serverName\n\n    for (serverName in this._nodes) {\n      if (now - this._nodes[serverName].lastStatusTime > this._options.clusterNodeInactiveTimeout) {\n        this._removeNode(serverName)\n      }\n    }\n  }\n\n  /**\n   * Updates the status of a node with incoming status data and resets its lastStatusTime.\n   *\n   * If the remote node doesn't exist yet, it is added and an add event is emitted / logged\n   *\n   * @param   {Object} data node status data as generated by _publishStatus\n   *\n   * @private\n   * @returns {void}\n   */\n  _updateNode (data) {\n    const isNew = !this._nodes[data.serverName]\n    this._nodes[data.serverName] = data\n    this._nodes[data.serverName].lastStatusTime = Date.now()\n    if (isNew) {\n      this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.CLUSTER_JOIN, data.serverName)\n      this.emit('add', data.serverName)\n    }\n  }\n\n  /**\n   * Removes a remote node from this registry if it exists.\n   *\n   * Logs/emits remove\n   *\n   * @param   {String} serverName\n   *\n   * @private\n   * @returns {void}\n   */\n  _removeNode (serverName) {\n    if (this._nodes[serverName]) {\n      delete this._nodes[serverName]\n      this._options.logger.log(C.LOG_LEVEL.INFO, C.EVENT.CLUSTER_LEAVE, serverName)\n      this.emit('remove', serverName)\n    }\n  }\n\n  /**\n   * Publishes this node's status on the message bus\n   *\n   * @private\n   * @returns {void}\n   */\n  _publishStatus () {\n    this._inCluster = true\n    const memoryStats = process.memoryUsage()\n\n    const data = {\n      serverName: this._options.serverName,\n      connections: this._connectionEndpoint.getConnectionCount(),\n      memory: memoryStats.heapUsed / memoryStats.heapTotal,\n      leaderScore: this._leaderScore,\n      externalUrl: this._options.externalUrl\n    }\n\n    this._updateNode(data)\n\n    this._options.messageConnector.publish(C.TOPIC.CLUSTER, {\n      topic: C.TOPIC.CLUSTER,\n      action: C.ACTIONS.STATUS,\n      data: [data]\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/cluster/cluster-unique-state-provider.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst utils = require('../utils/utils')\nconst EventEmitter = require('events').EventEmitter\n\nconst SUPPORTED_ACTIONS = {}\nSUPPORTED_ACTIONS[C.ACTIONS.LOCK_RESPONSE] = true\nSUPPORTED_ACTIONS[C.ACTIONS.LOCK_REQUEST] = true\nSUPPORTED_ACTIONS[C.ACTIONS.LOCK_RELEASE] = true\n\n/**\n * The unique registry is responsible for maintaing a single source of truth\n * within the cluster, used mainly for issuing cluster wide locks when an operation\n * that stretches over multiple nodes are required.\n *\n * For example, distributed listening requires a leader to drive the nodes in sequence,\n * so issuing a lock prevents multiple nodes from assuming the lead.\n *\n */\nmodule.exports = class UniqueRegistry {\n  /**\n  * The unique registry is a singleton and is only created once\n  * within deepstream.io. It is passed via\n  * via the options object.\n  *\n  * @param  {Object} options                     The options deepstream was created with\n  * @param  {ClusterRegistry} clusterRegistry    The cluster registry, used to get the\n  *                                              cluster leader\n  *\n  * @constructor\n  */\n  constructor (options, clusterRegistry) {\n    this._options = options\n    this._clusterRegistry = clusterRegistry\n    this._locks = {}\n    this._timeouts = {}\n    this._responseEventEmitter = new EventEmitter()\n    this._onPrivateMessageFn = this._onPrivateMessage.bind(this)\n    this._localTopic = this._getPrivateTopic(this._options.serverName)\n    this._options.messageConnector.subscribe(this._localTopic, this._onPrivateMessageFn)\n  }\n\n  /**\n  * Requests a lock, if the leader ( whether local or distributed ) has the lock availble\n  * it will invoke the callback with true, otherwise false.\n  *\n  * @param  {String}   name     the lock name that is desired\n  * @param  {Function} callback the callback to be told if the lock has been reserved succesfully\n  *\n  * @public\n  * @returns {void}\n  */\n  get (name, callback) {\n    const leaderServerName = this._clusterRegistry.getCurrentLeader()\n\n    if (this._options.serverName === leaderServerName) {\n      callback(this._getLock(name))\n    } else if (!this._timeouts[name]) {\n      this._getRemoteLock(name, leaderServerName, callback)\n    } else {\n      callback(false)\n    }\n  }\n\n  /**\n  * Release a lock, allowing other resources to request it again\n  *\n  * @param  {String}   name     the lock name that is desired\n  *\n  * @public\n  * @returns {void}\n  */\n  release (name) {\n    const leaderServerName = this._clusterRegistry.getCurrentLeader()\n\n    if (this._options.serverName === leaderServerName) {\n      this._releaseLock(name)\n    } else {\n      this._releaseRemoteLock(name, leaderServerName)\n    }\n  }\n\n  /**\n  * Called when the current node is not the leader, issuing a lock request\n  * via the message bus\n  *\n  * @param  {String}   name             The lock name\n  * @param  {String}   leaderServerName The leader of the cluster\n  * @param  {Function} callback         The callback to invoke once a response\n  *                                     from the server is retrieved\n  * @private\n  * @returns {void}\n  */\n  _getRemoteLock (name, leaderServerName, callback) {\n    this._timeouts[name] = utils.setTimeout(\n            this._onLockRequestTimeout.bind(this, name),\n            this._options.lockRequestTimeout\n        )\n\n    this._responseEventEmitter.once(name, callback)\n\n    const remoteTopic = this._getPrivateTopic(leaderServerName)\n\n    this._options.messageConnector.publish(remoteTopic, {\n      topic: remoteTopic,\n      action: C.ACTIONS.LOCK_REQUEST,\n      data: [{\n        name,\n        responseTopic: this._localTopic\n      }]\n    })\n  }\n\n  /**\n  * Notifies a remote leader keeping a lock that said lock is no longer required\n  *\n  * @param  {String}   name             The lock name\n  * @param  {String}   leaderServerName The leader of the cluster\n  *\n  * @private\n  * @returns {void}\n  */\n  _releaseRemoteLock (name, leaderServerName) {\n    const remoteTopic = this._getPrivateTopic(leaderServerName)\n\n    this._options.messageConnector.publish(remoteTopic, {\n      topic: remoteTopic,\n      action: C.ACTIONS.LOCK_RELEASE,\n      data: [{\n        name\n      }]\n    })\n  }\n\n  /**\n  * Called when a message is recieved on the message bus.\n  * This could mean the leader responded to a request or that you're currently\n  * the leader and recieved a request.\n  *\n  * @param  {Object} message Object from message bus\n  *\n  * @private\n  * @returns {void}\n  */\n  _onPrivateMessage (message) {\n    if (!SUPPORTED_ACTIONS[message.action]) {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.UNKNOWN_ACTION, message.action)\n      return\n    }\n\n    if (!message.data || !message.data[0]) {\n      this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.INVALID_MESSAGE_DATA, message.data)\n      return\n    }\n\n    if (message.action === C.ACTIONS.LOCK_RESPONSE) {\n      this._handleRemoteLockResponse(message.data[0])\n      return\n    }\n\n    if (this._clusterRegistry.isLeader() === false) {\n      let remoteServerName = 'unknown-server'\n      if (message.data[0].responseTopic) {\n        remoteServerName = message.data[0].responseTopic.replace(C.TOPIC.LEADER_PRIVATE, '')\n      }\n\n      this._options.logger.log(\n                C.LOG_LEVEL.WARN,\n                C.EVENT.INVALID_LEADER_REQUEST,\n                `server ${remoteServerName} assumes this node '${this._options.serverName}' is the leader`\n            )\n\n      return\n    }\n\n    if (message.action === C.ACTIONS.LOCK_REQUEST) {\n      this._handleRemoteLockRequest(message.data[0])\n    } else if (message.action === C.ACTIONS.LOCK_RELEASE) {\n      this._handleRemoteLockRelease(message.data[0])\n    }\n  }\n\n  /**\n  * Called when a remote lock request is received\n  *\n  * @param  {Object} data messageData\n  *\n  * @private\n  * @returns {void}\n  */\n  _handleRemoteLockRequest (data) {\n    this._options.messageConnector.publish(data.responseTopic, {\n      topic: data.responseTopic,\n      action: C.ACTIONS.LOCK_RESPONSE,\n      data: [{\n        name: data.name,\n        result: this._getLock(data.name)\n      }]\n    })\n  }\n\n  /**\n  * Called when a remote lock response is received\n  *\n  * @param  {Object} data messageData\n  *\n  * @private\n  * @returns {void}\n  */\n  _handleRemoteLockResponse (data) {\n    clearTimeout(this._timeouts[data.name])\n    delete this._timeouts[data.name]\n    this._responseEventEmitter.emit(data.name, data.result)\n  }\n\n  /**\n  * Called when a remote node notifies the cluster that a lock has been removed\n  *\n  * @param  {Object} data messageData\n  *\n  * @private\n  * @returns {void}\n  */\n  _handleRemoteLockRelease (data) {\n    clearTimeout(this._timeouts[data.name])\n    delete this._timeouts[data.name]\n    delete this._locks[data.name]\n  }\n\n  /**\n  * Generates a private topic to allow routing requests directly\n  * to this node\n  *\n  * @param  {String} serverName The server of this server\n  *\n  * @private\n  * @returns {String} privateTopic\n  */\n  _getPrivateTopic (serverName) { // eslint-disable-line\n    return C.TOPIC.LEADER_PRIVATE + serverName\n  }\n\n  /**\n  * Returns true if reserving lock was possible otherwise returns false\n  *\n  * @param  {String}   name     Name of lock\n  *\n  * @private\n  * @return {boolean}\n  */\n  _getLock (name) {\n    if (this._locks[name] === true) {\n      return false\n    }\n\n    this._timeouts[name] = utils.setTimeout(\n      this._onLockTimeout.bind(this, name),\n      this._options.lockTimeout\n    )\n    this._locks[name] = true\n    return true\n  }\n\n  /**\n  * Called when a lock is no longer required and can be released. This is triggered either by\n  * a timeout if a remote release message wasn't received in time or when release was called\n  * locally.\n  *\n  * Important note: Anyone can release a lock. It is assumed that the cluster is trusted\n  * so maintaining who has the lock is not required. This may need to change going forward.\n  *\n  * @param  {String} name Lock name\n  *\n  * @private\n  * @returns {void}\n  */\n  _releaseLock (name) {\n    clearTimeout(this._timeouts[name])\n    delete this._timeouts[name]\n    delete this._locks[name]\n  }\n\n  /**\n  * Called when a timeout occurs on a lock that has been reserved for too long\n  *\n  * @param  {String} name The lock name\n  *\n  * @private\n  * @returns {void}\n  */\n  _onLockTimeout (name) {\n    this._releaseLock(name)\n    this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.TIMEOUT, `lock ${name} released due to timeout`)\n  }\n\n  /**\n  * Called when a remote request has timed out, resulting in notifying the client that\n  * the lock wasn't able to be reserved\n  *\n  * @param  {String} name The lock name\n  *\n  * @private\n  * @returns {void}\n  */\n  _onLockRequestTimeout (name) {\n    this._handleRemoteLockResponse({ name, result: false })\n    this._options.logger.log(C.LOG_LEVEL.WARN, C.EVENT.TIMEOUT, `request for lock ${name} timed out`)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/jasmine-runner.js":"var Jasmine = require( 'jasmine' );\nvar SpecReporter = require( 'jasmine-spec-reporter' );\nvar noop = function() {};\n\nvar jrunner = new Jasmine();\nvar jasmine = global.jasmine;\njrunner.configureDefaultReporter( {print: noop} );    // remove default reporter logs\njasmine.getEnv().addReporter( new SpecReporter() );   // add jasmine-spec-reporter\njrunner.loadConfigFile( './jasmine.json' );           // load jasmine.json configuration\njrunner.execute();\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/bin/deepstream-hash.js":"'use strict'\n\nconst FileAuthenticationHandler = require('../src/authentication/file-based-authentication-handler')\nconst jsYamlLoader = require('../src/config/js-yaml-loader')\n\nmodule.exports = function (program) {\n  program\n\t\t.command('hash [password]')\n\t\t.description('Generate a hash from a plaintext password using file auth configuration settings')\n\t\t.option('-c, --config [file]', 'configuration file containing file auth and hash settings')\n\t\t.action(hash)\n}\n\nfunction hash(password) {\n  global.deepstreamCLI = this\n  const config = jsYamlLoader.loadConfigWithoutInitialisation().config\n\n  if (config.auth.type !== 'file') {\n    console.error('Error: Can only use hash with file authentication as auth type')\n    process.exit(1)\n  }\n\n  if (!config.auth.options.hash) {\n    console.error('Error: Can only use hash with file authentication')\n    process.exit(1)\n  }\n\n  config.auth.options.path = ''\n\n  if (!password) {\n    console.error('Error: Must provide password to hash')\n    process.exit(1)\n  }\n\n\t// Mock file loading since a users.yml file is not required\n  jsYamlLoader.readAndParseFile = function () {}\n\n  const fileAuthenticationHandler = new FileAuthenticationHandler(config.auth.options)\n  fileAuthenticationHandler.createHash(password, (err, hash) => {\n    if (err) {\n      console.error('Hash could not be created', err)\n      process.exit(1)\n    }\n    console.log('Password hash:', hash)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/authentication/file-based-authentication-handler.js":"'use strict'\n/* eslint-disable valid-typeof */\n\nconst crypto = require('crypto')\nconst jsYamlLoader = require('../config/js-yaml-loader')\nconst utils = require('../utils/utils')\nconst EventEmitter = require('events').EventEmitter\n\nconst STRING = 'string'\nconst STRING_CHARSET = 'base64'\n\n/**\n * This authentication handler reads a list of users and their associated password (either\n * hashed or in cleartext ) from a json file. This can be useful to authenticate smaller amounts\n * of clients with static credentials, e.g. backend provider that write to publicly readable records\n *\n * @public\n * @extends {EventEmitter}\n */\nmodule.exports = class FileBasedAuthenticationHandler extends EventEmitter {\n  /**\n  * Creates the class, reads and validates the users.json file\n  *\n  * @param   {Object} settings\n  * @param   {String} settings.path path to the user file\n  * @param   {String} settings.hash the name of a HMAC digest algorithm, a.g. 'sha512'\n  * @param   {Int} settings.iterations the amount of times the algorithm should be applied\n  * @param   {Int} settings.keyLength the length of the resulting key\n  *\n  * @constructor\n  * @returns {void}\n  */\n  constructor (settings) {\n    super()\n    this.isReady = false\n    this.type = `file using ${settings.path}`\n    this._validateSettings(settings)\n    this._settings = settings\n    this._base64KeyLength = 4 * Math.ceil(this._settings.keyLength / 3)\n    jsYamlLoader.readAndParseFile(settings.path, this._onFileLoad.bind(this))\n  }\n\n  /**\n  * Main interface. Authenticates incoming connections\n  *\n  * @param   {Object}   connectionData\n  * @param   {Object}   authData\n  * @param   {Function} callback\n  *\n  * @public\n  * @implements {PermissionHandler.isValidUser}\n  * @returns {void}\n  */\n  isValidUser (connectionData, authData, callback) {\n    if (typeof authData.username !== STRING) {\n      callback(false, { clientData: 'missing authentication parameter username' })\n      return\n    }\n\n    if (typeof authData.password !== STRING) {\n      callback(false, { clientData: 'missing authentication parameter password' })\n      return\n    }\n\n    const userData = this._data[authData.username]\n\n    if (!userData) {\n      callback(false)\n      return\n    }\n\n    if (this._settings.hash) {\n      this._isValid(\n        authData.password,\n        userData.password,\n        authData.username,\n        userData.serverData,\n        userData.clientData,\n        callback\n      )\n    } else if (authData.password === userData.password) {\n      callback(true, {\n        username: authData.username,\n        serverData: typeof userData.serverData === 'undefined' ? null : userData.serverData,\n        clientData: typeof userData.clientData === 'undefined' ? null : userData.clientData\n      })\n    } else {\n      callback(false)\n    }\n  }\n\n  /**\n  * Utility method for creating hashes including salts based on\n  * the provided parameters\n  *\n  * @todo  this needs to be exposed to users, maybe via CLI?\n  *\n  * @param   {String}   password the password that should be hashed\n  * @param   {Function} callback will be invoked with error, hash once hashing is completed\n  *\n  * @public\n  * @returns {void}\n  */\n  createHash (password, callback) {\n    const salt = crypto.randomBytes(16).toString(STRING_CHARSET)\n\n    crypto.pbkdf2(\n            password,\n            salt,\n            this._settings.iterations,\n            this._settings.keyLength,\n            this._settings.hash,\n            (err, hash) => {\n              callback(err || null, hash.toString(STRING_CHARSET) + salt)\n            }\n        )\n  }\n\n  /**\n  * Callback for loaded JSON files. Makes sure that\n  * no errors occured and every user has an associated password\n  *\n  * @param   {Error}     error an error that occured during loading or parsing the file\n  * @param   {Object}    data  parsed contents of the file\n  *\n  * @private\n  * @returns {void}\n  */\n  _onFileLoad (error, data) {\n    if (error) {\n      this.emit('error', `Error loading file ${this._settings.path}: ${error.toString()}`)\n      return\n    }\n\n    this._data = data\n\n    if (Object.keys(data).length === 0) {\n      this.emit('error', 'no users present in user file')\n      return\n    }\n\n    for (const username in this._data) {\n      if (typeof this._data[username].password !== STRING) {\n        this.emit('error', `missing password for ${username}`)\n      }\n    }\n\n    this.isReady = true\n    this.emit('ready')\n  }\n\n  /**\n  * Called initially to validate the user provided settings\n  *\n  * @param   {Object} settings\n  *\n  * @private\n  * @returns {void}\n  */\n  _validateSettings (settings) { // eslint-disable-line\n    if (!settings.hash) {\n      utils.validateMap(settings, true, {\n        path: 'string'\n      })\n      return\n    }\n\n    utils.validateMap(settings, true, {\n      path: 'string',\n      hash: 'string',\n      iterations: 'number',\n      keyLength: 'number'\n    })\n\n    if (crypto.getHashes().indexOf(settings.hash) === -1) {\n      throw new Error(`Unknown Hash ${settings.hash}`)\n    }\n  }\n\n  /**\n  * Extracts hash and salt from a string and runs a hasing function\n  * against it\n  *\n  * @param   {String}   password             the cleartext password the user provided\n  * @param   {String}   passwordHashWithSalt the hash+salt combination from the users.json file\n  * @param   {String}   username             as provided by user\n  * @param   {Object}   serverData           arbitrary authentication data that will be passed on\n  *                                          to the permission handler\n  * @param   {Object}   clientData           arbitrary authentication data that will be passed on\n  *                                          to the client\n  * @param   {Function} callback             callback that will be invoked once hash is created\n  *\n  * @private\n  * @returns {void}\n  */\n  _isValid (password, passwordHashWithSalt, username, serverData, clientData, callback) {\n    const expectedHash = passwordHashWithSalt.substr(0, this._base64KeyLength)\n    const salt = passwordHashWithSalt.substr(this._base64KeyLength)\n\n    crypto.pbkdf2(\n      password,\n      salt,\n      this._settings.iterations,\n      this._settings.keyLength,\n      this._settings.hash,\n      this._compareHashResult.bind(this, expectedHash, username, serverData, clientData, callback)\n    )\n  }\n\n  /**\n  * Callback once hashing is completed\n  *\n  * @param   {String}   expectedHash     has as retrieved from users.json\n  * @param   {Object}   serverData       arbitrary authentication data that will be passed on to the\n  *                                      permission handler\n  * @param   {Object}   clientData       arbitrary authentication data that will be passed on to the\n  *                                      client\n  * @param   {Function} callback         callback from isValidUser\n  * @param   {Error}    error            error that occured during hashing\n  * @param   {Buffer}   actualHashBuffer the buffer containing the bytes for the new hash\n  *\n  * @private\n  * @returns {void}\n  */\n  // eslint-disable-next-line\n  _compareHashResult (\n    expectedHash, username, serverData, clientData, callback, error, actualHashBuffer\n  ) {\n    if (expectedHash === actualHashBuffer.toString(STRING_CHARSET)) {\n      // todo log error\n      callback(true, {\n        username,\n        serverData: serverData || null,\n        clientData: clientData || null\n      })\n    } else {\n      callback(false)\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/bin/deepstream-info.js":"'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst glob = require('glob')\nconst jsYamlLoader = require('../src/config/js-yaml-loader')\n\nmodule.exports = function (program) {\n  program\n\t\t.command('info')\n\t\t.description('print meta information about build and runtime')\n\t\t.option('-c, --config [file]', 'configuration file containing lib directory')\n\t\t.option('-l, --lib-dir [directory]', 'directory of libraries')\n\t\t.action(printMeta)\n}\n\nfunction printMeta() {\n  if (!this.libDir) {\n    try {\n      global.deepstreamCLI = this\n      jsYamlLoader.loadConfigWithoutInitialisation()\n      this.libDir = global.deepstreamLibDir\n    } catch (e) {\n      console.log(e)\n      console.error('Please provide a libDir or a configFile to provide the relevant install information')\n      process.exit(1)\n    }\n  }\n\n  let meta\n  try {\n    meta = require('../meta.json')\n  } catch (err) {\n\t\t// if deepstream is not installed as binary (source or npm)\n    pkg = require('../package.json')\n    meta = {\n      deepstreamVersion: pkg.version,\n      ref: pkg.gitHead || pkg._resolved || 'N/A',\n      buildTime: 'N/A'\n    }\n  }\n  meta.platform = os.platform()\n  meta.arch = os.arch()\n  meta.nodeVersion = process.version\n  fetchLibs(this.libDir, meta)\n  console.log(JSON.stringify(meta, null, 2))\n}\n\nfunction fetchLibs(libDir, meta) {\n  const directory = libDir || 'lib'\n  const files = glob.sync(path.join(directory, '*', 'package.json'))\n  meta.libs = files.map((filePath) => {\n    const pkg = fs.readFileSync(filePath, 'utf8')\n    const object = JSON.parse(pkg)\n    return `${object.name}:${object.version}`\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/bin/deepstream-install.js":"'use strict'\n\nconst installer = require('./installer')\nconst jsYamlLoader = require('../src/config/js-yaml-loader')\n\nmodule.exports = function (program) {\n  program\n\t\t.command('install')\n\t\t.description('install connectors')\n\t\t.usage('<type> <name>[:version]')\n\t\t.option('-c, --config [file]', 'configuration file containing the lib directory')\n\t\t.option('-l, --lib-dir [directory]', 'directory where to extract the connector')\n\t\t.option('--verbose', 'more debug output')\n\t\t.option('--quiet', 'no output')\n\t\t.on('--help', () => {\n  console.log('  Examples:')\n  console.log('')\n  console.log('    $ deepstream install cache redis')\n  console.log('    $ deepstream install storage rethinkdb:0.1.0')\n  console.log('')\n  console.log('    list of available connectors: https://deepstream.io/download')\n  console.log('')\n})\n\t\t.action(action)\n}\n\nfunction action(type, nameAndVersion) {\n  const installArgs = Array.prototype.slice.call(arguments, 0, arguments.length - 1)\n  if (installArgs.length < 2) {\n    this.help()\n  }\n\n  if (!this.libDir) {\n    try {\n      global.deepstreamCLI = this\n      jsYamlLoader.loadConfigWithoutInitialisation()\n      this.libDir = global.deepstreamLibDir\n    } catch (e) {\n      console.error('Please provide a libDir or a configFile to provide the relevant install information')\n      process.exit(1)\n    }\n  }\n\n\t/*\n\t * Syntax:\n\t * TYPE NAME:VERSION\n\t * version is optional\n\t */\n  type = installArgs[0]\n  nameAndVersion = installArgs[1].split(':')\n  const name = nameAndVersion[0]\n  const version = nameAndVersion[1]\n\n  if (this.quiet) {\n    process.env.QUIET = 1\n  } else if (this.verbose) {\n    process.env.VERBOSE = 1\n  }\n\n  installer({\n    type,\n    name,\n    version,\n    dir: this.libDir\n  }, (err) => {\n    if (err) {\n      console.error(err.toString().red)\n      process.exit(1)\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/bin/installer.js":"'use strict'\n\nconst colors = require('colors')\nconst needle = require('needle')\nconst fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst AdmZip = require('adm-zip')\nconst execSync = require('child_process').execSync\nconst mkdirp = require('mkdirp')\n\nconst CONFIG_EXAMPLE_FILE = 'example-config.yml'\nconst SYSTEM = {\n  linux: 'linux',\n  darwin: 'mac',\n  win32: 'windows'\n}\nconst platform = SYSTEM[os.platform()]\n\nconst getWebUrl = function (repo) {\n  return `https://github.com/deepstreamIO/${repo}/releases`\n}\n\n/**\n * Download a release from GitHub releases API with with the deepstream connector\n * name convention: deepstreamIO/deepstream.io-TYPE-NAME\n *\n * @param  {array}    releases JSON array of the GitHub REST API for list releases\n * @param  {string}   type Connector type: {cache|message|storage}\n * @param  {string}   name Name of the connector\n * @param  {string}   version Version of the connector (optional)\n * @param  {string}   outputDir Path to directory where to install and extract the connector\n * @callback callback\n * @param {error} error\n * @param {Object} {{archive: String, name: String, version: String}}\n * @return {void}\n */\nconst downloadRelease = function (releases, type, name, version, outputDir, callback) {\n  outputDir = outputDir == null ? 'lib' : outputDir\n  const repo = `deepstream.io-${type}-${name}`\n  const filteredReleases = releases.filter((item) => {\n    if (version == null) {\n      return true\n    }\n    return item.tag_name === version || item.tag_name === `v${version}`\n  })\n  if (filteredReleases.length === 0) {\n    return callback(new Error(`${repo} ${version} not found, see ${getWebUrl(repo)}`))\n  }\n  const release = filteredReleases[0]\n  version = version == null ? release.tag_name : version\n  const releaseForMachine = release.assets.filter(item => item.name.indexOf(platform) !== -1)\n  if (releaseForMachine.length === 0) {\n    return callback(new Error(`Release for your platform not found, see ${getWebUrl(repo)}`))\n  }\n\n  const downloadUrl = releaseForMachine[0].browser_download_url\n  const extension = path.extname(downloadUrl)\n  const basename = path.basename(downloadUrl, extension).replace('deepstream.io-', '')\n  const urlBase = 'https://github.com'\n  const urlPath = downloadUrl.substr(urlBase.length)\n  const basenameWithVersion = `${basename}-${version}${extension}`\n  const outputFile = path.join(outputDir, basenameWithVersion)\n  mkdirp.sync(outputDir)\n\n  if (process.env.VERBOSE) {\n    console.log(`Downloading version ${version}`)\n  }\n  const outStream = fs.createWriteStream(outputFile)\n  downloadArchive(urlPath, outStream, (err) => {\n    if (err) {\n      return callback(err)\n    }\n    callback(null, {\n      archive: outputFile,\n      name: repo,\n      version\n    })\n  })\n}\n\n/**\n * Downloads an archive usually zip or tar.gz from a URL which comes from the GitHub\n * release API.\n *\n * @param  {String}   urlPath URL where to download the archive\n * @param  {Stream}   writeable output stream to save the archive\n * @param  {Function} callback Callback (err)\n * @return {void}\n */\nconst downloadArchive = function (urlPath, outStream, callback) {\n  needle.get(`https://github.com${urlPath}`, {\n    follow_max: 5,\n    headers: { 'User-Agent': 'nodejs-client' }\n  }, (error, response) => {\n    if (error) {\n      return callback(error)\n    }\n    outStream.write(response.body)\n    outStream.end()\n    if (process.env.VERBOSE) {\n      process.stdout.clearLine()\n      process.stdout.cursorTo(0)\n      process.stdout.write('Download complete' + '\\n')\n    }\n    return callback()\n  })\n}\n\n/**\n * Fetch a JSON array from GitHub Release API which contains all meta data\n * for a specific reposotiry.\n *\n * @param  {String}   type Connector type: {cache|message|storage}\n * @param  {String}   name Name of the connector\n * @callback callback\n * @param {error} error\n * @param {Object} JSON\n * @return {void}\n */\nconst fetchReleases = function (type, name, callback) {\n  const repo = `deepstream.io-${type}-${name}`\n  const urlPath = `/repos/deepstreamIO/${repo}/releases`\n  if (process.env.VERBOSE) {\n    console.log(`searching for ${repo}`)\n  }\n  needle.get(`https://api.github.com${urlPath}`, {\n    headers: { 'User-Agent': 'nodejs-client' },\n  }, (error, response) => {\n    if (error) {\n      return callback(error)\n    }\n    if (response.statusCode === 404) {\n      return callback(new Error('Not found, see available connectors on https://deepstream.io/download'))\n    }\n    if (response.statusCode == 403) {\n\t\t\t// API rate limit\n      return callback(new Error(response.body.message))\n    }\n    callback(null, response.body)\n  })\n}\n\n/**\n * Fetch a JSON array from GitHub Release API which contains all meta data\n * for a specific reposotiry.\n *\n * @param  {Object}   data Contains archive: contains the archive path, name: contains the name of the  connector\n * @param  {String}   platform The current platform (windows, linux or mac)\n * @return {String}   outPath The directory where the connector was extracted to\n */\nconst extract = function (data, platform) {\n  const archivePath = data.archive\n  const outputParent = path.dirname(archivePath)\n  const outPath = path.join(outputParent, data.name)\n  try {\n    if (platform === 'linux') {\n      execSync(`mkdir -p ${outPath} && tar -xzf ${archivePath} -C ${outPath}`)\n    } else {\n      extractZip(archivePath, outPath)\n    }\n  } catch (err) {\n    if (process.env.VERBOSE) {\n      console.error(err)\n    }\n    throw new Error('Could not extract archive')\n  }\n  if (!process.env.QUIET) {\n    console.log(colors.green(`${data.name} ${data.version} was installed to ${outputParent}`))\n  }\n  return outPath\n}\n\n/**\n * Extracts an archive to a specific directory\n *\n * @param  {String}   archivePath\n * @param {String}   outputDirectory\n * @return {void}\n */\nconst extractZip = function (archivePath, outputDirectory) {\n  const zip = new AdmZip(archivePath)\n  zip.extractAllTo(outputDirectory, true)\n}\n\n/**\n * Prints out the config snippet of a extract connector to the stdout.\n * Output is indented and grey colored.\n *\n * @param  {String}   directory where to lookup for CONFIG_EXAMPLE_FILE\n * @return {void}\n */\nconst showConfig = function (directory) {\n  try {\n    const content = fs.readFileSync(path.join(directory, CONFIG_EXAMPLE_FILE), 'utf8')\n    if (process.env.VERBOSE) {\n      console.log('You need to configure the connector in your deepstream configuration file')\n    }\n    if (!process.env.QUIET) {\n      console.log(`Example configuration:\\n${colors.grey(content)}`)\n    }\n  } catch (err) {\n    if (!process.env.QUIET) {\n      console.log('Example configuration not found')\n    }\n  }\n}\n\n/**\n * Download, extract and show configuration for deepstream connector\n *\n * @param  {Object}   opts {{type: String, name: string, version: String, dir: String}}\n * @param  {Function} callback Callback (err)\n * @return {void}\n */\nmodule.exports = function (opts, callback) {\n  if (opts.type === 'message') {\n    opts.type = 'msg'\n  }\n  fetchReleases(opts.type, opts.name, (error, releases) => {\n    if (error) {\n      return callback(error)\n    }\n    downloadRelease(releases, opts.type, opts.name, opts.version, opts.dir, (error, result) => {\n      if (error) {\n        return callback(error)\n      }\n      try {\n        const extractedDirectory = extract(result, platform)\n        showConfig(extractedDirectory)\n        callback()\n      } catch (error) {\n        callback(error)\n      }\n    })\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/bin/deepstream-start.js":"'use strict'\n\nconst colors = require('colors')\nconst fs = require('fs')\nconst os = require('os')\nconst path = require('path')\nconst child_process = require('child_process')\nconst C = require('../src/constants/constants.js')\nconst pidHelper = require('./pid-helper')\n\nmodule.exports = function (program) {\n  program\n\t\t.command('start')\n\t\t.description('start a deepstream server')\n\n\t\t.option('-c, --config [file]', 'configuration file, parent directory will be used as prefix for other config files')\n\t\t.option('-l, --lib-dir [directory]', 'path where to lookup for plugins like connectors and logger')\n\t\t.option('-d, --detach', 'detach the deepstream server process')\n\n\t\t.option('--server-name <name>', 'Each server within a cluster needs a unique name')\n\t\t.option('--host <host>', 'host for the HTTP/websocket server')\n\t\t.option('--port <port>', 'port for the HTTP/websocket server', parseInteger.bind(null, '--port'))\n\t\t.option('--disable-auth', 'Force deepstream to use \"none\" auth type')\n\t\t.option('--disable-permissions', 'Force deepstream to use \"none\" permissions')\n\t\t.option('--log-level <level>', 'Log messages with this level and above', parseLogLevel)\n\t\t.option('--colors [true|false]', 'Enable or disable logging with colors', parseBoolean.bind(null, '--colors'))\n\t\t.action(action)\n}\n\nfunction action() {\n  global.deepstreamCLI = this\n\n  if (this.detach) {\n\t\t// --detach is not supported for windows\n    if (os.platform() === 'win32') {\n      console.error('detached mode not supported on windows')\n      process.exit(1)\n    }\n\t\t// proxy arguments from commander to the spawing process\n    const args = []\n    if (this.config != null) {\n      args.push('--config')\n      args.push(this.config)\n    }\n    if (this.libDir != null) {\n      args.push('--lib-dir')\n      args.push(this.libDir)\n    }\n\t\t// TODO: need to pass other options as well, which are accessable directly as properties of this\n\t\t//       but need to transform camelCase back to kebabCase, like disableAuth\n\n\t\t// ensure there is no pid file with a running process\n    pidHelper.ensureNotRunning((err) => {\n      if (err) {\n        return pidHelper.exit(err)\n      }\n      const child = child_process.spawn(path.join(__dirname, 'deepstream'), ['start'].concat(args), {\n        detached: true,\n        stdio: ['ignore']\n      })\n      const WAIT_FOR_ERRORS = 3000\n\t\t\t// register handler if the child process will fail within WAIT_FOR_ERRORS period\n      child.on('close', detachErrorHandler)\n      child.on('exit', detachErrorHandler)\n      child.unref()\n\t\t\t// wait, maybe ther is an error during startup\n      setTimeout(() => {\n        console.log(`process was detached with pid ${child.pid}`)\n        process.exit(0)\n      }, WAIT_FOR_ERRORS)\n    })\n  } else {\n\t\t// non-detach case\n    const Deepstream = require('../src/deepstream.io.js')\n    try {\n      process.on('uncaughtException', pidHelper.exit)\n      const ds = new Deepstream(null)\n      ds.on('started', () => {\n        pidHelper.save(process.pid)\n      })\n      ds.start()\n    } catch (err) {\n      console.error(err.toString())\n      console.trace()\n      process.exit(1)\n    }\n    process\n\t\t\t.removeAllListeners('SIGINT').on('SIGINT', pidHelper.exit)\n\t\t\t.removeAllListeners('SIGTERM').on('SIGTERM', pidHelper.exit)\n  }\n}\n\nfunction detachErrorHandler() {\n  console.error('Error during detaching the deepstream process, see logs or run without --detach'.red)\n  process.exit(1)\n}\n\n/**\n* Used by commander to parse the log level and and fails if invalid\n* value is passed in\n* @private\n*/\nfunction parseLogLevel(logLevel) {\n  if (!/debug|info|warn|error|off/i.test(logLevel)) {\n    console.error('Log level must be one of the following (debug|info|warn|error|off)')\n    process.exit(1)\n  }\n  return logLevel.toUpperCase()\n}\n\n/**\n* Used by commander to parse numbers and fails if invalid\n* value is passed in\n* @private\n*/\nfunction parseInteger(name, port) {\n  const portNumber = Number(port)\n  if (!portNumber) {\n    console.error(`Provided ${name} must be an integer`)\n    process.exit(1)\n  }\n  return portNumber\n}\n\n/**\n* Used by commander to parse boolean and fails if invalid\n* value is passed in\n* @private\n*/\nfunction parseBoolean(name, enabled) {\n  let isEnabled\n  if (typeof enabled === 'undefined' || enabled === 'true') {\n    isEnabled = true\n  } else if (typeof enabled !== 'undefined' && enabled === 'false') {\n    isEnabled = false\n  } else {\n    console.error(`Invalid argument for ${name}, please provide true or false`)\n    process.exit(1)\n  }\n  return isEnabled\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/bin/pid-helper.js":"'use strict'\n\nconst colors = require('colors')\nconst fs = require('fs')\nconst path = require('path')\nconst os = require('os')\n\nconst DEFAULT_PID_FILE = path.join(os.tmpdir(), 'deepstream.pid')\nconst PID_FILE = process.env.DEEPSTREAM_PID_FILE || DEFAULT_PID_FILE\n\n/**\n * Save a JSON (pid and timestamp) object to the temp directofy of the system\n *\n * @param  {String|Number} pid Connector type: {cache|message|storage}\n * @callback callback\n * @param {error} error\n * @return {void}\n */\nconst save = function (pid, callback) {\n  if (callback == null) {\n    callback = function () {}\n  }\n  if (pid == null) {\n    return callback(new Error('pid is null'))\n  }\n  const now = new Date()\n  const data = {\n    pid,\n    timestamp: now.getTime(),\n    time: now.toString()\n  }\n  fs.writeFile(PID_FILE, JSON.stringify(data), (err) => {\n    callback(err)\n  })\n}\n\n/**\n * Try to read the pid file from the temp directory\n *\n * @callback callback\n * @param {error} error\n * @return {void}\n */\nconst read = function (callback) {\n  fs.readFile(PID_FILE, 'utf8', (err, content) => {\n    if (err) {\n      return callback(err)\n    }\n    try {\n      return callback(null, JSON.parse(content))\n    } catch (err) {\n      return callback(err)\n    }\n  })\n}\n\n/**\n * Ensure that there is no process running with the PID in the pid file,\n * otherwise throw an error.\n *\n * @callback callback\n * @param {error} error\n * @return {void}\n */\nconst ensureNotRunning = function (callback) {\n  read((err, data) => {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        return callback()\n      }\n      return callback(err)\n    }\n    try {\n      const pid = data.pid\n      if (isRunning(pid)) {\n        throw new Error(`A deepstream server is already running with PID ${pid}, see ${PID_FILE}`)\n      } else {\n\t\t\t\t// pid file is there but process is not running anymore\n        return callback()\n      }\n    } catch (err) {\n      return callback(err)\n    }\n  })\n}\n\n/**\n * Exit the current process with a status code 0.\n * If you pass an error as argument, it will exit with 1 and the error will\n * printed to the stderr.\n *\n * @param  {Error} err Optional error object\n * @return {void}\n */\nconst exit = function (err) {\n  if (err instanceof Error) {\n    console.error(colors.red(err.toString()))\n    console.error(err)\n    process.exit(1)\n  } else {\n    remove(() => {\n      process.exit(0)\n    })\n  }\n}\n\n/**\n * Try to find a process with the given pid and returns true if it is running.\n * Otherwise false.\n *\n * @param  {String|Number} pid\n * @return {Boolean}\n */\nconst isRunning = function (pid) {\n  try {\n    return process.kill(pid, 0)\n  } catch (e) {\n    return e.code === 'EPERM'\n  }\n}\n\n/**\n * Delete the pid file\n *\n * @callback callback Optional callback\n * @param {error} error\n * @return {void}\n */\nconst remove = function (callback) {\n  fs.unlink(PID_FILE, (err) => {\n    if (callback != null) {\n      return callback(err)\n    }\n    console.error(err)\n  })\n}\n\n/**\n * Try to find a process from the pid file and kills it.\n * Prints out if a process or pid file was found or not for how long it was running.\n *\n * @return {void}\n */\nconst stop = function () {\n  read((err, data) => {\n    if (err) {\n      return console.log('no pid file')\n    } else {\n      try {\n        process.kill(data.pid)\n      } catch (err) {\n        return console.log(`No process found for PID ${data.pid}`)\n      }\n      const uptime = new Date().getTime() - data.timestamp\n      console.log(`Deepstream was running for ${uptime / 1000} seconds`)\n    }\n  })\n}\n\nmodule.exports = {\n  save,\n  isRunning,\n  ensureNotRunning,\n  exit,\n  stop,\n  read,\n  PID_FILE\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/bin/deepstream-status.js":"'use strict'\n\nconst pidHelper = require('./pid-helper')\n\nfunction statusCheck(cmd, program) {\n  pidHelper.read((err, data) => {\n    if (err) {\n      return console.log('not running (no pid file)')\n    }\n    if (pidHelper.isRunning(data.pid)) {\n      const seconds = (new Date().getTime() - data.timestamp) / 1000\n      console.log(`Process running with PID ${data.pid} since ${seconds} seconds`)\n    } else {\n      console.log(`Not running (no process for PID ${data.pid})`)\n    }\n  })\n}\n\nmodule.exports = function (program) {\n  program\n\t\t.command('status')\n\t\t.description('display if a deepstream server is running')\n\t\t.action(statusCheck)\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/bin/deepstream-stop.js":"'use strict'\n\nconst pidHelper = require('./pid-helper')\n\nmodule.exports = function (program) {\n  program\n\t\t.command('stop')\n\t\t.description('stop a running deepstream server')\n\t\t.action(pidHelper.stop)\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/scripts/details.js":"var exec = require( 'child_process' ).execSync;\nvar fs = require( 'fs' );\nvar path = require( 'path' );\nvar pkg = require( '../package' );\n\nif( process.argv[2] === 'VERSION' ) {\n\tconsole.log( pkg.version );\n} else if( process.argv[2] === 'UWS_VERSION' ) {\n\tconsole.log( pkg.dependencies.uws.replace('^','') );\n} else if( process.argv[2] === 'NAME' ) {\n\tconsole.log( pkg.name );\n} else if( process.argv[2] === 'OS' ) {\n\tconsole.log( require( 'os' ).platform() );\n} else if( process.argv[2] === 'COMMIT' ) {\n\tconsole.log( exec( 'git log --pretty=format:%h -n 1' ).toString() );\n} else if( process.argv[2] === 'META' ) {\n\twriteMetaFile();\n}\telse {\n\tconsole.log( 'ERROR: Pass in VERSION or NAME as env variable' );\n}\n\nfunction writeMetaFile() {\n\tvar meta = {\n\t\tdeepstreamVersion: pkg.version,\n\t\tgitRef: exec( 'git rev-parse HEAD' ).toString().trim(),\n\t\tbuildTime: new Date().toString()\n\t};\n\tfs.writeFileSync( path.join( __dirname, '..', 'meta.json' ), JSON.stringify( meta, null, 2 ), 'utf8' );\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/scripts/license-aggregator.js":"#!/usr/bin/env node\nconst path = require('path')\nconst fs = require('fs')\nconst child_process = require('child_process')\nconst async = require('async')\n\nconst PRE_HEADER = fs.readFileSync('LICENSE', 'utf8')\nconst HEADER = `\nThis license applies to all parts of deepstream.io that are not externally\nmaintained libraries.\n\nThe externally maintained libraries used by deepstream.io are:\n`\nconst emptyState  = \"see MISSING LICENSES at the bottom of this file\"\n\n\nif (path.basename(process.cwd()) === 'scripts') {\n  console.error('Run this script from the project root!')\n  process.exit(0)\n}\n\nchild_process.execSync('npm list --production --json > licenses.json')\nconst mainModule = require('../licenses.json')\n\nconst moduleNames = []\ntraverseDependencies(mainModule)\n\nfunction traverseDependencies(module) {\n  for (let dependency in module.dependencies) {\n    moduleNames.push(dependency)\n    traverseDependencies(module.dependencies[dependency])\n  }\n}\n\n// This source code is taken from the 'license-spelunker' npm module, it was patched\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2013 Mike Brevoort\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\nvar projPath = path.resolve(process.argv[2] || '.')\nconsole.error('Project Path', projPath)\nvar topPkg = require(path.join(projPath, 'package.json'))\n\nvar modules = []\nvar count = 0\n\ndoLevel(projPath)\n\n\nfunction doLevel(nodePath) {\n  var pkg = require(path.join(nodePath, 'package.json'))\n  if (topPkg.name !== pkg.name && moduleNames.indexOf(pkg.name) === -1) {\n    return\n  }\n  var nodeModulesPath = path.join(nodePath, 'node_modules')\n  count ++\n\n  //console.error('package.json license', pkg.license)\n\n  fs.exists(nodeModulesPath, function (dirExists) {\n    if (dirExists) {\n      fs.readdir(nodeModulesPath, function (err, files) {\n        if (err) throw err\n        files = files.map(function (f) { return path.join(nodeModulesPath, f) })\n        async.filter(files, isModuleDirectory, (err, directories) => {\n          directories.forEach(doLevel)\n        })\n      })\n    }\n  })\n\n  licenseText(nodePath, function (license) {\n    var licenceProperty = pkg.license || pkg.licenses\n    var licenceUrl = (pkg.license || {}).url\n    if ((licenceProperty || {}).type) {\n      licenceProperty = licenceProperty.type\n      licenceUrl = licenceProperty[0].url\n    }\n    if (((licenceProperty || {})[0] || []).type) {\n      licenceProperty = licenceProperty[0].type\n      licenceUrl = licenceProperty[0].url\n    }\n\n    if (pkg.name !== topPkg.name) {\n      modules.push({\n        name: pkg.name,\n        version: pkg.version,\n        url: 'http://npmjs.org/package/' + pkg.name,\n        localPath: path.relative(projPath,nodePath),\n        pkgLicense: licenceProperty,\n        licenceUrl: licenceUrl,\n        license: license\n      })\n    }\n    count--\n\n    if (count == 0) {\n      var noLicenseFile = modules.filter(function (m) { return m.license === emptyState })\n      var andNoPkgJsonLicense = noLicenseFile.filter(function (m) { return !m.pkgLicense })\n\n      // Status report\n      // Write to StdErr\n      console.error('LICENSE FILE REPORT FOR ', topPkg.name)\n      console.error(modules.length + ' nested dependencies')\n      console.error(noLicenseFile.length +  ' without identifiable license text')\n      console.error(andNoPkgJsonLicense.length +  ' without even a package.json license declaration', '\\n\\n')\n\n      // Write to StdOut\n      console.log(PRE_HEADER)\n      console.log('')\n      console.log(HEADER)\n      modules.forEach(function(m) {\n        console.log((modules.indexOf(m)+1) + ' ----------------------------------------------------------------------------')\n        console.log(m.name + '@' + m.version)\n        console.log(m.url)\n        console.log(m.localPath)\n        if (m.pkgLicense) console.log('From package.json license property:', JSON.stringify(m.pkgLicense))\n        if (m.licenceUrl) console.log('From package.json url property:', JSON.stringify(m.licenceUrl))\n        console.log('')\n        console.log(m.license)\n        console.log('')\n      })\n    }\n  })\n}\n\nfunction licenseText (nodePath, cb) {\n  var possibleLicensePaths = [\n    path.join(nodePath, 'LICENSE'),\n    path.join(nodePath, 'LICENCE'),\n    path.join(nodePath, 'LICENSE.md'),\n    path.join(nodePath, 'LICENSE.txt'),\n    path.join(nodePath, 'LICENSE-MIT'),\n    path.join(nodePath, 'LICENSE-BSD'),\n    path.join(nodePath, 'LICENSE.BSD'),\n    path.join(nodePath, 'MIT-LICENSE.txt'),\n    path.join(nodePath, 'Readme.md'),\n    path.join(nodePath, 'README.md'),\n    path.join(nodePath, 'README.markdown')\n  ]\n\n  async.reduceRight(possibleLicensePaths, emptyState, function (state, licensePath, reduceCb) {\n    var isAReadme = (licensePath.toLowerCase().indexOf('/readme') > 0)\n\n    // if we already found a licnese, don't bother looking at READMEs\n    if (state !== emptyState && isAReadme) return reduceCb (null, state)\n\n    fs.exists(licensePath, function (exists) {\n      if (!exists) return reduceCb(null, state)\n      fs.readFile(licensePath, { encoding: 'utf8' }, function (err, text) {\n        if (err) return logError(err, reduceCb)(err, state)\n\n        if (isAReadme) {\n          var match = text.match(/\\n[# ]*license[ \\t]*\\n/i)\n          if (match) {\n            //console.log(match.input.substring(match.index))\n            return reduceCb (null, 'FROM README:\\n' + match.input.substring(match.index))\n          }\n          else {\n            return reduceCb(null, state)\n          }\n        }\n        else {\n          return reduceCb (null, text)\n        }\n\n\n        return reduceCb (null, text)\n      })\n\n    })\n  }, function (err, license) {\n    if (err) return cb('ERROR FINDING LICENSE FILE ' + err )\n    cb (license)\n  })\n}\n\nfunction isModuleDirectory (dirPath, cb) {\n  var pkgPath = path.join(dirPath, 'package.json')\n  fs.stat(dirPath, function (err, stat) {\n    if (err) return logError(err, cb)(false)\n\n    var isdir = stat.isDirectory()\n    if (isdir) {\n      fs.access(pkgPath, (err) => {\n        cb(null, !err)\n      })\n    }\n    else {\n      cb(false)\n    }\n  })\n}\n\nfunction logError(err, cb) {\n  console.error('ERROR', err)\n  return cb\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/scripts/nexe.js":"const nexe = require( 'nexe' );\nnexe.compile( {\n\t\tflags: true,\n\t\tinput: \"bin/deepstream\",\n\t\toutput: process.env.EXECUTABLE_NAME,\n\t\tnodeVersion: process.env.NODE_VERSION_WITHOUT_V,\n\t\tnodeTempDir: \"nexe_node\",\n\t\tframework: \"node\",\n\t\tresourceFiles: [ \"ascii-logo.txt\" ]\n\t},\n\tfunction(error) {\n\t\tif ( error ) {\n\t\t\treturn console.error( error.message );\n\t\t}\n\t}\n);\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/authentication/http-authentication-handler.js":"'use strict'\n\nconst HttpAuthenticationRequest = require('./http-authentication-request')\nconst utils = require('../utils/utils')\n\nconst EventEmitter = require('events').EventEmitter\n\n/**\n *\n * @public\n * @extends {EventEmitter}\n */\nmodule.exports = class HttpAuthenticationHandler extends EventEmitter {\n  /**\n  * Creates the class\n  *\n  * @param   {Object} settings\n  * @param   {String} settings.endpointUrl http(s) endpoint that will receive post requests\n  * @param   {Array}  settings.permittedStatusCodes an array of http status codes that qualify\n  *                                                 as permitted\n  * @param   {Number} settings.requestTimeout time in milliseconds before the request times out\n  *                                           if no reply is received\n  *\n  * @param   {Logger} logger\n  *\n  * @constructor\n  * @returns {void}\n  */\n  constructor (settings, logger) {\n    super()\n    this.isReady = true\n    this.type = `http webhook to ${settings.endpointUrl}`\n    this._settings = settings\n    this._logger = logger\n    this._validateSettings()\n  }\n\n  /**\n  * Main interface. Authenticates incoming connections\n  *\n  * @param   {Object}   connectionData\n  * @param   {Object}   authData\n  * @param   {Function} callback\n  *\n  * @public\n  * @implements {PermissionHandler.isValidUser}\n  * @returns {void}\n  */\n  isValidUser (connectionData, authData, callback) {\n    // eslint-disable-next-line\n    new HttpAuthenticationRequest(\n      { connectionData, authData },\n      this._settings,\n      this._logger,\n      callback\n    )\n  }\n\n  /**\n  * Validate the user provided settings\n  *\n  * @private\n  * @returns {void}\n  */\n  _validateSettings () {\n    utils.validateMap(this._settings, true, {\n      endpointUrl: 'url',\n      permittedStatusCodes: 'array',\n      requestTimeout: 'number'\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/authentication/http-authentication-request.js":"'use strict'\n\nconst needle = require('needle')\nconst C = require('../constants/constants')\n\n/**\n * This class represents a single request from deepstream to a http\n * endpoint for authentication data\n */\nmodule.exports = class HttpAuthenticationRequest {\n\n  /**\n   * Creates and issues the request and starts the timeout\n   *\n   * @param   {Object}   data           Map with authData and connectionData\n   * @param   {Object}   settings       contains requestTimeout and permittedStatusCodes\n   * @param   {Function} callback       Called with error, isAuthenticated, userData\n   * @param   {Logger}   logger\n   *\n   * @constructor\n   * @returns {void}\n   */\n  constructor (data, settings, logger, callback) {\n    this._settings = settings\n    this._callback = callback\n    this._logger = logger\n\n    const options = {\n      read_timeout: settings.requestTimeout,\n      open_timeout: settings.requestTimeout,\n      timeout: settings.requestTimeout,\n      follow_max: 2,\n      json: true\n    }\n\n    needle.post(settings.endpointUrl, data, options, this._onComplete.bind(this))\n  }\n\n  /**\n   * Invoked for completed responses, whether succesful\n   * or erroures\n   *\n   * @param {Error} error HTTP Error\n   * @param {http.Response} response\n   *\n   * @private\n   * @returns {void}\n   */\n  _onComplete (error, response) {\n    if (error) {\n      this._logger.log(C.LOG_LEVEL.WARN, C.EVENT.AUTH_ERROR, `http auth error: ${error}`)\n      this._callback(false, null)\n      this._destroy()\n      return\n    }\n\n    if (response.statusCode >= 500 && response.statusCode < 600) {\n      this._logger.log(C.LOG_LEVEL.WARN, C.EVENT.AUTH_ERROR, `http auth server error: ${response.body}`)\n    }\n\n    if (this._settings.permittedStatusCodes.indexOf(response.statusCode) === -1) {\n      this._callback(false, response.body || null)\n    } else if (response.body && typeof response.body === 'string') {\n      this._callback(true, { username: response.body })\n    } else {\n      this._callback(true, response.body || null)\n    }\n\n    this._destroy()\n  }\n\n  /**\n   * Destroys the class\n   *\n   * @private\n   * @returns {void}\n   */\n  _destroy () {\n    this._callback = null\n    this._settings = null\n    this._logger = null\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/authentication/open-authentication-handler.js":"'use strict'\n\nconst EventEmitter = require('events').EventEmitter\n\n/**\n * Used for users that don't provide a username\n *\n * @type {String}\n */\nconst OPEN = 'open'\n\n/**\n * The open authentication handler allows every client to connect.\n * If the client specifies a username as part of its authentication\n * data, it will be used to identify the user internally\n *\n * @class OpenAuthenticationHandler\n */\nmodule.exports = class OpenAuthenticationHandler extends EventEmitter {\n  /**\n  * @param {String} type exposes the type for logging purposes. This one is called\n  *                      none to avoid confusion with openAuth\n  */\n  constructor () {\n    super()\n    this.type = 'none'\n    this.isReady = true\n  }\n\n  /**\n  * Grants access to any user. Registeres them with username or open\n  *\n  * @param   {Object}   connectionData\n  * @param   {Object}   authData\n  * @param   {Function} callback\n  *\n  * @public\n  * @implements {PermissionHandler.isValidUser}\n  * @returns {void}\n  */\n  isValidUser (connectionData, authData, callback) { // eslint-disable-line\n    callback(true, { username: authData.username || OPEN })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/default-plugins/local-cache.js":"'use strict'\n\nconst LocalCache = function () {\n  this.isReady = true\n  this._data = {}\n}\n\nLocalCache.prototype.set = function (key, value, callback) {\n  this._data[key] = value\n  callback(null)\n}\n\nLocalCache.prototype.get = function (key, callback) {\n  callback(null, this._data[key] || null)\n}\n\nLocalCache.prototype.delete = function (key, callback) {\n  delete this._data[key]\n  callback(null)\n}\n\nmodule.exports = new LocalCache()\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/default-plugins/noop-message-connector.js":"'use strict'\n\nconst noop = function () {}\n\nexports.subscribe = noop\nexports.publish = noop\nexports.unsubscribe = noop\nexports.isReady = true\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/default-plugins/noop-storage.js":"'use strict'\n\nexports.get = function (key, callback) {\n  callback(null, null)\n}\n\nexports.set = function (key, value, callback) { callback(null) }\nexports.delete = function (key, callback) { callback(null) }\nexports.isReady = true\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/permission/config-compiler.js":"'use strict'\n\nconst pathParser = require('./path-parser')\nconst ruleParser = require('./rule-parser')\n\n/**\n * Compiles a pre-validated config into a format that allows for quicker access\n * and execution\n *\n * @param   {Object} config parsed and validated permission config\n *\n * @public\n * @returns {Object} compiledConfig\n */\nexports.compile = function (config) {\n  const compiledConfig = {}\n  let compiledRuleset\n  let section\n  let path\n\n  for (section in config) {\n    compiledConfig[section] = []\n\n    for (path in config[section]) {\n      compiledRuleset = compileRuleset(path, config[section][path])\n      compiledConfig[section].push(compiledRuleset)\n    }\n  }\n\n  return compiledConfig\n}\n\n/**\n * Compiles an individual ruleset\n *\n * @param   {String} path\n * @param   {Object} rules\n *\n * @private\n * @returns {Object} compiledRuleset\n */\nfunction compileRuleset (path, rules) {\n  const ruleset = pathParser.parse(path)\n\n  ruleset.rules = {}\n\n  for (const ruleType in rules) {\n    ruleset.rules[ruleType] = ruleParser.parse(\n      rules[ruleType], ruleset.variables\n    )\n  }\n\n  return ruleset\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/permission/path-parser.js":"'use strict'\n\nconst WILDCARD_REGEXP = /\\*/g\nconst WILDCARD_STRING = '.*'\nconst VARIABLE_REGEXP = /(\\$[a-zA-Z0-9]+)/g\nconst VARIABLE_STRING = '([^/]+)'\nconst INVALID_VARIABLE_REGEXP = /(\\$[^a-zA-Z0-9])/\n\n/**\n * Checks a path for type and basic syntax errors\n *\n * @param   {String} path The path as specified in permission.json\n *\n * @public\n * @returns {String|Boolean} true if path is valid, string error message if not\n */\nexports.validate = function (path) {\n  if (typeof path !== 'string') {\n    return 'path must be a string'\n  }\n\n  if (path.length === 0) {\n    return 'path can\\'t be empty'\n  }\n\n  if (path[0] === '/') {\n    return 'path can\\'t start with /'\n  }\n\n  const invalidVariableNames = path.match(INVALID_VARIABLE_REGEXP)\n\n  if (invalidVariableNames !== null) {\n    return `invalid variable name ${invalidVariableNames[0]}`\n  }\n\n  return true\n}\n\n/**\n * Parses a path and returns a regexp matcher with capture groups for\n * variable names and a list of variable names in the same order.\n * The path is assumed to be valid when its passed to this method\n *\n * @param   {String} path The path as specified in permission.json\n *\n * @public\n * @returns {Object} { variables: <String variableNames>[], regexp: <RegExp>}\n */\nexports.parse = function (path) {\n  const variables = []\n  let regExp = path.replace(WILDCARD_REGEXP, WILDCARD_STRING)\n\n  regExp = regExp.replace(VARIABLE_REGEXP, (variableName) => {\n    variables.push(variableName)\n    return VARIABLE_STRING\n  })\n\n  return {\n    variables,\n    path,\n    regexp: new RegExp(`^${regExp}$`)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/permission/rule-parser.js":"'use strict'\n\nconst rulesMap = require('./rules-map')\n\n// TODO: any of these are fine inside a string or comment context...\nconst FUNCTION_REGEXP = /([\\w]+(?:['\"`]\\])?)\\s*\\(/g\nconst USER_FUNCTION_REGEXP = /[^\\w$]function[^\\w$]|=>/g\nconst NEW_REGEXP = /(^|[^\\w$])new[^\\w$]/\nconst OLD_DATA_REGEXP = /(^|[^\\w~])oldData[^\\w~]/\nconst DATA_REGEXP = /(^|[^\\w.~])data($|[^\\w~])/\n\nconst SUPPORTED_FUNCTIONS = [\n  '_',\n  'startsWith',\n  'endsWith',\n  'includes',\n  'indexOf',\n  'match',\n  'toUpperCase',\n  'toLowerCase',\n  'trim'\n]\n\n/**\n * Validates a rule. Makes sure that the rule is either a boolean or a string,\n * that it doesn't contain the new keyword or unsupported function invocations\n * and that it can be compiled into a javascript function\n *\n * @param   {String|Boolean} rule the rule as read from permissions.json\n * @param   {String} section record, event or rpc\n * @param   {String} type read, write, publish, subscribe etc...\n *\n * @public\n * @returns {Boolean} isValid\n */\nexports.validate = function (rule, section, type) {\n  if (typeof rule === 'boolean') {\n    return true\n  }\n\n  if (typeof rule !== 'string') {\n    return 'rule must be a string'\n  }\n\n  if (rule.length === 0) {\n    return 'rule can\\'t be empty'\n  }\n\n  if (rule.match(NEW_REGEXP)) {\n    return 'rule can\\'t contain the new keyword'\n  }\n\n  if (rule.match(USER_FUNCTION_REGEXP)) {\n    return 'rule can\\'t contain user functions'\n  }\n\n  const functions = rule.match(FUNCTION_REGEXP)\n  let functionName\n  let i\n\n  // TODO _ cross references are only supported for section record\n  if (functions) {\n    for (i = 0; i < functions.length; i++) {\n      functionName = functions[i].replace(/\\s*\\($/, '')\n      if (SUPPORTED_FUNCTIONS.indexOf(functionName) === -1) {\n        return `function ${functionName} is not supported`\n      }\n    }\n  }\n\n  try {\n    // eslint-disable-next-line\n    new Function(rule)\n  } catch (e) {\n    return e.toString()\n  }\n\n  if (!!rule.match(OLD_DATA_REGEXP) && !rulesMap.supportsOldData(type)) {\n    return `rule ${type} for ${section} does not support oldData`\n  }\n\n  if (!!rule.match(DATA_REGEXP) && !rulesMap.supportsData(type)) {\n    return `rule ${type} for ${section} does not support data`\n  }\n\n  return true\n}\n\n/**\n * Cross References:\n *\n * Cross references are denoted with an underscore function _()\n * They can take path variables: _($someId)\n * variables from data: _(data.someValue)\n * or strings: _('user/egon')\n *\n * @param   {[type]} rule      [description]\n * @param   {[type]} variables [description]\n *\n * @returns {[type]}\n */\nexports.parse = function (rule, variables) {\n  if (rule === true || rule === false) {\n    return {\n      fn: rule === true ? function () { return true } : function () { return false },\n      hasOldData: false,\n      hasData: false\n    }\n  }\n  const ruleObj = {}\n  const args = ['_', 'user', 'data', 'oldData', 'now', 'action'].concat(variables)\n  args.push(`return ${rule};`)\n\n  ruleObj.fn = Function.apply(this, args)\n  ruleObj.hasOldData = !!rule.match(OLD_DATA_REGEXP)\n  ruleObj.hasData = !!rule.match(DATA_REGEXP)\n\n  return ruleObj\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/permission/rules-map.js":"'use strict'\n\nconst C = require('../constants/constants')\nconst utils = require('../utils/utils')\n\nconst actionToKey = utils.reverseMap(C.ACTIONS)\nconst RULES_MAP = {}\nconst RULE_TYPES = {}\n\n/**\n * Different rule types support different features. Generally, all rules can\n * use cross referencing _() to reference records, but only record writes, incoming events\n * or RPC requests carry data and only existing records have a concept of oldData\n *\n * @type {Object}\n */\nRULE_TYPES.CREATE = { name: 'create', data: false, oldData: false }\nRULE_TYPES.READ = { name: 'read', data: false, oldData: true }\nRULE_TYPES.WRITE = { name: 'write', data: true, oldData: true }\nRULE_TYPES.DELETE = { name: 'delete', data: false, oldData: true }\nRULE_TYPES.LISTEN = { name: 'listen', data: false, oldData: false }\nRULE_TYPES.PUBLISH = { name: 'publish', data: true, oldData: false }\nRULE_TYPES.SUBSCRIBE = { name: 'subscribe', data: true, oldData: false }\nRULE_TYPES.PROVIDE = { name: 'provide', data: false, oldData: false }\nRULE_TYPES.REQUEST = { name: 'request', data: true, oldData: false }\nRULE_TYPES.ALLOW = { name: 'allow', data: false, oldData: false }\n\n/**\n * This class maps topic / action combinations to applicable\n * rules. It combines actions of a similar character (e.g. READ,\n * SNAPSHOT, HAS) into high level permissions (e.g. read)\n *\n * Lower level permissioning on a per action basis can still be achieved\n * by virtue of using the action variable within the rule, e.g.\n *\n * {\n *    //allow read, but not listen\n *    'read': 'user.id === $userId && action !== LISTEN'\n * }\n */\nRULES_MAP[C.TOPIC.RECORD] = {}\nRULES_MAP[C.TOPIC.RECORD].section = 'record'\nRULES_MAP[C.TOPIC.RECORD].actions = {}\nRULES_MAP[C.TOPIC.RECORD].actions[C.ACTIONS.READ] = RULE_TYPES.READ\nRULES_MAP[C.TOPIC.RECORD].actions[C.ACTIONS.HAS] = RULE_TYPES.READ\nRULES_MAP[C.TOPIC.RECORD].actions[C.ACTIONS.SNAPSHOT] = RULE_TYPES.READ\nRULES_MAP[C.TOPIC.RECORD].actions[C.ACTIONS.HEAD] = RULE_TYPES.READ\nRULES_MAP[C.TOPIC.RECORD].actions[C.ACTIONS.LISTEN] = RULE_TYPES.LISTEN\nRULES_MAP[C.TOPIC.RECORD].actions[C.ACTIONS.LISTEN_SNAPSHOT] = RULE_TYPES.LISTEN\nRULES_MAP[C.TOPIC.RECORD].actions[C.ACTIONS.CREATE] = RULE_TYPES.CREATE\nRULES_MAP[C.TOPIC.RECORD].actions[C.ACTIONS.UPDATE] = RULE_TYPES.WRITE\nRULES_MAP[C.TOPIC.RECORD].actions[C.ACTIONS.PATCH] = RULE_TYPES.WRITE\nRULES_MAP[C.TOPIC.RECORD].actions[C.ACTIONS.DELETE] = RULE_TYPES.DELETE\n\nRULES_MAP[C.TOPIC.EVENT] = {}\nRULES_MAP[C.TOPIC.EVENT].section = 'event'\nRULES_MAP[C.TOPIC.EVENT].actions = {}\nRULES_MAP[C.TOPIC.EVENT].actions[C.ACTIONS.LISTEN] = RULE_TYPES.LISTEN\nRULES_MAP[C.TOPIC.EVENT].actions[C.ACTIONS.SUBSCRIBE] = RULE_TYPES.SUBSCRIBE\nRULES_MAP[C.TOPIC.EVENT].actions[C.ACTIONS.EVENT] = RULE_TYPES.PUBLISH\n\nRULES_MAP[C.TOPIC.RPC] = {}\nRULES_MAP[C.TOPIC.RPC].section = 'rpc'\nRULES_MAP[C.TOPIC.RPC].actions = {}\nRULES_MAP[C.TOPIC.RPC].actions[C.ACTIONS.SUBSCRIBE] = RULE_TYPES.PROVIDE\nRULES_MAP[C.TOPIC.RPC].actions[C.ACTIONS.REQUEST] = RULE_TYPES.REQUEST\n\nRULES_MAP[C.TOPIC.PRESENCE] = {}\nRULES_MAP[C.TOPIC.PRESENCE].section = 'presence'\nRULES_MAP[C.TOPIC.PRESENCE].actions = {}\nRULES_MAP[C.TOPIC.PRESENCE].actions[C.ACTIONS.SUBSCRIBE] = RULE_TYPES.ALLOW\nRULES_MAP[C.TOPIC.PRESENCE].actions[C.ACTIONS.QUERY] = RULE_TYPES.ALLOW\n\n\n/**\n * Returns a map of applicable rule-types for a topic\n * action combination\n *\n * @param   {Message} message a parsed and validated deepstream.io message\n *\n * @public\n * @returns {Object} ruleTypes a map with <String> section, <Array> rules, <String> action\n */\nexports.getRulesForMessage = function (message) {\n  if (RULES_MAP[message.topic] === undefined) {\n    return null\n  }\n\n  if (RULES_MAP[message.topic].actions[message.action] === undefined) {\n    return null\n  }\n\n  return {\n    section: RULES_MAP[message.topic].section,\n    type: RULES_MAP[message.topic].actions[message.action].name,\n    action: actionToKey[message.action]\n  }\n}\n\n/**\n * Returns true if a given rule supports references to incoming data\n *\n * @param   {String} type one of RULE_TYPES\n *\n * @public\n * @returns {Boolean}\n */\nexports.supportsData = function (type) {\n  return RULE_TYPES[type.toUpperCase()].data\n}\n\n/**\n * Returns true if a given rule supports references to existing data\n *\n * @param   {String} type one of RULE_TYPES\n *\n * @public\n * @returns {Boolean}\n */\nexports.supportsOldData = function (type) {\n  return RULE_TYPES[type.toUpperCase()].oldData\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/permission/config-permission-handler.js":"'use strict'\n/* eslint-disable valid-typeof */\nconst configValidator = require('./config-validator')\nconst configCompiler = require('./config-compiler')\nconst rulesMap = require('./rules-map')\nconst RuleApplication = require('./rule-application')\nconst RuleCache = require('./rule-cache')\nconst events = require('events')\nconst utils = require('util')\nconst jsYamlLoader = require('../config/js-yaml-loader')\n\nconst STRING = 'string'\nconst UNDEFINED = 'undefined'\n\n/**\n * A permission handler that reads a rules config YAML or JSON, validates\n * its contents, compiles it and executes the permissions that it contains\n * against every incoming message.\n *\n * This is the standard permission handler that deepstream exposes, in conjunction\n * with the default permission.yml it allows everything, but at the same time provides\n * a convenient starting point for permission declarations.\n *\n * @author deepstreamHub GmbH\n * @license [https://github.com/deepstreamIO/deepstream.io/blob/master/LICENSE] MIT\n *\n * @constructor\n * @extends {EventEmitter}\n *\n * @param {Object} options deepstream options\n * @param {[Object]} config  Optional config. If no config is provided, the\n *                           ConfigPermissionHandler will attempt\n *                           to load it from the path provided in options.path.\n */\nconst ConfigPermissionHandler = function (options, config) {\n  this._ruleCache = new RuleCache(options)\n  this._options = options\n  this._permissionOptions = options.permission.options\n  this._config = null\n  this._recordHandler = null\n  this.isReady = false\n  this.type = `valve permissions loaded from ${this._permissionOptions.path}`\n  this._optionsValid = true\n\n  const maxRuleIterations = options.permission.options.maxRuleIterations\n  if (maxRuleIterations !== undefined && maxRuleIterations < 1) {\n    this._optionsValid = false\n    process.nextTick(() => this.emit('error', 'Maximum rule iteration has to be at least one '))\n  } else if (config) {\n    this.useConfig(config)\n  }\n}\n\nutils.inherits(ConfigPermissionHandler, events.EventEmitter)\n\n/**\n * Will be invoked with the initialised recordHandler instance by deepstream.io\n *\n * @param {RecordHandler} recordHandler\n *\n * @public\n * @returns {void}\n */\nConfigPermissionHandler.prototype.setRecordHandler = function (recordHandler) {\n  this._recordHandler = recordHandler\n}\n\n/**\n * Will be called by the dependency initialiser once server.start() is called.\n * This gives users a chance to change the path using server.set()\n * first\n *\n * @public\n * @returns {void}\n */\nConfigPermissionHandler.prototype.init = function () {\n  if (this._config === null && this._optionsValid) {\n    this.loadConfig(this._permissionOptions.path)\n  }\n}\n\n/**\n * Load a configuration file. This will either load a configuration file for the first time at\n * startup or reload the configuration at runtime\n *\n * CLI loadConfig <path>\n *\n * @todo expose this method via the command line interface\n *\n * @param   {String} path the filepath of the permission.yml file\n *\n * @public\n * @returns {void}\n */\nConfigPermissionHandler.prototype.loadConfig = function (filePath) {\n  jsYamlLoader.readAndParseFile(filePath, this._onConfigLoaded.bind(this, filePath))\n}\n\n/**\n * Validates and compiles a loaded config. This can be called as the result\n * of a config being passed to the permissionHandler upon initialisation,\n * as a result of loadConfig or at runtime\n *\n * CLI useConfig <config>\n *\n * @todo expose this method via the command line interface\n *\n * @param   {Object} config deepstream permissionConfig\n *\n * @public\n * @returns {void}\n */\nConfigPermissionHandler.prototype.useConfig = function (config) {\n  const validationResult = configValidator.validate(config)\n\n  if (validationResult !== true) {\n    this.emit('error', `invalid permission config - ${validationResult}`)\n    return\n  }\n\n  this._config = configCompiler.compile(config)\n  this._ruleCache.reset()\n  this._ready()\n}\n\n/**\n * Implements the permissionHandler's canPerformAction interface\n * method\n *\n * This is the main entry point for permissionOperations and will\n * be called for every incoming message. This method executes four steps\n *\n * - Check if the incoming message conforms to basic specs\n * - Check if the incoming message requires permissions\n * - Load the applicable permissions\n * - Apply them\n *\n * @param   {String}   username the name of the connected user, as specified in isValidUser\n * @param   {Object}   message  a parsed deepstream message\n * @param   {Function} callback the callback to provide the result\n * @param   {[Object]}   authData additional optional authData as passed to isValidUser\n *\n * @public\n * @interface\n * @returns {void}\n */\nConfigPermissionHandler.prototype.canPerformAction = function (\n  username, message, callback, authData) {\n  if (typeof message.data[0] !== STRING) {\n    callback('invalid message', false)\n    return\n  }\n\n  const ruleSpecification = rulesMap.getRulesForMessage(message)\n  const name = message.data[0]\n\n  if (ruleSpecification === null) {\n    callback(null, true)\n    return\n  }\n\n  const ruleData = this._getCompiledRulesForName(name, ruleSpecification)\n\n  // eslint-disable-next-line\n  new RuleApplication({\n    recordHandler: this._recordHandler,\n    username,\n    authData,\n    path: ruleData,\n    ruleSpecification,\n    message,\n    action: ruleSpecification.action,\n    regexp: ruleData.regexp,\n    rule: ruleData.rule,\n    name,\n    callback,\n    logger: this._options.logger,\n    permissionOptions: this._permissionOptions,\n    options: this._options\n  })\n}\n\n/**\n * Evaluates the rules within a section and returns the matching rule for a path.\n * Takes basic specificity (as deduced from the path length) into account and\n * caches frequently used rules for faster access\n *\n * @param   {String} name              the name of the record, event or rpc the rule applies to\n * @param   {Object} ruleSpecification a ruleSpecification as provided by the rules-map\n *\n * @private\n * @returns {Object} compiled rules\n */\nConfigPermissionHandler.prototype._getCompiledRulesForName = function (name, ruleSpecification) {\n  if (this._ruleCache.has(ruleSpecification.section, name, ruleSpecification.type)) {\n    return this._ruleCache.get(ruleSpecification.section, name, ruleSpecification.type)\n  }\n\n  const section = this._config[ruleSpecification.section]\n  let i = 0\n  let pathLength = 0\n  let result = null\n\n  for (i; i < section.length; i++) {\n    if (\n      typeof section[i].rules[ruleSpecification.type] !== UNDEFINED &&\n      section[i].path.length >= pathLength &&\n      section[i].regexp.test(name)\n    ) {\n      pathLength = section[i].path.length\n      result = {\n        path: section[i].path,\n        regexp: section[i].regexp,\n        rule: section[i].rules[ruleSpecification.type]\n      }\n    }\n  }\n\n  if (result) {\n    this._ruleCache.set(ruleSpecification.section, name, ruleSpecification.type, result)\n  }\n\n  return result\n}\n\n/**\n * Callback for loadConfig. Parses the incoming configuration string and forwards\n * it to useConfig if no errors occured\n *\n * @param   {Error} loadError a FileSystem Error that occured during the loading of the file\n * @param   {String} data     the content of the permission.yml file as utf-8 encoded string\n *\n * @private\n * @returns {void}\n */\nConfigPermissionHandler.prototype._onConfigLoaded = function (filePath, loadError, config) {\n  if (loadError) {\n    this.emit('error', `error while loading config: ${loadError.toString()}`)\n    return\n  }\n  this.emit('config-loaded', filePath)\n  this.useConfig(config)\n}\n\n/**\n * Sets this permissionHandler to ready. Occurs once the config has been successfully loaded,\n * parsed and compiled\n *\n * @private\n * @returns {void}\n */\nConfigPermissionHandler.prototype._ready = function () {\n  if (this.isReady === false) {\n    this.isReady = true\n    this.emit('ready')\n  }\n}\n\nmodule.exports = ConfigPermissionHandler\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/permission/config-validator.js":"'use strict'\n\nconst pathParser = require('./path-parser')\nconst ruleParser = require('./rule-parser')\nconst SCHEMA = require('./config-schema')\n\nconst validationSteps = {}\n\n/**\n * Validates a configuration object. This method runs through multiple\n * individual validation steps. If any of them returns false,\n * the validation fails\n *\n * @param   {Object} config parsed permission config\n *\n * @public\n * @returns {Boolean|String} validationResult Only true is treated as pass.\n */\nexports.validate = function (config) {\n  let validationStepResult\n  let key\n\n  for (key in validationSteps) {\n    validationStepResult = validationSteps[key](config)\n\n    if (validationStepResult !== true) {\n      return validationStepResult\n    }\n  }\n\n  return true\n}\n\n/**\n * Checks if the configuration is an object\n *\n * @param   {Object} config parsed permission config\n *\n * @private\n * @returns {Boolean}\n */\nvalidationSteps.isValidType = function (config) {\n  if (typeof config === 'object') {\n    return true\n  }\n\n  return `config should be an object literal, but was of type ${typeof config}`\n}\n\n/**\n * Makes sure all sections (record, event, rpc) are present\n *\n * @param   {Object} config parsed permission config\n *\n * @private\n * @returns {Boolean}\n */\nvalidationSteps.hasRequiredTopLevelKeys = function (config) {\n  for (const key in SCHEMA) {\n    if (typeof config[key] !== 'object') {\n      return `missing configuration section \"${key}\"`\n    }\n  }\n\n  return true\n}\n\n/**\n * Makes sure no unsupported sections were added\n *\n * @param   {Object} config parsed permission config\n *\n * @private\n * @returns {Boolean}\n */\nvalidationSteps.doesNotHaveAdditionalTopLevelKeys = function (config) {\n  for (const key in config) {\n    if (typeof SCHEMA[key] === 'undefined') {\n      return `unexpected configuration section \"${key}\"`\n    }\n  }\n\n  return true\n}\n\n/**\n * Checks if the configuration contains valid path definitions\n *\n * @param   {Object} config parsed permission config\n *\n * @private\n * @returns {Boolean}\n */\nvalidationSteps.doesOnlyContainValidPaths = function (config) {\n  let key\n  let path\n  let result\n\n  for (key in SCHEMA) {\n    // Check empty\n    if (Object.keys(config[key]).length === 0) {\n      return `empty section \"${key}\"`\n    }\n\n    // Check valid\n    for (path in config[key]) {\n      result = pathParser.validate(path)\n      if (result !== true) {\n        return `${result} for path ${path} in section ${key}`\n      }\n    }\n  }\n\n  return true\n}\n\n/**\n * Each section must specify a generic permission (\"*\") that\n * will be applied if no other permission is applicable\n *\n * @param   {Object} config parsed permission config\n *\n * @private\n * @returns {Boolean}\n */\nvalidationSteps.doesHaveRootEntries = function (config) {\n  let sectionName\n\n  for (sectionName in SCHEMA) {\n    if (!config[sectionName]['*']) {\n      return `missing root entry \"*\" for section ${sectionName}`\n    }\n  }\n\n  return true\n}\n\n/**\n * Runs the rule validator against every rule in each section\n *\n * @param   {Object} config parsed permission config\n *\n * @private\n * @returns {Boolean}\n */\nvalidationSteps.hasValidRules = function (config) {\n  let path\n  let ruleType\n  let section\n  let validationResult\n\n  for (section in config) {\n    for (path in config[section]) {\n      for (ruleType in config[section][path]) {\n        if (SCHEMA[section][ruleType] !== true) {\n          return `unknown rule type ${ruleType} in section ${section}`\n        }\n\n        validationResult = ruleParser.validate(config[section][path][ruleType], section, ruleType)\n        if (validationResult !== true) {\n          return validationResult\n        }\n      }\n    }\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/permission/config-schema.js":"'use strict'\n\n/**\n * A basic schema for permission.json files that\n * the config validater uses\n *\n * @type {Object}\n */\nmodule.exports = {\n  record: {\n    write: true,\n    read: true,\n    create: true,\n    delete: true,\n    listen: true\n  },\n  event: {\n    publish: true,\n    subscribe: true,\n    listen: true\n  },\n  rpc: {\n    provide: true,\n    request: true\n  },\n  presence: {\n    allow: true\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/permission/rule-application.js":"'use strict'\n/* eslint-disable consistent-return */\nconst OPEN = 'open'\nconst UNDEFINED = 'undefined'\nconst LOADING = 'loading'\nconst ERROR = 'error'\nconst STRING = 'string'\nconst EOL = require('os').EOL\n\nconst C = require('../constants/constants')\nconst RecordRequest = require('../record/record-request')\nconst messageParser = require('../message/message-parser')\nconst JsonPath = require('../record/json-path')\n\n/**\n * This class handles the evaluation of a single rule. It creates\n * the required variables, injects them into the rule function and\n * runs the function recoursively until either all cross-references,\n * references to old or new data is loaded, it errors or the maxIterationCount\n * limit is exceeded\n *\n * @constructor\n *\n * @param {Object} params requires the following keys\n *\n * username: <String>,\n * authData: <Object>,\n * path: <Object>,\n * ruleSpecification: <Object>,\n * message: <Object>,\n * action: <String>,\n * regexp: <RegExp>,\n * rule: <Object>,\n * name: <String>,\n * callback: <Function>,\n * options: <Object>\n */\nconst RuleApplication = function (params) {\n  this._params = params\n  this._isDestroyed = false\n  this._runScheduled = false\n  this._maxIterationCount = this._params.permissionOptions.maxRuleIterations\n  this._crossReferenceFn = this._crossReference.bind(this)\n  this._pathVars = this._getPathVars()\n  this._user = this._getUser()\n  this._recordData = {}\n  this._id = Math.random().toString()\n  this._iterations = 0\n  this._run()\n}\n\n/**\n * Runs the rule function. This method is initially called when this class\n * is constructed and recoursively from thereon whenever the loading of a record\n * is completed\n *\n * @private\n * @returns {void}\n */\nRuleApplication.prototype._run = function () {\n  this._runScheduled = false\n  this._iterations++\n  /* istanbul ignore next */\n  if (this._isDestroyed === true) {\n    return\n  }\n\n  if (this._iterations > this._maxIterationCount) {\n    this._onRuleError('Exceeded max iteration count')\n    return\n  }\n\n  const args = this._getArguments()\n  let result\n\n  if (this._isDestroyed === true) {\n    return\n  }\n\n  try {\n    result = this._params.rule.fn.apply({}, args)\n  } catch (error) {\n    if (this._isReady()) {\n      this._onRuleError(error)\n      return\n    }\n  }\n\n  if (this._isReady()) {\n    this._params.callback(null, result)\n    this._destroy()\n  }\n}\n\n/**\n * Callback if a rule has irrecoverably errored. Rule errors due to unresolved\n * crossreferences are allowed as long as a loading step is in progress\n *\n * @param   {Error|String} error\n *\n * @private\n * @returns {void}\n */\nRuleApplication.prototype._onRuleError = function (error) {\n  if (this._isDestroyed === true) {\n    return\n  }\n  const errorMsg = `error when executing ${this._params.rule.fn.toString()}${EOL\n           }for ${this._params.path}: ${error.toString()}`\n  this._params.logger.log(C.LOG_LEVEL.WARN, C.EVENT.MESSAGE_PERMISSION_ERROR, errorMsg)\n  this._params.callback(C.EVENT.MESSAGE_PERMISSION_ERROR, false)\n  this._destroy()\n}\n\n/**\n * Called either asynchronously when data is successfully retrieved from the\n * cache or synchronously if its already present\n *\n * @param   {String} recordName the name of the loaded record data\n * @param   {Object} data       the data of the record\n *\n * @private\n * @returns {void}\n */\nRuleApplication.prototype._onLoadComplete = function (recordName, data) {\n  this._recordData[recordName] = data\n\n  if (this._isReady()) {\n    this._runScheduled = true\n    process.nextTick(this._run.bind(this))\n  }\n}\n\n/**\n * Called whenever a storage or cache retrieval fails. Any kind of error during the\n * permission process is treated as a denied permission\n *\n * @param   {String} recordName\n * @param   {Error}  error\n *\n * @private\n * @returns {void}\n */\nRuleApplication.prototype._onLoadError = function (recordName, error) {\n  this._recordData[recordName] = ERROR\n  const errorMsg = `failed to load record ${this._params.name} for permissioning:${error.toString()}`\n  this._params.logger.log(C.LOG_LEVEL.ERROR, C.EVENT.RECORD_LOAD_ERROR, errorMsg)\n  this._params.callback(C.EVENT.RECORD_LOAD_ERROR, false)\n  this._destroy()\n}\n\n/**\n * Destroys this class and nulls down values to avoid\n * memory leaks\n *\n * @private\n * @returns {void}\n */\nRuleApplication.prototype._destroy = function () {\n  this._params.recordHandler.removeRecordRequest(this._params.name)\n  this._isDestroyed = true\n  this._runScheduled = false\n  this._params = null\n  this._crossReferenceFn = null\n  this._pathVars = null\n  this._user = null\n  this._recordData = null\n  this._currentData = null\n}\n\n/**\n * If data.someValue is used in the rule, this method retrieves or loads the\n * current data. This can mean different things, depending on the type of message\n *\n * the data arguments is supported for record read & write,\n * event publish and rpc request\n *\n * for event publish, record update and rpc request, the data is already provided\n * in the message and doesn't need to be loaded\n *\n * for record.patch, only a delta is part of the message. For the full data, the current value\n * is loaded and the patch applied on top\n *\n * @private\n * @returns {void}\n */\nRuleApplication.prototype._getCurrentData = function () {\n  if (this._params.rule.hasData === false) {\n    return null\n  }\n\n  const msg = this._params.message\n  let data\n\n  if (msg.topic === C.TOPIC.EVENT && msg.data[1]) {\n    data = messageParser.convertTyped(msg.data[1])\n  } else if (msg.topic === C.TOPIC.RPC) {\n    data = messageParser.convertTyped(msg.data[2])\n  } else if (msg.topic === C.TOPIC.RECORD && msg.action === C.ACTIONS.UPDATE) {\n    data = this._getRecordUpdateData(msg)\n  } else if (msg.topic === C.TOPIC.RECORD && msg.action === C.ACTIONS.PATCH) {\n    data = this._getRecordPatchData(msg)\n  }\n\n  if (data instanceof Error) {\n    this._onRuleError(`error when converting message data ${data.toString()}`)\n  } else {\n    return data\n  }\n}\n\n/**\n * Extracts the data from record update messages\n *\n * @param   {Object} msg a deepstream message\n *\n * @private\n * @returns {Object} recordData\n */\nRuleApplication.prototype._getRecordUpdateData = function (msg) {\n  let data\n\n  try {\n    data = JSON.parse(msg.data[2])\n  } catch (error) {\n    return error\n  }\n\n  return data\n}\n\n/**\n * Loads the records current data and applies the patch data onto it\n * to avoid users having to distuinguish between patches and updates\n *\n * @param   {Object} msg a deepstream message\n *\n * @private\n * @returns {Object} recordData\n */\nRuleApplication.prototype._getRecordPatchData = function (msg) {\n  if (msg.data.length !== 4 || typeof msg.data[2] !== STRING) {\n    return new Error('Invalid message data')\n  }\n\n  const currentData = this._recordData[this._params.name]\n  const newData = messageParser.convertTyped(msg.data[3])\n  let jsonPath\n  let data\n\n  if (newData instanceof Error) {\n    return newData\n  }\n\n  if (currentData === null) {\n    return new Error(`Tried to apply patch to non-existant record ${msg.data[0]}`)\n  }\n\n  if (typeof currentData !== UNDEFINED && currentData !== LOADING) {\n    jsonPath = new JsonPath(msg.data[2])\n    data = JSON.parse(JSON.stringify(currentData._d))\n    jsonPath.setValue(data, newData)\n    return data\n  }\n  this._loadRecord(this._params.name)\n}\n\n/**\n * Returns or loads the record's previous value. Only supported for record\n * write and read operations\n *\n * If getData encounters an error, the rule application might already be destroyed\n * at this point\n *\n * @private\n * @returns {void}\n */\nRuleApplication.prototype._getOldData = function () {\n  if (this._isDestroyed === true || this._params.rule.hasOldData === false) {\n    return null\n  } else if (this._recordData[this._params.name]) {\n    return this._recordData[this._params.name]._d\n  }\n  this._loadRecord(this._params.name)\n}\n\n/**\n * Compile the list of arguments that will be injected\n * into the permission function. This method is called\n * everytime the permission is run. This allows it to merge\n * patches and update the now timestamp\n *\n * @private\n * @returns {void}\n */\nRuleApplication.prototype._getArguments = function () {\n  return [\n    this._crossReferenceFn,\n    this._user,\n    this._getCurrentData(),\n    this._getOldData(),\n    Date.now(),\n    this._params ? this._params.action : null\n  ].concat(this._pathVars)\n}\n\n/**\n * Returns the data for the user variable. This is only done once\n * per rule as the user is not expected to change\n *\n * @private\n * @returns {void}\n */\nRuleApplication.prototype._getUser = function () {\n  return {\n    isAuthenticated: this._params.username !== OPEN,\n    id: this._params.username,\n    data: this._params.authData\n  }\n}\n\n/**\n * Applies the compiled regexp for the path and extracts\n * the variables that will be made available as $variableName\n * within the rule\n *\n * This is only done once per rule as the path is not expected\n * to change\n *\n * @private\n * @returns {Array} pathVars\n */\nRuleApplication.prototype._getPathVars = function () {\n  return this._params.name.match(this._params.regexp).slice(1)\n}\n\n/**\n * Returns true if all loading operations that are in progress have finished\n * and no run has been scheduled yet\n *\n * @private\n * @returns {Boolean}\n */\nRuleApplication.prototype._isReady = function () {\n  let isLoading = false\n\n  for (const key in this._recordData) {\n    if (this._recordData[key] === LOADING) {\n      isLoading = true\n    }\n  }\n\n  return isLoading === false && this._runScheduled === false\n}\n\n/**\n * Loads a record with a given name. This will either result in\n * a onLoadComplete or onLoadError call. This method should only\n * be called if the record is not already being loaded or present,\n * but I'll leave the additional safeguards in until absolutely sure.\n *\n * @param   {String} recordName\n *\n * @private\n * @returns {void}\n */\nRuleApplication.prototype._loadRecord = function (recordName) {\n  /* istanbul ignore next */\n  if (this._recordData[recordName] === LOADING) {\n    return\n  }\n  /* istanbul ignore next */\n  if (typeof this._recordData[recordName] !== UNDEFINED) {\n    this._onLoadComplete(recordName, this._recordData[recordName])\n    return\n  }\n\n  this._recordData[recordName] = LOADING\n\n  this._params.recordHandler.runWhenRecordStable(\n    recordName,\n    this._createNewRecordRequest.bind(this)\n  )\n}\n\n/**\n * Load the record data from the cache for permissioning. This method should be\n * called once the record is stable – meaning there are no remaining writes\n * waiting to be written to the cache.\n *\n * @param   {String} recordName\n *\n * @private\n * @returns {void}\n */\nRuleApplication.prototype._createNewRecordRequest = function (recordName) {\n  // eslint-disable-next-line\n  new RecordRequest(\n    recordName,\n    this._params.options,\n    null,\n    this._onLoadComplete.bind(this, recordName),\n    this._onLoadError.bind(this, recordName)\n  )\n}\n\n/**\n * This method is passed to the rule function as _ to allow crossReferencing\n * of other records. Cross-references can be nested, leading to this method\n * being recoursively called until the either all cross references are loaded\n * or the rule has finally failed\n *\n * @param   {String} recordName\n *\n * @private\n * @returns {void}\n */\nRuleApplication.prototype._crossReference = function (recordName) {\n  const type = typeof recordName\n\n  if (type !== UNDEFINED && type !== STRING) {\n    this._onRuleError(`crossreference got unsupported type ${type}`)\n  } else if (type === UNDEFINED || recordName.indexOf(UNDEFINED) !== -1) {\n    return\n  } else if (this._recordData[recordName] === LOADING) {\n    return\n  } else if (this._recordData[recordName] === null) {\n    return null\n  } else if (typeof this._recordData[recordName] === UNDEFINED) {\n    this._loadRecord(recordName)\n  } else {\n    return this._recordData[recordName]._d\n  }\n}\n\nmodule.exports = RuleApplication\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/permission/rule-cache.js":"'use strict'\n\n/**\n * This cache stores rules that are frequently used. It removes\n * unused rules after a preset interval\n *\n * @constructor\n * @param {Object} options deepstream options\n */\nconst RuleCache = function (options) {\n  this._options = options\n  this._data = {}\n  setInterval(this._purge.bind(this), options.cacheEvacuationInterval)\n}\n\n/**\n * Empties the rulecache completely\n *\n * @public\n * @returns {void}\n */\nRuleCache.prototype.reset = function () {\n  this._data = {}\n}\n\n/**\n * Checks if an entry for a specific rule in a specific section is\n * present\n *\n * @param   {String}  section e.g. record, event or rpc\n * @param   {String}  name    the name of the record, event or rpc\n * @param   {String}  type    the type of the action, e.g. read, write, subscribe\n *\n * @public\n * @returns {Boolean}\n */\nRuleCache.prototype.has = function (section, name, type) {\n  return !!this._data[this._toKey(section, name, type)]\n}\n\n/**\n * Resets the usage flag and returns an entry from the cache\n *\n * @param   {String}  section e.g. record, event or rpc\n * @param   {String}  name    the name of the record, event or rpc\n * @param   {String}  type    the type of the action, e.g. read, write, subscribe\n *\n * @public\n * @returns {Object} rule\n */\nRuleCache.prototype.get = function (section, name, type) {\n  const key = this._toKey(section, name, type)\n  this._data[key].isUsed = true\n  return this._data[key].rule\n}\n\n\n/**\n * Adds an entry to the cache\n *\n * @param   {String}  section e.g. record, event or rpc\n * @param   {String}  name    the name of the record, event or rpc\n * @param   {String}  type    the type of the action, e.g. read, write, subscribe\n * @param   {Object}  rule the result of a rule lookup\n *\n * @public\n * @returns {Object} rule\n */\nRuleCache.prototype.set = function (section, name, type, rule) {\n  this._data[this._toKey(section, name, type)] = {\n    rule,\n    isUsed: true\n  }\n}\n\n/**\n * Creates a key from the various set parameters\n *\n * @param   {String}  section e.g. record, event or rpc\n * @param   {String}  name    the name of the record, event or rpc\n * @param   {String}  type    the type of the action, e.g. read, write, subscribe\n *\n * @public\n * @returns {String} key\n */\nRuleCache.prototype._toKey = function (section, name, type) {\n  return `${section}_${name}_${type}`\n}\n\n/**\n * This method is called repeatedly on an interval, defined by\n * cacheEvacuationInterval.\n *\n * If a rule in the cache has been used in the last interval, it sets its isUsed flag to false.\n * Whenever the rule is used, the isUsed flag will be set to true\n * Any rules that haven't been used in the next cycle will be removed from the cache\n *\n * @private\n * @returns {void}\n */\nRuleCache.prototype._purge = function () {\n  for (const key in this._data) {\n    if (this._data[key].isUsed === true) {\n      this._data[key].isUsed = false\n    } else {\n      delete this._data[key]\n    }\n  }\n}\n\nmodule.exports = RuleCache\n","/home/travis/build/npmtest/node-npmtest-deepstream.io/node_modules/deepstream.io/src/permission/open-permission-handler.js":"'use strict'\n\nconst EventEmitter = require('events').EventEmitter\n\n/**\n * The open permission handler allows any action to occur without applying\n * any permissions.\n *\n * @class OpenPermissionHandler\n */\nmodule.exports = class OpenPermissionHandler extends EventEmitter {\n  /**\n  * @param {String} type exposes the type for logging purposes\n  */\n  constructor () {\n    super()\n    this.type = 'none'\n    this.isReady = true\n  }\n\n  /**\n  * Allows any action by an user\n  *\n  * @param   {String}   username the name of the connected user, as specified in isValidUser\n  * @param   {Object}   message  a parsed deepstream message\n  * @param   {Function} callback the callback to provide the result\n  * @param   {[Object]}   authData additional optional authData as passed to isValidUser\n  *\n  * @public\n  * @implements {PermissionHandler.isValidUser}\n  * @returns {void}\n  */\n  canPerformAction (username, message, callback, authData) { // eslint-disable-line\n    callback(null, true)\n  }\n}\n"}